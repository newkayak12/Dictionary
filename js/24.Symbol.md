# Symbol
JS는 6개의 타입을 가지고 있었다.
- Boolean
- null
- undefined
- Number
- String
- Object

Symbol은 이름 충돌 위험이 없는 유일한 객체의 프로퍼티 키(property Key)를 만들기 위해서 사용한다. 


## 생성
- Symbol()
- Symbol.for()
- Symbol.iterator

### Symbol()
이때 생성된 Symbol은 객체가 아니라 변경 불가능한 원시 타입의 값이다.
Symbol()은 String, Number, Boolean과 같이 래퍼 객체를 생성하는 생성자 함수와는 달리 `new`를 사용하지 않는다.
```javascript
let mySymbol = Symbol();

let mySymbol2 = Symbol("something");
// Symbol()에 문자열을 줄수 있는데 별다릇 뜻은 없고 주석 같은 개념이다. 
// 디버깅할때 이 심볼이 어느 심볼인지 구분하기 편하게 하기 위한 장치

console.log(mySymbol);        // Symbol()
console.log(typeof mySymbol); // symbol
```

심볼은 유일성이 보장되는 자료형이기 때문에, 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값은 다릅니다.
```javascript
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
//심볼에 붙이는 이름표 역할만 한다.
```

### Symbol.for()
전역 심볼
`Symbol()`은 고유한 심볼을 반환한다. 
`Symbol.for()`은 전역으로 존재하는 `global symbol table`의 목록을 참조한다.
그렇기 때문에 Symbol.for(token String)으로 정의할 때 이미 심볼이 있다면 해당 심볼을 반환하게 된다.
```javascript
// 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 없으면 새로운 Symbol 생성
const s1 = Symbol.for('foo');

// 전역 Symbol 레지스트리에 foo라는 키로 저장된 Symbol이 있으면 해당 Symbol을 반환
const s2 = Symbol.for('foo');

console.log(s1 === s2); // true
```

### Symbol.keyFor()
Symbol.keyFor 은 global symbol table 로부터 존재하는 Symbol의 token string 을 반환합니다.
```javascript
var token = Symbol.for("tokenString");
console.log(Symbol.keyFor(token) === "tokenString"); // true
```

### Symbol.description
Symbol.keyFor가 전역 심볼의 이름을 반환하면, 이건 일반 심볼 이름을 반환합니다.
```javascript
const shareSymbol = Symbol.for('myKey');
console.log(Symbol.keyFor(shareSymbol)); // myKey

const unsharedSymbol = Symbol('myKey');
console.log(Symbol.keyFor(unsharedSymbol)); // undefined
console.log(unsharedSymbol.description); // myKey
```

>
> Symbol 함수는 매번 다른 Symbol 값을 생성하는 것에 반해,
> Symbol.for 메소드는 하나의 Symbol을 생성하여 여러 모듈이 키를 통해 같은 Symbol을 공유할 수 있다.
> Symbol.for 메소드를 통해 생성된 Symbol 값은 반드시 키를 갖는다.
> 이에 반해 Symbol 함수를 통해 생성된 Symbol 값은 키가 없다.
> 
>
> 출처: https://inpa.tistory.com/entry/JS-📚-자료형-Symbol-🚩-정리 [Inpa Dev 👨‍💻:티스토리]
> 

## 심볼은 문자형으로 자동 형변환이 되지 않는다.
