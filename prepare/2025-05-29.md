### **📘 면접 준비 (자동 실행: 2025-05-29)**
  

오늘의 백엔드 인터뷰 연습 질문(난이도 ↓):

---
#### **🔹 Q1. [Spring]**

@Transactional 애노테이션이 내부적으로 어떤 방식으로 트랜잭션을 시작하고 종료하는지 설명해 주세요. 그리고 프록시 방식이 동작하지 않는 경우는 언제인지 설명해 주세요.

---
#### **🔹 Q2. [Kotlin]**


Kotlin에서 sealed class와 enum class의 차이를 설명하고, 백엔드 로직에서 각각을 어떤 상황에 사용하는 것이 적절한지 예시 없이 논리적으로 설명해 주세요.

---
#### **🔹 Q3. [MySQL]**

다음과 같은 쿼리에서 WHERE 절과 HAVING 절의 차이를 설명하세요. 또한 HAVING을 사용하는 상황을 일반적인 조건 필터링과 구분하여 설명해 주세요.



1. AOP로 작동하며 메소드를 begin tran, commit이 있는 블록 사이에서 실행시킨다.

기본적으로 프록시로 작동하나. 메소드가 protected, private 등이면 작동하지 않는다.

propagation이 NOT_SUPPORTED 등이면 동작하지 않는다.

  

2. sealed class는 상속에대한 제한사항을 두는 클래스이고 enum은 열거형에 대한 지정을 하는 클래스다. 따라서 sealed는 무분별한 상속을 막는 정책적 방향을 표현하는 데 중점을 두고 enum은 코드, 타입, 상태 등을 표현하는 데 사용한다.

  

3. where은 select에 대한 결과를 바탕으로, having은 group by를 하면서 만든 임시테이블을 바탕으로 filtering을 진행한다.

### **개별 피드백**

1. **Q1: @Transactional 동작 방식** – **8/10**
    
    - AOP 기반 트랜잭션 경계 설명 적절 ✔
        
    - 프록시 한계(NOT_SUPPORTED, protected 메서드 등) 언급 ✔
        
    - **키워드**: _proxy vs CGLIB_, _transaction manager_, _propagation_
        
    
2. **Q2: sealed class vs enum class** – **8/10**
    
    - 상속 제한 vs 열거형 목적 명확 ✔
        
    - 사용 맥락 설명 적절 ✔
        
    - **키워드**: _sealed for hierarchy_, _enum for fixed set_
        
    
3. **Q3: WHERE vs HAVING** – **9/10**
    
    - 집계 전/후 필터링 차이 정확 ✔
        
    - 임시 테이블 기반 필터링 설명 적절 ✔
        
    - **키워드**: _aggregation filter_, _performance considerations_
        
    

---

💡 **다음 학습 제안**

- **Q1**: 전파 속성(propagation)의 상세 동작, 트랜잭션 예외 처리 흐름
    
- **Q2**: sealed hierarchy 활용 패턴, enum implement interfaces
    
- **Q3**: 인덱스 활용 시 HAVING 절 성능 영향