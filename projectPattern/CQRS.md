# CQRS(Command and Query Responsibility Segregation)
데이터 저장소로부터의 읽기, 업데이트 작업을 분리하는 패턴을 말한다. CQRS를 사용하면 퍼포먼스, 확장성, 보안성을 극대화할 수 있다.
(하는 작업만 하기 때문에?) 또한, 지속적으로 시스템을 발전시켜 나갈 수 있다.



## 기존 문제점
DB를 조회하고 업데이트할 때 같은 데이터 모델이 사용되었다. 이는 유지 보수를 어렵게 할 수 있다. 데이터 조회시 각기 다른 형태의 DTO를 반환하는 다양한 쿼리를 수행할 수 있다.
각기 다른 형태의 DTO에 객체 매핑을 하는 것은 복잡해질 수 있다. 또한 데이터 Insert, Update에 유효성 검사와 비즈니스 로직이 수행되어야 한다.
모든 것을 한 모델에서 하면 필연적으로 복잡해진다.

그 밖에도
1. 읽기/ 쓰기에 데이터 표현들이 서로 일치하지 않는 경우가 많다. 일부 작업에서 사용하지 않는 컬럼/ /속성의 업데이트가 이뤄져야 한다.
2. 동일한 데이터 셋에 대해서 병렬 작업이 수행되면 데이터 경합이 발생할 수 있다.
3. 정보 조회를 위해 요구되는 복잡한 쿼리로 성능에 부정적인 영향을 줄 수 있다. 
4. 하나의 데이터 모델로 읽기/ 쓰기를 모두 수행하기에 보안 관리가 복잡해질 수 있다.

## 해결책으로서 CQRS
읽기/ 쓰기를 다른 모델로 분리한다. Command로 쓰고 Query로 읽는다.

1. Command는 데이터 중심이 아닌 행위 중심이 되어야 한다. 예약할 때, '시간이 예약 상태로 변경된다.'가 아닌 '시간 예약'과 같이 생성된다.
2. Command는 비동기로 큐에 쌓인 후 수행된다.
3. Query는 DB를 결코 수정하지 않는다. 쿼리는 DTO 만을 반환한다.

이렇게 읽기/ 쓰기를 격리할 수 있다. 하지만 CQRS는 ORM을 통해서 DB 스키마로부터 generate 하기 어렵다.
혹은 더 확실하기 물리적으로 읽기/ 쓰기를 분리할 수도 있다. [MaterializedView](#materialized-view)를 가지는 read only 스키마를 가질 수 있다. 혹은
아예 다른 데이터 타입 저장소를 사용할 수도 있다. 쓰기는 RDBMS, 읽기는 Mongo같은 NoSQL를 사용하는 것이다.

보통 이런 경우 쓰기 이벤트 발생 시 싱크를 맞춘다. DB 업데이트와 이벤트 발행은 반드시 하나의 트랜잭션에서 이뤄져야 한다.
결과적으로 레플리카든 이기종이든 읽기/ 쓰기를 분리하는데 관심사를 둔다. 

## 장점
1. 독립적인 스케일링 : 읽기/ 쓰기에 대해서 각각 독립적으로 스케일링할 수 있게 해준다. Lock을 줄여준다.
2. 최적화된 스키마 : 읽기/ 쓰기에 최적화된 스키마를 사용할 수 있게 해준다.
3. 보안 : 읽기/ 쓰기를 분리하고 보안 관리가 용이해진다.
4. 관심사 분리: 읽기/ 쓰기를 분리해서 유지보수를 쉽게 해준다. 보통 쓰기에 복잡한 비즈니스 로직이 들어간다.
5. 간단한 쿼리 읽기 : 읽기 저장소으 MaterialView로 join 등을 줄일 수 있다.


## 단점
1. 복잡성: 기본 아이디어는 간단하지만 EventSourcing이 들어가면 복잡해진다.
2. 메시징: 필수는 아니지만 Command 수행과 이벤트 발행이 보편적이다. 메시지 실패나 중복 메시지에 대한 처리가 필요하다.
3. 데이터 일관성: 읽기/ 쓰기의 싱크가 중요하다. 딜레이가 발생해서 읽기/ 쓰기 데이터 일관성 문제가 발생할 수 있다. 

## 사용해야할 경우
1. 많은 사용자가 동일한 데이터에 병렬로 액세스하는 경우. CQRS는 도메인 레벨에서서 병합 충동을 최소화할 수 있도록 세분화된 Command를 정의하는 것이 가능하게 해준다.
2. CQRS에서는 쓰기 모델은 비즈니스 로직, 유효성 검사 등을 모두 간진 완전한 명령(Command) 처리 기능을 가진다. 쓰기 모델은 객체들의 집합을 한 단위에서 다룰 수 있고 
이 객체들이 항상 일관된 상태를 가지도록 보장할 수 있다. 읽기 로직은 유효성 검사 없이 DTO만 반환하게 된다. 
3. 데이터 읽기 성능이 쓰기 성능과 별도 조정이 가능해야할 때, 특히 읽기의 수가 쓰기의 수보다 훨씬 많을 때, 이 경우 필요한 모델만 스케일 아웃할 수 있다.
4. 다른 시스템과의 통합, 특히 이벤트 소싱과 결합할 때.

## 사용하지 않는게 좋은 경우
1. 비교적 단순한 CRUD, 비즈니스 로직을 가진 경우

## 이벤트 소싱과 CQRS
CQRS는 `이벤트 소싱`과 자주 쓰인다. CQRS는 분리된 읽기/ 쓰기 모델을 가지고, 각자 작업에 최적화 되어 있으며, 저장소도 다른 경우가 대부분이다.
이벤트 소싱과 CQRS를 함께 사용할 때, 이벤트 저장소가 쓰기 모델이 되며, 이는 메인 저장소가 된다. 읽기 모델은 일반적으로 반정규화된 Materialized view를 제공한다.
이 뷰들은 각자의 요구사항에 최적화 되어 있다.

특정 시점의 실제데이터를 사용하는 것 대신 쓰기 저장소로 이벤트 스트림을 사용하는 것은 하나의 집계에 대한 병합 충돌을 방지하고 성능과 확장성을 극대화 시켜준다. 
이벤트 저장소가 결국 메인 저장소고 materializeView는 일종의 읽기 전용 캐시이기 떄문에 새로운 형태로 생성하는 것도 가능하다.

## 유의 사항
1. 읽기/ 쓰기가 분리되어 있다면 저장소 수정 및 Materialize View 반영까지 딜레이가 있을 수 있다.
2. 이 패턴은 복잡성이 높다. 다만 EventSourcing을 사용했을 때 도메인 모델링이 용이하고 데이터 변경 이벤트들이 보존되기 떄문에 뷰를 쉽게 리빌딩할 수 있다는 장점이 있다.
3. Materialize View를 만드는데 오랜 실행이나 리소스가 필요할 수 있다. 

--------
<a href="#materialized-view">MaterializedView</a> : 쿼리 결과를 수행 속도, 비용 절감을 위해서 Table로 미리 집계하여 해당 테이블을 조회하도록 하는 것이다.