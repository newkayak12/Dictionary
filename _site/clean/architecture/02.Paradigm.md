# 패러다임


> ### 패러다임, paradigm
> <sub>(명사)</sub> 
> 
> 한 시대의 사람들의 견해나 사고를 근본적으로 규정하고 있는 인식의 체계. 또는, 사물에 대한 이론적인 틀이나 체계. 순화어는 `틀'.

- 패러다임은 언어에 대체적으로 독립적이다.
- 기법적으로 **금지, 제약**에 대한 내용을 담고 있는 것이다.
- 보통 세 가지, ***Structured***, ***Object-oriented***, ***functional***이 있다.

> ## Summary
> - 구조적 프로그래밍 : 제어 흐름의 직접적인 전환에 대해서 규칙을 부과한다.
> - 객체 지향 프로그래밍
>   - 함수 포인터 사용에 대한 규칙을 부과한다.( 다형성 )
>   - 제어 흐름에 대한 간접적인 전환에 대해서 규칙을 부과한다.
> - 함수형 프로그래밍
>   - 람다 계산법을 수용하고 할당문에 대한 규칙을 부과한다.
> ---
> - 결론적으로 ***무엇을 하지 말아야 하는가?*** 에 초점을 둔다.


## 구조적 프로그래밍
- 구조적 프로그래밍을 통해서 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있고 이를 기능적으로 분해할 수 있음을 뜻한다.
- 모든 프로그램은 sequence, selection, iteration 이 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 즉, 커보이는 기능을 반복적으로 저수준 함수로 분해할 수 있고 분해 과정을 반복적으로 진행할 수 있다.
- 이를 기반으로 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능으로 세분화할 수 있음을 의미한다.

## 객체 지향 프로그래밍
- Object-Oriented는 '데이터와 함수의 조합', '실제 시계를 모델링하는 방법' 이라고 말한다. 이는 다소 모호한 감이 없지 않다. 
- 'encapsulation', 'inheritance', 'polymorphism' 이 세 가지에 기대는 경우도 있다.
  > ##### encapsulation
  > - 구분선 바깥에서 데이터를 은닉하고, 일부 함수만 외부로 노출한다.
  > - C에서는 헤더와 구현은 분리하는 방식으로 캡슐화를 구현했다.
  > - C++, java에서는 멤버 변수를 헤더에 명시하거나 혹은 헤더, 구현체를 분리하는 방식을 버렸다.
  > - 의외로 OO 언어가 캡슐화를 강제하지는 않는다. (실제로 자바는 불완전하지만 접근제어로 막는 식으로 구현한다. 그러나 javabean 명세에 getter, setter를 두기도 하고 무분별하게 선언해서 거의 망가진 상태다.)
  > - 실제로는 완벽한 캡슐화를 약화시켜왔다는 것을 알 수 있다.
  > - 따라서 캡슐화가 OO의 필수 조건이라는 것은 납득하기 어렵다.
  >
  > ##### inheritance
  > - 상속은 단순하게 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일이다. (서브타이핑은 조금 내려놓자.)
  > - 상속 개념 자체는 OO 언어 전에도 있었고 약간의 트릭을 통해서 사용했다고 한다.
  > - 단순히 OO 언어에서는 공식적으로 지원할뿐이다.
  > - 결과적으로 상속이 OO의 필수 조건이라는 것은 납득하기 어렵다.
  > 
  > ##### polymorphism
  > - 서브 타이핑을 통해서 함수를 가리키는 포인터를 응용한 형태다.
  > - 다형적 행위를 수행하는 방법을 포인터가 아니라 더 안전하고 편리하게 사용할 수 있게 한다.
  > - 사실 이전에 지원했기에 크게 변한 점이 없다.
  > - 그러나 포인터의 위험성을 숨기고 실수할 위험을 줄여준다. 
  > - OO 언어가 가진 차별점이다. 이런 이유로 OO는 제어 흐름을 간접적으로 전환하는 규칙을 부과한다는 사안을 '다형성'에서 찾을 수 있다.
- 다형성을 이용해서 OO에서는 plugin architecture를 적용할 수 있게 됐다.
- 다형성을 기반으로 **DIP**도 구현할 수도 있게 됐다.
- 전형적인 방법은 의존성 방향과 제어 흐름이 같다. DIP는 소스 코드 의존성과 제어 흐름과 반대가 된다.
- 즉, OO에서는 꼭 소스코드 의존성이 제어흐름과 방향이 일치되지 않는다. 오히려 원하는 방향으로 설정할 수 있다.
- OO가 가진 차별점이다. 
- 정리하면 OO란 다형성을 이용해서 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
- 또한 이를 바탕으로 제어 흐름을 간접적으로 제한할 수 있도록 규칙을 부과한다.

## 함수형 프로그래밍
- 함수형 프로그래밍은 가변 변수를 상정하지 않는다. 한 번 초기화되면 절대로 변하지 않는다.
- 아케텍쳐에서 변수의 가변성을 배제하면 경합(race) 조건, 교착 상태(deadlock), 동시 업데이트(concurrent update) 문제에서 자유로워질 수 있다.
- 결론적으로 함수형 프로그래밍은 변수 할당에 규칙을 부과한다.


---
## 결론적으로 요약하면 이렇다.
> 1. 구조적 프로그래밍은 **제어 흐름의 직접적인 전환에 부과되는 규율**이다.
> 2. 객체 지향 프로그래밍은 **제어 흐름의 간접적인 전환에 부과되는 규율**이다.
> 3. 함수형 프로그래밍은 **변수 할당에 부과되는 규율**이다.

- 결과적으로 보면 다 제한이다. 뭔가 특별한 능력을 주는 것이 아니다.