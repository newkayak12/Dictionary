# 완전 탐색 
모든 경우의 수를 다 체크해서 정답을 찾는 방법

## 적용
1) 해결하고자 하는 문제의 가능한 경우의 수를 대략적으로 계산
2) 모든 가능성 고려
    - BruteForce -> 반복/ 조건문으로 대입
    - 순열(Permutation) -> n의 원소 중 r개의 원소를 중복 허용 없이 나열
    - 재귀호출
    - 비트마스크 -> 2진수 표현 기법을 활용
    - BFS, DFS
3) 적용


A. bruteforce : 무차별 대입


B. 순열(nPr) : 임의의 수열이 있을 때, 다른 순서로 연산하는 방법 [1,2,3]과 [3,2,1]를 보는 순서가 차이가 있음이 중요한 경우
![](img/스크린샷 2024-02-05 22.23.56.png)


C. 재귀: 반복호출 + 탈출조건으로 결과를 구한다. 
[DP](./DynamicProgramming.md)와 유사해보이지만 DP는 이전의 상태를 기억하고 시도에서 실패 시 이전 상황에서부터 다음 경우의 수를 탐색한다는 것이 다르다.


D. [비트 마스크](./bit/BitOperator.md)
bit 연산으로 부분 집합을 표현하는 방법을 의미한다.

|  A  |  B  | A&B | A￨B | ~A  | A^B |
|:---:|:---:|:---:|:---:|:---:|:---:|
|  0  |  0  |  0  |  0  |  1  |  0  |
|  0  |  1  |  0  |  1  |  1  |  1  |
|  1  |  0  |  0  |  1  |  0  |  1  |
|  1  |  1  |  1  |  1  |  0  |  0  |

shift (>> ,<< ) 비트를 특정 값만큼 민다. 빈 값은 0으로 채운다.
1<sub>(2)</sub><<2 = 1000<sub>(2)</sub>

E. [BFS](tree/BFS.md), [DFS](tree/DFS.md)
