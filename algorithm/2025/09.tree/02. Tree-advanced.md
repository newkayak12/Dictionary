## 1. íŠ¸ë¦¬ì˜ ì§€ë¦„(Diameter)
- íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê²½ë¡œ ê¸¸ì´ì´ë‹¤.
- (ë³´í†µ ê¸¸ì´ëŠ” ê°„ì„  ìˆ˜)
```text
    1
   / \
  2   3
     / \
    4   5
         \
          6
```
- ìœ„ ê·¸ë˜í”„ì—ì„œ ë…¸ë“œ 2 -> 1 -> 3 -> 5 -> 6ì´ ê°€ì¥ ê¸´ ê²½ë¡œë‹¤.
- ì´ ê°„ì„  ìˆ˜ëŠ” 4ì´ë‹¤.
- ìœ„ì™€ ê°™ì€ ê²ƒì´ íŠ¸ë¦¬ì˜ ì§€ë¦„ì´ë‹¤.

### 1.1 ì–´ë–»ê²Œ êµ¬í• ê¹Œ?
- DFSë¥¼ ë‘ ë²ˆ ì§„í–‰í•œë‹¤. 
- ë³´í†µ rootì—ì„œ ì‹œì‘í•´ì„œ ê°€ì¥ ë¨¼ ë…¸ë“œ í•œ ë²ˆ
- ê·¸ë‹¤ìŒ rootì—ì„œ ë‹¤ì‹œ ê°€ì¥ ë¨¼ ë…¸ë“œ í•œ ë²ˆ 
- ì´ ë‘˜ê¹Œì§€ ê°€ëŠ” ê±°ë¦¬ == íŠ¸ë¦¬ì˜ ì§€ë¦„
- ì‹œê°„ ë³µì¡ë„ O(n)

### 1.2 êµ¬í˜„
```kotlin
class DiameterOfTree {  
    /**  
     * ğŸ§ª ì‹¤ìŠµ ë¬¸ì œ  
     *  
     * ğŸ¯ [ë¬¸ì œ] íŠ¸ë¦¬ì˜ ì§€ë¦„ êµ¬í•˜ê¸°  
     *  
     * Nê°œì˜ ë…¸ë“œë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬ê°€ ìˆë‹¤.  
     * íŠ¸ë¦¬ëŠ” ê°„ì„ ë§ˆë‹¤ ê°€ì¤‘ì¹˜ê°€ ìˆê³ , ì—°ê²°ëœ ë‘ ë…¸ë“œì™€ ê±°ë¦¬(ê°€ì¤‘ì¹˜)ê°€ ì£¼ì–´ì§„ë‹¤.  
     * ì´ íŠ¸ë¦¬ì˜ ì§€ë¦„(ê°€ì¥ ê¸´ ê²½ë¡œì˜ ê±°ë¦¬)ì„ êµ¬í•˜ì‹œì˜¤.  
     *    
     * ğŸ”¸ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„: ë…¸ë“œì˜ ìˆ˜ N (2 â‰¤ N â‰¤ 10,000)   
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° N-1ê°œ ì¤„:  
     *   u v w â†’ ë…¸ë“œ uì™€ vê°€ ê±°ë¦¬ê°€ wì¸ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ë¨  
     *  
     * ğŸ”¸ ì¶œë ¥ í˜•ì‹  
     *  â€¢  íŠ¸ë¦¬ì˜ ì§€ë¦„ (ê°€ì¥ ë¨¼ ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê±°ë¦¬)  
     * ğŸ”¹ ì˜ˆì œ ì…ë ¥  
     * ```text  
     * 5   
     * 1 2 3  
     * 1 3 2   
     * 3 4 4    
     * 3 5 6    
     * ```    
     *     
     * ğŸ”¹ ì˜ˆì œ ì¶œë ¥  
     * 11  
     * 
     */  
 
    @Test  
    fun solution() {  
        val numberOfNode = 5  
        val nodes = listOf(  
            Triple(1, 2, 3),  
            Triple(1, 3, 2),  
            Triple(3, 4, 4),  
            Triple(3, 5, 6),  
        )  
        val expected = 11  
  
        assertEquals(expected, diameterUseRecursive(5, nodes))  
        assertEquals(expected, diameterUseStack(5, nodes))  
    }  
  
    private inner class Node(  
        val node: Int,  
        val score: Int  
    )  
  
  
    private fun diameterUseRecursive(numberOfNode: Int, table: List<Triple<Int, Int, Int>>): Int {  
        val graph = Array<MutableList<Node>>(numberOfNode + 1) { mutableListOf() }  
  
        for ((parent, child, score) in table) {  
            graph[parent].add(Node(child, score))  
            graph[child].add(Node(parent, score))  
        }  
  
  
        val (deepestIndex, _) = recursive(1, graph, BooleanArray(numberOfNode + 1) {  
            it == 1  
        }, 0)  
  
        val (_, farthestScore) = recursive(deepestIndex, graph, BooleanArray(numberOfNode + 1) {  
            it == deepestIndex  
        }, 0)  
  
        return farthestScore  
    }  
  
    private fun recursive(  
        node: Int,  
        graph: Array<MutableList<Node>>,  
        visited: BooleanArray,  
        score: Int  
    ): Pair<Int, Int> {  
        val now = graph[node]  
        var index = node  
        var maxScore = score  
  
        for (element in now) {  
  
            if (visited[element.node]) continue  
            visited[element.node] = true  
            val (nextIndex, nextScore) = recursive(element.node, graph, visited, score + element.score)  
            if (maxScore < nextScore) {  
                maxScore = nextScore  
                index = nextIndex  
            }  
  
        }  
  
        return index to maxScore  
    }  
  
    private fun diameterUseStack(numberOfNode: Int, table: List<Triple<Int, Int, Int>>): Int {  
        val graph = Array<MutableList<Node>>(numberOfNode + 1) { mutableListOf() }  
  
        for ((parent, child, score) in table) {  
            graph[parent].add(Node(child, score))  
            graph[child].add(Node(parent, score))  
        }  
  
  
        val (deepestIndex, _) = stack(numberOfNode, 1, graph, 0)  
  
        val (_, farthestScore) = stack(numberOfNode, deepestIndex, graph, 0)  
  
        return farthestScore  
    }  
  
    private fun stack(  
        numberOfNode: Int,  
        startNodeIndex: Int,  
        graph: Array<MutableList<Node>>,  
        score: Int  
    ): Pair<Int, Int> {  
        val stack = ArrayDeque<Pair<Int, Int>>()  
        stack.addLast(startNodeIndex to score)  
  
        val visited = BooleanArray(numberOfNode + 1) { it == startNodeIndex }  
        var deepestScore = score  
        var deepestIndex = startNodeIndex  
  
        while (stack.isNotEmpty()) {  
            val (node, score) = stack.removeLast()  
  
            for (next in graph[node]) {  
  
                if (visited[next.node]) continue  
                if (deepestScore < next.score + score) {  
                    deepestScore = next.score + score  
                    deepestIndex = next.node  
                }  
                stack.addLast(next.node to next.score + score)  
                visited[next.node] = true  
  
            }  
        }  
  
  
        return deepestIndex to deepestScore  
    }  
}
```

## 2. ë…¸ë“œ ê°„ ê±°ë¦¬ ê³„ì‚°\
- íŠ¸ë¦¬ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,
- ì—¬ëŸ¬ ìŒì˜ ë…¸ë“œ u, vì— ëŒ€í•´ì„œ u -> v ê°„ ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤.
### 2.1. í•µì‹¬ ê°œë…
- íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ê¸° ë•Œë¬¸ì— u -> v ê°„ ê±°ë¦¬ëŠ” í•­ìƒ ìœ ì¼
- ë”°ë¼ì„œ DFS ë˜ëŠ” BFSë¡œ í•œ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œê¹Œì§€ì˜ ê²½ë¡œ ê¸¸ì´ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì™€ ê°™ë‹¤.
### 2.2. ê³„ì‚° ë°©ì‹
#### 1. DFS í•œ ë²ˆë§ˆë‹¤ ê³„ì‚°(ë‹¨ìˆœ ì ‘ê·¼)
- ë§¤ ì¿¼ë¦¬ë§ˆë‹¤ DFSë¡œ uì—ì„œ vê¹Œì§€ ì´ë™í•˜ë©´ì„œ ê±°ë¦¬ ëˆ„ì  
- êµ¬í˜„ì€ ì‰½ì§€ë§Œ ì‹œê°„ ì´ˆê³¼ ê°€ëŠ¥ì„± ë†’ìŒ
#### 2. ì‚¬ì „ ì „ì²˜ë¦¬ + ìµœì†Œ ê³µí†µ ì¡°ìƒ(LCA) ê¸°ë°˜ ê³„ì‚°
- ë£¨íŠ¸ë¡œë¶€í„° ê° ë…¸ë“œê¹Œì§€ ê±°ë¦¬ ë°°ì—´ì„ ë¯¸ë¦¬ êµ¬í•˜ê³ 
- LCA(u,v)ë¥¼ ì°¾ì€ ë‹¤ìŒ
- `distance(u,v) = dist[u] + dist[v] - 2 x dist[LCA(u,v)]`
- í›¨ì”¬ ë¹ ë¦„
### 2.3. êµ¬í˜„
#### 2.3.1 DFS
```kotlin
class DistanceDFS {  
    /**  
     * ğŸ§ª ì‹¤ìŠµ ë¬¸ì œ ì œì‹œ  
     *  
     * ğŸ¯ [ë¬¸ì œ] ë…¸ë“œ ê°„ ê±°ë¦¬ ê³„ì‚°  
     *  
     * íŠ¸ë¦¬ê°€ ì£¼ì–´ì§„ë‹¤. ì´í›„ Qê°œì˜ ì¿¼ë¦¬ê°€ ì£¼ì–´ì§„ë‹¤.  
     * ê° ì¿¼ë¦¬ëŠ” ë‘ ì •ì  u, vë¡œ ì£¼ì–´ì§€ë©°, ë‘ ì •ì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ì¶œë ¥í•˜ë¼.  
     *    
     * ğŸ”¸ ì…ë ¥  
     *  â€¢  ì²« ì¤„: N (ë…¸ë“œ ìˆ˜), Q (ì¿¼ë¦¬ ìˆ˜)  
     *  â€¢  ì´í›„ N-1ì¤„: ê°„ì„  ì •ë³´ â†’ u v w (uì™€ v ì‚¬ì´ ê°„ì„ , ê°€ì¤‘ì¹˜ w) 
     *  â€¢  ì´í›„ Qì¤„: u v (ê±°ë¦¬ êµ¬í•  ë…¸ë“œ ìŒ)  
     *     
     * ğŸ”¸ ì¶œë ¥  
     *  â€¢  ê° ì¿¼ë¦¬ë§ˆë‹¤ u ~ v ê±°ë¦¬ ì¶œë ¥  
     *  
     * ì˜ˆì œ ì…ë ¥:  
     * 5 3    
     *     
     * 1 2 3  
     * 1 3 2  
     * 3 4 4    
     * 3 5 6    
     *    
     * ```text  
     *     
     *      1   
     * (3)/   \(2)    
     *   2     3  
     *     (4)/  \(6)   
     *       4    5     
     * ```    
     *    
     * 2 4    
     * 4 5    
     * 2 5    
     * ì˜ˆì œ ì¶œë ¥:  
     * 9    
     * 10    
     * 11    
     * */  
    
    @Test  
    fun solution1() {  
        val countOfNode = 5  
        val table = arrayOf(  
            Triple(1, 2, 3),  
            Triple(1, 3, 2),  
            Triple(3, 4, 4),  
            Triple(3, 5, 6),  
        )  
        val start = 2  
        val end = 4  
        val score = 9  
  
        assertEquals(score, distanceDFSUseRecursive(countOfNode, start, end, table))  
        assertEquals(score, distanceDFSUseStack(countOfNode, start, end, table))  
    }  
  
    @Test  
    fun solution2() {  
        val countOfNode = 5  
        val table = arrayOf(  
            Triple(1, 2, 3),  
            Triple(1, 3, 2),  
            Triple(3, 4, 4),  
            Triple(3, 5, 6),  
        )  
        val start = 4  
        val end = 5  
        val score = 10  
  
        assertEquals(score, distanceDFSUseRecursive(countOfNode, start, end, table))  
        assertEquals(score, distanceDFSUseStack(countOfNode, start, end, table))  
    }  
  
    @Test  
    fun solution3() {  
        val countOfNode = 5  
        val table = arrayOf(  
            Triple(1, 2, 3),  
            Triple(1, 3, 2),  
            Triple(3, 4, 4),  
            Triple(3, 5, 6),  
        )  
        val start = 2  
        val end = 5  
        val score = 11  
  
        assertEquals(score, distanceDFSUseRecursive(countOfNode, start, end, table))  
        assertEquals(score, distanceDFSUseStack(countOfNode, start, end, table))  
    }  
  
    data class Node(  
        val node: Int,  
        val score: Int  
    )  
  
    private fun distanceDFSUseRecursive(  
        countOfNode: Int,  
        start: Int,  
        end: Int,  
        array: Array<Triple<Int, Int, Int>>  
    ): Int {  
        val graph = Array<MutableList<Node>>(countOfNode + 1) { mutableListOf() }  
  
        for ((from, to, score) in array) {  
            graph[from].add(Node(to, score))  
            graph[to].add(Node(from, score))  
        }  
  
        val (_, score, isReached) = recursive(start, end, graph, 0, BooleanArray(countOfNode + 1) { it == start })  
        return if (isReached) score else -1  
    }  
  
    private fun recursive(  
        start: Int,  
        end: Int,  
        graph: Array<MutableList<Node>>,  
        score: Int,  
        visited: BooleanArray  
    ): Triple<Int, Int, Boolean> {  
        if (start == end) return Triple(start, score, true)  
        val child = graph[start]  
        var index = start  
        var totalScore = score  
        var isReached = false  
  
        for (element in child) {  
            if (visited[element.node]) continue  
            visited[element.node] = true  
            val (nextIndex, nextScore) = recursive(element.node, end, graph, score + element.score, visited)  
            if (nextIndex == end) {  
                index = nextIndex  
                totalScore = nextScore  
                isReached = true  
  
                break            }  
        }  
  
        return Triple(index, totalScore, isReached)  
    }  
  
  
    private fun distanceDFSUseStack(countOfNode: Int, start: Int, end: Int, array: Array<Triple<Int, Int, Int>>): Int {  
        val graph = Array<MutableList<Node>>(countOfNode + 1) { mutableListOf() }  
  
        for ((from, to, score) in array) {  
            graph[from].add(Node(to, score))  
            graph[to].add(Node(from, score))  
        }  
  
        val (score, isReached) = stack(start, end, graph, 0, BooleanArray(countOfNode + 1) { it == start })  
        return if (isReached) score else -1  
    }  
  
    private fun stack(  
        start: Int,  
        end: Int,  
        graph: Array<MutableList<Node>>,  
        score: Int,  
        visited: BooleanArray  
    ): Pair<Int, Boolean> {  
        val stack = ArrayDeque<Pair<Int, Int>>()  
        stack.addLast(start to score)  
  
        var index = start  
        var totalScore = score  
        var isReached = false  
  
        while (stack.isNotEmpty()) {  
            val (currentNode, currentScore) = stack.removeLast()  
  
            if (currentNode == end) {  
                index = currentNode  
                totalScore = currentScore  
                isReached = true  
                break            }  
  
            for (element in graph[currentNode]) {  
                if (visited[element.node]) continue  
                visited[element.node] = true  
                stack.addLast(element.node to currentScore + element.score)  
            }  
        }  
  
        return totalScore to isReached  
    }  
}
```

## 3. ì„œë¸ŒíŠ¸ë¦¬ì˜ í¬ê¸° ê³„ì‚°