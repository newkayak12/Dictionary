## 1. íŠ¸ë¦¬ì˜ ì§€ë¦„(Diameter)
- íŠ¸ë¦¬ì—ì„œ ê°€ì¥ ë©€ë¦¬ ë–¨ì–´ì§„ ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê²½ë¡œ ê¸¸ì´ì´ë‹¤.
- (ë³´í†µ ê¸¸ì´ëŠ” ê°„ì„  ìˆ˜)
```text
    1
   / \
  2   3
     / \
    4   5
         \
          6
```
- ìœ„ ê·¸ë˜í”„ì—ì„œ ë…¸ë“œ 2 -> 1 -> 3 -> 5 -> 6ì´ ê°€ì¥ ê¸´ ê²½ë¡œë‹¤.
- ì´ ê°„ì„  ìˆ˜ëŠ” 4ì´ë‹¤.
- ìœ„ì™€ ê°™ì€ ê²ƒì´ íŠ¸ë¦¬ì˜ ì§€ë¦„ì´ë‹¤.

### 1.1 ì–´ë–»ê²Œ êµ¬í• ê¹Œ?
- DFSë¥¼ ë‘ ë²ˆ ì§„í–‰í•œë‹¤. 
- ë³´í†µ rootì—ì„œ ì‹œì‘í•´ì„œ ê°€ì¥ ë¨¼ ë…¸ë“œ í•œ ë²ˆ
- ê·¸ë‹¤ìŒ rootì—ì„œ ë‹¤ì‹œ ê°€ì¥ ë¨¼ ë…¸ë“œ í•œ ë²ˆ 
- ì´ ë‘˜ê¹Œì§€ ê°€ëŠ” ê±°ë¦¬ == íŠ¸ë¦¬ì˜ ì§€ë¦„
- ì‹œê°„ ë³µì¡ë„ O(n)

### 1.2 êµ¬í˜„
```kotlin
class DiameterOfTree {  
    /**  
     * ğŸ§ª ì‹¤ìŠµ ë¬¸ì œ  
     *  
     * ğŸ¯ [ë¬¸ì œ] íŠ¸ë¦¬ì˜ ì§€ë¦„ êµ¬í•˜ê¸°  
     *  
     * Nê°œì˜ ë…¸ë“œë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬ê°€ ìˆë‹¤.  
     * íŠ¸ë¦¬ëŠ” ê°„ì„ ë§ˆë‹¤ ê°€ì¤‘ì¹˜ê°€ ìˆê³ , ì—°ê²°ëœ ë‘ ë…¸ë“œì™€ ê±°ë¦¬(ê°€ì¤‘ì¹˜)ê°€ ì£¼ì–´ì§„ë‹¤.  
     * ì´ íŠ¸ë¦¬ì˜ ì§€ë¦„(ê°€ì¥ ê¸´ ê²½ë¡œì˜ ê±°ë¦¬)ì„ êµ¬í•˜ì‹œì˜¤.  
     *    
     * ğŸ”¸ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„: ë…¸ë“œì˜ ìˆ˜ N (2 â‰¤ N â‰¤ 10,000)   
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° N-1ê°œ ì¤„:  
     *   u v w â†’ ë…¸ë“œ uì™€ vê°€ ê±°ë¦¬ê°€ wì¸ ê°„ì„ ìœ¼ë¡œ ì—°ê²°ë¨  
     *  
     * ğŸ”¸ ì¶œë ¥ í˜•ì‹  
     *  â€¢  íŠ¸ë¦¬ì˜ ì§€ë¦„ (ê°€ì¥ ë¨¼ ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê±°ë¦¬)  
     * ğŸ”¹ ì˜ˆì œ ì…ë ¥  
     * ```text  
     * 5   
     * 1 2 3  
     * 1 3 2   
     * 3 4 4    
     * 3 5 6    
     * ```    
     *     
     * ğŸ”¹ ì˜ˆì œ ì¶œë ¥  
     * 11  
     * 
     */  
 
    @Test  
    fun solution() {  
        val numberOfNode = 5  
        val nodes = listOf(  
            Triple(1, 2, 3),  
            Triple(1, 3, 2),  
            Triple(3, 4, 4),  
            Triple(3, 5, 6),  
        )  
        val expected = 11  
  
        assertEquals(expected, diameterUseRecursive(5, nodes))  
        assertEquals(expected, diameterUseStack(5, nodes))  
    }  
  
    private inner class Node(  
        val node: Int,  
        val score: Int  
    )  
  
  
    private fun diameterUseRecursive(numberOfNode: Int, table: List<Triple<Int, Int, Int>>): Int {  
        val graph = Array<MutableList<Node>>(numberOfNode + 1) { mutableListOf() }  
  
        for ((parent, child, score) in table) {  
            graph[parent].add(Node(child, score))  
            graph[child].add(Node(parent, score))  
        }  
  
  
        val (deepestIndex, _) = recursive(1, graph, BooleanArray(numberOfNode + 1) {  
            it == 1  
        }, 0)  
  
        val (_, farthestScore) = recursive(deepestIndex, graph, BooleanArray(numberOfNode + 1) {  
            it == deepestIndex  
        }, 0)  
  
        return farthestScore  
    }  
  
    private fun recursive(  
        node: Int,  
        graph: Array<MutableList<Node>>,  
        visited: BooleanArray,  
        score: Int  
    ): Pair<Int, Int> {  
        val now = graph[node]  
        var index = node  
        var maxScore = score  
  
        for (element in now) {  
  
            if (visited[element.node]) continue  
            visited[element.node] = true  
            val (nextIndex, nextScore) = recursive(element.node, graph, visited, score + element.score)  
            if (maxScore < nextScore) {  
                maxScore = nextScore  
                index = nextIndex  
            }  
  
        }  
  
        return index to maxScore  
    }  
  
    private fun diameterUseStack(numberOfNode: Int, table: List<Triple<Int, Int, Int>>): Int {  
        val graph = Array<MutableList<Node>>(numberOfNode + 1) { mutableListOf() }  
  
        for ((parent, child, score) in table) {  
            graph[parent].add(Node(child, score))  
            graph[child].add(Node(parent, score))  
        }  
  
  
        val (deepestIndex, _) = stack(numberOfNode, 1, graph, 0)  
  
        val (_, farthestScore) = stack(numberOfNode, deepestIndex, graph, 0)  
  
        return farthestScore  
    }  
  
    private fun stack(  
        numberOfNode: Int,  
        startNodeIndex: Int,  
        graph: Array<MutableList<Node>>,  
        score: Int  
    ): Pair<Int, Int> {  
        val stack = ArrayDeque<Pair<Int, Int>>()  
        stack.addLast(startNodeIndex to score)  
  
        val visited = BooleanArray(numberOfNode + 1) { it == startNodeIndex }  
        var deepestScore = score  
        var deepestIndex = startNodeIndex  
  
        while (stack.isNotEmpty()) {  
            val (node, score) = stack.removeLast()  
  
            for (next in graph[node]) {  
  
                if (visited[next.node]) continue  
                if (deepestScore < next.score + score) {  
                    deepestScore = next.score + score  
                    deepestIndex = next.node  
                }  
                stack.addLast(next.node to next.score + score)  
                visited[next.node] = true  
  
            }  
        }  
  
  
        return deepestIndex to deepestScore  
    }  
}
```
