## 1. Tree?
- ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²° ê·¸ë˜í”„
- ë…¸ë“œ Nê°œ ê°„ì„  N-1ê°œë©´ íŠ¸ë¦¬
- ë£¨íŠ¸ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì¸µì ì¸ êµ¬ì¡°ë¥¼ ê°–ëŠ”ë‹¤.

## 2. Tree vs. Graph

| ë¹„êµ í•­ëª© | Tree      | Graph   |
| :---: | --------- | ------- |
| ê°„ì„  ìˆ˜  | n - 1     | ì œí•œ ì—†ìŒ   |
| ë£¨íŠ¸ ì¡´ì¬ | ì¡´ì¬        | ì—†ìŒ      |
|  ì‚¬ì´í´  | ì—†ìŒ        | ì¡´ì¬ ê°€ëŠ¥   |
|  ë°©í–¥ì„±  | ëŒ€ë¶€ë¶„ ë°©í–¥ ìˆìŒ | ë°©í–¥/ ë¬´ë°©í–¥ |
<<<<<<< HEAD
=======

>>>>>>> dict/master
### 2.1 íŠ¸ë¦¬ì˜ êµ¬í˜„?
```kotlin
val tree = Array(N + 1){ mutableListOf<Int>() } //ë…¸ë“œê°€ 1ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ
tree[a].add(b) //aë²ˆ ë…¸ë“œì— b ì—°ê²°
tree[b].add(a) //ë¬´ë°©í–¥ì´ë¯€ë¡œ
```

### 2.2 íŠ¸ë¦¬ì—ì„œ ê° ë…¸ë“œì˜ ë¶€ëª¨ ì°¾ê¸°
- DFSë¥¼ ì´ìš©
```kotlin
package renewal.tree  
  
import org.junit.jupiter.api.Test  
import kotlin.test.assertEquals  
  
class FindParents {  
    /**  
     * âœ… ë¬¸ì œ: íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸°  
     *  
     * â¸»  
     *  
     * â–ªï¸ ë¬¸ì œ ì„¤ëª…  
     *  
     * ë£¨íŠ¸ê°€ 1ë²ˆì¸ íŠ¸ë¦¬ê°€ ì£¼ì–´ì§„ë‹¤.  
     * ê° ë…¸ë“œì˜ ë¶€ëª¨ë¥¼ êµ¬í•´ì„œ ì¶œë ¥í•˜ë¼.  
     *     * â¸»  
     *  
     * â–ªï¸ ì…ë ¥  
     *  â€¢  ì²« ì¤„: ë…¸ë“œ ê°œìˆ˜ N (2 â‰¤ N â‰¤ 100,000)    
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° N-1ì¤„: ê°„ì„  ì •ë³´ a\ b 
     *   
     * â¸»  
     *  
     * â–ªï¸ ì¶œë ¥  
     *  â€¢  2ë²ˆ ë…¸ë“œë¶€í„° Në²ˆ ë…¸ë“œê¹Œì§€, ê° ë…¸ë“œì˜ ë¶€ëª¨ ë…¸ë“œ ë²ˆí˜¸ë¥¼ í•œ ì¤„ì”© ì¶œë ¥  
     *  
     * â¸»  
     *  
     * â–ªï¸ ì˜ˆì‹œ ì…ë ¥  
     * 7  
     * 1 6   
     * 6 3    
     * 3 5   
     * 4 1     
     * 2 4    
     * 4 7    
     *   
     * â¸»  
     *  
     * â–ªï¸ ì˜ˆì‹œ ì¶œë ¥  
     * 4  
     * 6   
     * 1    
     * 3   
     * 1  
     * 4  
     * */  
     
    @Test  
    fun solution() {  
        val node = 7  
        val table = arrayOf(  
            intArrayOf(1, 6),  
            intArrayOf(6, 3),  
            intArrayOf(3, 5),  
            intArrayOf(4, 1),  
            intArrayOf(2, 4),  
            intArrayOf(4, 7),  
        )  
  
        val expected = """  
            4            6            1            3            1            4        """.trimIndent()  
  
        assertEquals(expected, findParents(node, table))  
    }  
  
    private fun findParents(node: Int, table: Array<IntArray>): String {  
        val tree = Array(node + 1) { mutableListOf<Int>() }  
        val parents = Array(node + 1) { 0 }  
  
        for ((a, b) in table) {  
            tree[a].add(b)  
            tree[b].add(a)  
        }  
  
  
        val stack = ArrayDeque<Int>()  
        val visited = BooleanArray(node + 1)  
        stack.add(1)  
        visited[1] = true  
  
        while (stack.isNotEmpty()) {  
            val parent = stack.removeLast()  
  
            for (element in tree[parent]) {  
                if (!visited[element]) {  
                    stack.addLast(element)  
                    visited[element] = true  
                    parents[element] = parent  
                }  
            }  
        }  
  
  
        val builder = StringBuilder()  
        for (i in 2 until parents.size) {  
            builder.append("${parents[i]}\n")  
        }  
  
        return builder.toString().trimIndent()  
    }  
}
```

### 2.3 íŠ¹ì • ë…¸ë“œì—ì„œ rootê¹Œì§€ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°€ê¸°
```kotlin
class ParentToChild {  
    /**  
     * âœ… [íŠ¸ë¦¬ ê°œë…] - ë¶€ëª¨ ë°°ì—´ ì¶”ì ì„ í†µí•œ ë£¨íŠ¸ â†’ ë¦¬í”„ ê²½ë¡œ êµ¬ì„±  
     *  
     *  
     * âœ… ì‹¤ìŠµ ë¬¸ì œ: â€œíŠ¹ì • ë…¸ë“œì—ì„œ ë£¨íŠ¸ê¹Œì§€ì˜ ê²½ë¡œ ì¶œë ¥â€  
     *   
     * â–ªï¸ ë¬¸ì œ ì„¤ëª…  
     *  
     * ë£¨íŠ¸ê°€ 1ë²ˆì¸ íŠ¸ë¦¬ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, íŠ¹ì • ë…¸ë“œ Xë¡œë¶€í„° ë£¨íŠ¸ê¹Œì§€ì˜ ê²½ë¡œë¥¼ ì¶œë ¥í•˜ë¼.  
     *    
     * â–ªï¸ ì…ë ¥  
     * 7  
     * 1 6   
     * 6 3  
     * 3 5    
     * 4 1   
     * 2 4   
     * 4 7   
     * X = 5 
     *    
     * â–ªï¸ ì¶œë ¥  
     * 5 3 6 1  
     */ 


    @Test  
    fun solution() {  
        val node = 7  
        val table = arrayOf(  
            intArrayOf(1, 6),  
            intArrayOf(6, 3),  
            intArrayOf(3, 5),  
            intArrayOf(4, 1),  
            intArrayOf(2, 4),  
            intArrayOf(4, 7),  
        )  
        val x = 5  
        val expected = "5 3 6 1"  
  
        assertEquals(expected, traceTree(node, table, x))  
    }  
  
   private fun traceTree(node: Int, table: Array<IntArray>, target: Int): String {  
        val tree = Array(node + 1) { mutableListOf<Int>() }  
        val parents = Array(node + 1) { 0 }  
  
        for((a, b) in table) {  
            tree[a].add(b)  
            tree[b].add(a)  
        }  
  
        val stack = ArrayDeque<Int>()  
        val visited = BooleanArray(node + 1)  
  
        stack.addLast(1)  
        visited[1] = true  
  
        while(stack.isNotEmpty()) {  
            val parent = stack.removeLast()  
  
            for(element in tree[parent]) {  
                if(!visited[element]) {  
                    stack.addLast(element)  
                    visited[element] = true  
                    parents[element] = parent  
                }  
            }  
        }  
  
        val printStack = ArrayDeque<Int>()  
        val builder = StringBuilder()  
        printStack.addLast(target)  
        builder.append("$target ")  
  
        while(printStack.isNotEmpty()) {  
            val prev = printStack.removeLast()  
  
            val parent = parents[prev]  
            if(parent > 0) {  
                printStack.addLast(parent)  
                builder.append("$parent ")  
            }  
        }  
  
        return builder.toString().trimEnd()  
    }  
}
```
## 3. ìš©ì–´ ì •ë¦¬

| **ìš©ì–´**                | **ì˜ë¯¸**                                                                      |
| --------------------- | --------------------------------------------------------------------------- |
| ë£¨íŠ¸ ë…¸ë“œ (Root)          | íŠ¸ë¦¬ì˜ ì‹œì‘ì                                                                      |
| ë¦¬í”„ ë…¸ë“œ (Leaf)          | ìì‹ì´ ì—†ëŠ” ë…¸ë“œ                                                                   |
| ë‚´ë¶€ ë…¸ë“œ (Internal Node) | ìì‹ì´ í•˜ë‚˜ ì´ìƒ ìˆëŠ” ë…¸ë“œ                                                             |
| ë¶€ëª¨/ ìì‹(Parent/ Child) | ì–´ë–¤ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ë‹¨ê³„ ì•„ë˜ì— ì—°ê²°ëœ ë…¸ë“œëŠ” ìì‹, ìœ„ì— ìˆëŠ” ë…¸ë“œëŠ” ë¶€ëª¨                               |
| í˜•ì œ (Sibling)          | ê°™ì€ ë¶€ëª¨ë¥¼ ê°€ì§„ ë…¸ë“œë“¤                                                               |
| ë ˆë²¨ (Level)            | ë£¨íŠ¸ë¥¼ 0ë²ˆ ë ˆë²¨ë¡œ í–ˆì„ ë•Œ, ì•„ë˜ë¡œ ë‚´ë ¤ê°ˆìˆ˜ë¡ +1ì”© ì¦ê°€   <br>    ì˜ˆ: ë£¨íŠ¸ â†’ 0, ê·¸ ìì‹ë“¤ â†’ 1, ê·¸ ì†ìë“¤ â†’ 2 |
| ê¹Šì´ (Depth)            | ì–´ë–¤ ë…¸ë“œì—ì„œ ë£¨íŠ¸ê¹Œì§€ ì˜¬ë¼ê°€ëŠ” ê°„ì„  ìˆ˜    <br>    ì˜ˆ: ë£¨íŠ¸ì˜ ê¹Šì´ = 0, ê·¸ ìì‹ì˜ ê¹Šì´ = 1               |
| ë†’ì´ (Height)           | ì–´ë–¤ ë…¸ë“œì—ì„œ ê°€ì¥ ë©€ë¦¬ ìˆëŠ” ë¦¬í”„ ë…¸ë“œê¹Œì§€ì˜ ê°„ì„  ìˆ˜<br>    íŠ¸ë¦¬ì˜ ë†’ì´ = ë£¨íŠ¸ ë…¸ë“œì˜ ë†’ì´                    |
| ì°¨ìˆ˜ (Degree)           | í•˜ë‚˜ì˜ ë…¸ë“œê°€ ê°€ì§€ëŠ” ìì‹ì˜ ìˆ˜                                                           |


## 4. íŠ¸ë¦¬ì˜ ì£¼ìš” ì„±ì§ˆë“¤
1. **íŠ¸ë¦¬ì— ì •ì ì´ Nê°œ ìˆë‹¤ë©´, ê°„ì„ ì€ í•­ìƒ N - 1ê°œì´ë‹¤.**
    - íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì´ ì—†ê³ , ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
2. **íŠ¸ë¦¬ëŠ” í•­ìƒ ì—°ê²° ê·¸ë˜í”„ì´ê³ , ì‚¬ì´í´ì´ ì—†ë‹¤.**
3. **ì´ì§„ íŠ¸ë¦¬ì—ì„œëŠ” ë…¸ë“œì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:**
    - ë ˆë²¨ì´ Lì¸ íŠ¸ë¦¬ì—ì„œ ìµœëŒ€ ë…¸ë“œ ìˆ˜ëŠ” 2<sup>L</sup>
    - ë†’ì´ê°€ hì¸ ì´ì§„ íŠ¸ë¦¬ì˜ ìµœëŒ€ ë…¸ë“œ ìˆ˜ëŠ” 2<sup>(h+1)</sup> - 1

## 5. íŠ¸ë¦¬ì˜ ì¢…ë¥˜
1. ì¼ë°˜ íŠ¸ë¦¬(GeneralTree)
	1. ê° ë…¸ë“œê°€ ìì‹ ë…¸ë“œë¥¼ ì—¬ëŸ¬ ê°œ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.
	2. ìì‹ ìˆ˜ì— ì œí•œì´ ì—†ë‹¤.
	3. ê³„ì¸µ êµ¬ì¡°, íŒŒì¼ ì‹œìŠ¤í…œ
2. ì´ì§„ íŠ¸ë¦¬(BinaryTree)
	1. ê° ë…¸ë“œê°€ ìµœëŒ€ 2ê°œì˜ ìì‹ ë…¸ë“œë§Œ ê°€ì§
	2. ë‹¤ì–‘í•œ êµ¬ì¡°ê°€ ì¡´ì¬

| **ì¢…ë¥˜**                                    | **ì„¤ëª…**                                    |
| ----------------------------------------- | ----------------------------------------- |
| **í¬í™” ì´ì§„ íŠ¸ë¦¬ (Full Binary Tree)**           | ëª¨ë“  ë…¸ë“œê°€ 0ê°œ ë˜ëŠ” 2ê°œì˜ ìì‹ì„ ê°€ì§ <br>ë¦¬í”„ ë…¸ë“œê°€ ë™ì¼í•œ ê¹Šì´ |
| **ì™„ì „ ì´ì§„ íŠ¸ë¦¬ (Complete Binary Tree)**       | ì™¼ìª½ë¶€í„° ì°¨ë¡€ë¡œ ë¹ˆí‹ˆì—†ì´ ì±„ì›Œì§„ íŠ¸ë¦¬                      |
| **ì • ì´ì§„ íŠ¸ë¦¬ (Proper / Strict Binary Tree)** | ìì‹ì´ 0ê°œ or 2ê°œë§Œ í—ˆìš© (1ê°œ ê¸ˆì§€)                  |
| **ê· í˜• ì´ì§„ íŠ¸ë¦¬ (Balanced Tree)**              | ì„œë¸ŒíŠ¸ë¦¬ ë†’ì´ ì°¨ì´ê°€ ì¼ì • ì´í•˜                         |
| **ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST)**                        | ì™¼ìª½ < ë£¨íŠ¸ < ì˜¤ë¥¸ìª½ ê·œì¹™ì„ ë§Œì¡±                      |
3. Nì§„ íŠ¸ë¦¬
	1. ëª¨ë“  ë…¸ë“œê°€ ìµœëŒ€ Nê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°€ì§ˆ ìˆ˜ ìˆëŠ” íŠ¸ë¦¬
	2. ì¼ë°˜ íŠ¸ë¦¬ì˜ íŠ¹ìˆ˜í•œ ê²½ìš°
4. íŠ¹ë³„í•œ ìš©ë„ì˜ íŠ¸ë¦¬

| **ì¢…ë¥˜**                     | **ì„¤ëª…**                    |
| -------------------------- | ------------------------- |
| **í™ (Heap)**               | ì™„ì „ ì´ì§„ íŠ¸ë¦¬ ê¸°ë°˜, ìš°ì„ ìˆœìœ„ í       |
| **íŠ¸ë¼ì´ (Trie)**             | ë¬¸ìì—´ ì €ì¥ìš© íŠ¸ë¦¬ êµ¬ì¡°             |
| **ì„¸ê·¸ë¨¼íŠ¸ íŠ¸ë¦¬ (Segment Tree)** | êµ¬ê°„ ì¿¼ë¦¬ ì²˜ë¦¬ìš© íŠ¸ë¦¬              |
| **íœìœ… íŠ¸ë¦¬ (Fenwick Tree)**   | Binary Indexed Tree (BIT) |
| **AVL íŠ¸ë¦¬ / Red-Black íŠ¸ë¦¬**  | ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬            |
| **B íŠ¸ë¦¬ / B+ íŠ¸ë¦¬**           | DB ì¸ë±ìŠ¤ ë“±ì—ì„œ ì‚¬ìš©, ë‹¤ì°¨ì› ë¶„ê¸° í—ˆìš©  |

## 6. íŠ¸ë¦¬ì˜ ìˆœíšŒ (Traversal)

> íŠ¸ë¦¬ì˜ ëª¨ë“  ë…¸ë“œë¥¼ í•œ ë²ˆì”© ë°©ë¬¸í•˜ëŠ” ë°©ë²•
1.  ì „ìœ„ ìˆœíšŒ (Pre-order)
	- ë°©ë¬¸ ìˆœì„œ: ë£¨íŠ¸ â†’ ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½
2.  ì¤‘ìœ„ ìˆœíšŒ (In-order)
	- ë°©ë¬¸ ìˆœì„œ: ì™¼ìª½ â†’ ë£¨íŠ¸ â†’ ì˜¤ë¥¸ìª½
	- ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ **ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬** íš¨ê³¼
3.  í›„ìœ„ ìˆœíšŒ (Post-order)
	- ë°©ë¬¸ ìˆœì„œ: ì™¼ìª½ â†’ ì˜¤ë¥¸ìª½ â†’ ë£¨íŠ¸

```text
        A
       / \
      B   C
     / \   \
    D   E   F

- ì „ìœ„ ìˆœíšŒ: A B D E C F
- ì¤‘ìœ„ ìˆœíšŒ: D B E A C F
- í›„ìœ„ ìˆœíšŒ: D E B F C A
```

1) íŠ¸ë¦¬ ìˆœíšŒ ì˜ˆì‹œ
```kotlin
class Traversal {  
    /**  
     * âœ… ì‹¤ìŠµ ë¬¸ì œ  
     *  
     * ğŸŸ© ë¬¸ì œ: íŠ¸ë¦¬ ìˆœíšŒ ê²°ê³¼ ì¶œë ¥  
     *  
     * ë£¨íŠ¸ ë…¸ë“œê°€ ì£¼ì–´ì§„ íŠ¸ë¦¬ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ ì „ìœ„, ì¤‘ìœ„, í›„ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ë¼.  
     *   
     * â–ªï¸ ì…ë ¥  
     *  â€¢  ì²« ì¤„: ë…¸ë“œ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 26)    
     *  â€¢  ì´í›„ Nì¤„: ê° ì¤„ì— ì„¸ ê°œì˜ ê°’ ë¶€ëª¨ ìì‹1 ìì‹2  
     *  â€¢  ìì‹ì´ ì—†ìœ¼ë©´ .ìœ¼ë¡œ í‘œê¸°  
     *  
     * â–ªï¸ ì¶œë ¥  
     *  â€¢  ì „ìœ„ ìˆœíšŒ ê²°ê³¼  
     *  â€¢  ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼  
     *  â€¢  í›„ìœ„ ìˆœíšŒ ê²°ê³¼  
     *  
     * â¸»  
     *  
     * â–ªï¸ ì˜ˆì‹œ ì…ë ¥  
     * 7  
     * A B C   
     * B D E    
     * C F .   
     * E . .   
     * D . .   
     * F . .   
     * ```text  
     *      A    
     *     / \   
     *    B   C   
     *  /  \   \   
     * D    E   F   
     * ```    
     * â–ªï¸ ì˜ˆì‹œ ì¶œë ¥  
     * ì „ìœ„ ìˆœíšŒ: ABDECF  
     * ì¤‘ìœ„ ìˆœíšŒ: DBEACF  
     * í›„ìœ„ ìˆœíšŒ: DEBFCA  
     */  
 
    data class Node(  
        val character: String,  
        val left: Node?,  
        val right: Node?  
    )  
  
    @Test  
    fun solution() {  
  
  
        val E = Node("E", null, null)  
        val D = Node("D", null, null)  
        val F = Node("F", null, null)  
        val C = Node("C", null, F)  
        val B = Node("B", D, E)  
        val A = Node("A", B, C)  
  
        val preOrderExpected = "ABDECF";  
        val inOrderExpected = "DBEACF";  
        val postOrderExpected = "DEBFCA";  
  
        assertEquals(preOrderExpected, preOrderUseStack(A))  
        assertEquals(inOrderExpected, inOrderUseStack(A))  
        assertEquals(postOrderExpected, postOrderUseStack(A))  
  
        assertEquals(preOrderExpected, preOrderUseRecursive(A))  
        assertEquals(inOrderExpected, inorderUseRecursive(A))  
        assertEquals(postOrderExpected, postOrderUseRecursive(A))  
    }  
  
  
    private fun preOrderUseStack(tree: Node): String {  
        val stack = ArrayDeque<Pair<Node, StringBuilder>>()  
        val builder = StringBuilder()  
        stack.addLast(tree to builder)  
  
        while (stack.isNotEmpty()) {  
            val (node, builder) = stack.removeLast()  
            builder.append(node.character)  
  
            if (node?.right != null) {  
                stack.addLast(node.right to builder)  
            }  
            if (node?.left != null) {  
                stack.addLast(node.left to builder)  
            }  
        }  
  
        return builder.toString()  
    }  
  
    private fun inOrderUseStack(tree: Node): String {  
        val stack = ArrayDeque<Node>()  
        val builder = StringBuilder()  
        var current: Node? = tree  
  
  
        while (current != null || stack.isNotEmpty()) {  
            while (current != null) {  
                stack.addLast(current)  
                current = current.left  
            }  
  
            val node = stack.removeLast()  
            builder.append(node.character)  
  
            current = node.right  
        }  
  
        return builder.toString()  
    }  
  
    private fun postOrderUseStack(tree: Node): String {  
  
        val stack = ArrayDeque<Node>()  
        val wordStack = ArrayDeque<String>()  
        stack.addLast(tree)  
  
        while (stack.isNotEmpty()) {  
            val node = stack.removeLast()  
            wordStack.addLast(node.character)  
  
  
            if (node?.left != null) {  
                stack.addLast(node.left)  
            }  
            if (node?.right != null) {  
                stack.addLast(node.right)  
            }  
        }  
  
        val builder = StringBuilder()  
        while (wordStack.isNotEmpty()) {  
            builder.append(wordStack.removeLast())  
        }  
  
        return builder.toString()  
    }  
  
    private fun preOrderUseRecursive(tree: Node): String {  
        val builder = StringBuilder()  
        preOrderTraversal(tree, builder)  
        return builder.toString()  
    }  
  
    private fun preOrderTraversal(tree: Node, builder: StringBuilder) {  
        builder.append(tree.character)  
        if (tree?.left != null) preOrderTraversal(tree.left, builder)  
        if (tree?.right != null) preOrderTraversal(tree.right, builder)  
    }  
  
    private fun inorderUseRecursive(tree:Node): String {  
        val builder = StringBuilder()  
        inorderTraversal(tree, builder)  
        return builder.toString()  
    }  
  
    private fun inorderTraversal(tree: Node, builder: StringBuilder) {  
        if(tree?.left != null) inorderTraversal(tree.left, builder)  
        builder.append(tree.character)  
        if(tree?.right != null) inorderTraversal(tree.right, builder)  
    }  
    private fun postOrderUseRecursive(tree:Node): String {  
        val builder = StringBuilder()  
        postOrderTraversal(tree, builder)  
        return builder.toString()  
    }  
  
    private fun postOrderTraversal(tree: Node, builder: StringBuilder) {  
        if (tree?.left != null) postOrderTraversal(tree.left, builder)  
        if (tree?.right != null) postOrderTraversal(tree.right, builder)  
        builder.append(tree.character)  
    }  
}
```