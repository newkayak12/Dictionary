# 이진 트리와 배열 인덱싱: 0-based vs 1-based

## 핵심 개념

배열이 0부터 시작하는 것은 단순한 관습이 아니라, **포인터 연산과 이진 트리 자료구조의 효율성**에서 비롯된 설계 결정이다.

---

## 1. 배열 = 포인터 + 오프셋 (C언어 관점)

### 메모리 구조

```c
int arr[5] = {10, 20, 30, 40, 50};

메모리 레이아웃:
주소:  1000   1004   1008   1012   1016
값:     10     20     30     40     50
       ↑
      arr (배열의 시작 주소)
```

### 배열 접근의 본질

```c
arr[i] = *(arr + i)

예시:
arr[0] = *(arr + 0) = *1000 = 10
arr[3] = *(arr + 3) = *1012 = 40

실제 주소 = 시작주소 + (인덱스 × 원소크기)
         = arr + (i × sizeof(int))
```

### 0-based의 장점

```c
// 0-based: 오프셋 = 인덱스 그대로
arr[0] = *(arr + 0)  // +0
arr[1] = *(arr + 1)  // +1
arr[2] = *(arr + 2)  // +2

// 추가 연산 없음!
```

### 1-based였다면?

```c
// 논리적으로 1~5 인덱스 사용
arr[1] = 첫 번째 원소 (실제 주소: arr + 0)
arr[2] = 두 번째 원소 (실제 주소: arr + 1)

// 구현:
arr[i] = *(arr + (i - 1))

// 모든 접근마다 -1 연산 필요!
// CPU 사이클 낭비
```

---

## 2. 이진 트리 자료구조와의 관계

### 힙을 배열로 표현

```
완전 이진 트리:
         0
        / \
       1   2
      / \ / \
     3  4 5  6
```

### 0-based 인덱싱 공식

```kotlin
val heap = arrayOf(10, 5, 8, 3, 2, 7, 6)
//          인덱스: 0   1  2  3  4  5  6

부모-자식 관계:
parent(i) = (i - 1) / 2
leftChild(i) = 2 * i + 1
rightChild(i) = 2 * i + 2

예시:
노드 1 (값 5):
  부모 = (1-1)/2 = 0 (값 10) ✓
  왼쪽 자식 = 2*1+1 = 3 (값 3) ✓
  오른쪽 자식 = 2*1+2 = 4 (값 2) ✓
```

### 1-based 인덱싱 공식

```kotlin
// 인덱스 0 낭비
val heap = arrayOf(?, 10, 5, 8, 3, 2, 7, 6)
//          인덱스: 0  1   2  3  4  5  6  7

부모-자식 관계:
parent(i) = i / 2
leftChild(i) = 2 * i
rightChild(i) = 2 * i + 1

예시:
노드 1 (값 10):
  왼쪽 자식 = 2*1 = 2 (값 5) ✓
  오른쪽 자식 = 2*1+1 = 3 (값 8) ✓

노드 2 (값 5):
  부모 = 2/2 = 1 (값 10) ✓
  왼쪽 자식 = 2*2 = 4 (값 3) ✓
```

**1-based의 장점:**

- 공식이 더 직관적 (나누기 2, 곱하기 2)
- 알고리즘 교과서에서 선호하는 이유

**1-based의 단점:**

- 배열 인덱스 0 낭비 (메모리 손실)
- 실제 구현에서는 0-based 배열을 쓰므로 혼란

---

## 3. 토너먼트 문제와의 연결

### 문제: 1-based 참가자 번호

```
토너먼트 참가자: 1, 2, 3, 4, 5, 6, 7, 8

매칭:
1↔2, 3↔4, 5↔6, 7↔8
```

### 이진수 표현의 문제

```
1-based:
1 = 001₂
2 = 010₂  ← 형제인데 전혀 다른 패턴!

XOR:
  001
⊕ 010
-----
  011 = 3 (길이 2)

실제 답: 1라운드
XOR 길이: 2
→ 불일치!
```

### 해결: 0-based 변환

```kotlin
(a - 1) xor (b - 1)

1 → 0: 0 = 000₂
2 → 1: 1 = 001₂  ← 마지막 비트만 다름!

XOR:
  000
⊕ 001
-----
  001 = 1 (길이 1)

답: 1라운드 ✓
```

### 0-based에서 형제 패턴

```
0 = 000₂ ↔ 1 = 001₂  (차이: 1비트)
2 = 010₂ ↔ 3 = 011₂  (차이: 1비트)
4 = 100₂ ↔ 5 = 101₂  (차이: 1비트)

형제 = 마지막 비트만 다름
XOR 길이 = 1 = 1라운드에서 만남
```

---

## 4. 실전 적용

### 토너먼트 문제 풀이

```kotlin
// 방법 1: 시뮬레이션 (1-based 그대로)
fun solution(n: Int, a: Int, b: Int): Int {
    var x = a
    var y = b
    var round = 1
    
    while ((x + 1) / 2 != (y + 1) / 2) {
        round++
        x = (x + 1) / 2
        y = (y + 1) / 2
    }
    
    return round
}

// 방법 2: 비트 연산 (0-based 변환)
fun solution(n: Int, a: Int, b: Int): Int {
    return ((a - 1) xor (b - 1)).toString(2).length
}
```

### 힙 구현 선택

```kotlin
// 방법 1: 0-based (메모리 효율)
class MinHeap {
    private val heap = mutableListOf<Int>()
    
    private fun parent(i: Int) = (i - 1) / 2
    private fun left(i: Int) = 2 * i + 1
    private fun right(i: Int) = 2 * i + 2
}

// 방법 2: 1-based (공식 단순)
class MinHeap {
    private val heap = mutableListOf(0)  // 더미
    
    private fun parent(i: Int) = i / 2
    private fun left(i: Int) = 2 * i
    private fun right(i: Int) = 2 * i + 1
}
```

---

## 5. 핵심 정리

### 배열이 0부터 시작하는 이유

1. **포인터 연산 효율성**
    
    - `arr[i] = *(arr + i)`
    - 추가 연산 없이 오프셋 계산
2. **이진 트리 공식과의 조화**
    
    - 0-based: `parent = (i-1)/2`
    - 복잡하지만 메모리 낭비 없음
3. **하드웨어 친화적**
    
    - CPU 캐시, 메모리 정렬과 자연스럽게 매칭

### 언제 1-based를 쓰나?

- **알고리즘 교육**: 공식이 직관적 (힙 설명할 때)
- **수학적 문제**: 자연수 개념과 일치
- **레거시 시스템**: Fortran, MATLAB 등

### 언제 0-based를 쓰나?

- **실제 구현**: C, Java, Kotlin 등 대부분 언어
- **메모리 효율**: 낭비 없음
- **표준 라이브러리**: 기존 생태계와 호환

---

## 6. 주의사항

### 인덱싱 혼동 방지

```kotlin
// 문제가 1-based 인덱스를 주면
val input = 4  // 4번 참가자

// 0-based 계산 시 변환
val zeroBasedIndex = input - 1  // 3

// 비트 연산
val result = ((a - 1) xor (b - 1)).toString(2).length

// 결과는 그대로 (라운드는 1부터 시작)
return result
```

### 힙 구현 시

```kotlin
// 0-based 선택 시 공식 주의
parent(i) = (i - 1) / 2     // (0-1)/2 = 0 (자기자신)
left(i) = 2 * i + 1
right(i) = 2 * i + 2

// 1-based 선택 시 인덱스 0 처리
heap.add(0, -1)  // 더미 값
// 이후 1번 인덱스부터 사용
```

---

## 결론

**배열의 0-based 인덱싱은:**

- 포인터 연산의 자연스러운 결과
- 하드웨어 효율성을 위한 선택
- 이진 트리 자료구조와 긴밀한 관계

**실무에서는 0-based, 교육에서는 1-based를 병용하므로 둘 다 이해 필수!**