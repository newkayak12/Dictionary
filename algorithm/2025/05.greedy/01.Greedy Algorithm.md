## ê¸°ë³¸ ê°œë…
1. ë§¤ ìˆœê°„ë§ˆë‹¤ ê°€ì¥ ìµœì ì´ë¼ê³  ìƒê°í•˜ëŠ” ì„ íƒì„ í•˜ëŠ” ë°©ì‹(ë‹¹ì‹œ ìƒí™©ì—ì„œ ìµœì )
2. ê³¼ì—° ê° ìƒí™©ì—ì„œì˜ ìµœì í•´ì˜ í•©ì´ "**ì „ì²´ ìµœì í•´**"ê°€ ë˜ëŠ”ê°€ëŠ” ì¦ëª…ì´ í•„ìš”í•˜ë‹¤.

## í•µì‹¬ íŠ¹ì§•
1. íƒìš• ì„ íƒ ì¡°ê±´ (Greedy Choice Property)
   -> ê° ë‹¨ê³„ì˜ ìµœì„ ì˜ ì„ íƒì´ ì „ì²´ì ìœ¼ë¡œ ìµœì ì´ ëœë‹¤.
2. ë¬¸ì œ ë¶„í•  ë¶ˆê°€ëŠ¥(DPì™€ì˜ ì°¨ì´ì )
   -> ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œëŠ” ì—†ê³ , í•œ ë²ˆ ê²°ì •ë˜ë©´ ë˜ëŒë¦´ ìˆ˜ ì—†ë‹¤.
## ê·¸ë¦¬ë””ì¸ì§€ íŒŒì•…
#### **ğŸ”·**Â **ë¬¸ì œë¥¼ ë³´ê³  â€œê·¸ë¦¬ë”” ë¬¸ì œâ€ì„ì„ ì–´ë–»ê²Œ ì•Œ ìˆ˜ ìˆëŠ”ê°€?**
1.  ì „í˜•ì  íŒ¨í„´:
	- **ì •ë ¬ í›„, ë‹¨ìˆœ ê·œì¹™ìœ¼ë¡œ ë°˜ë³µ ì²˜ë¦¬**
	- í•œ ë²ˆì˜ â€œì„ íƒâ€ì´ ì´í›„ ì„ íƒì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ” ê²½ìš° (êµ­ì†Œì ìœ¼ë¡œ ìµœì  ì„ íƒì´ ì „ì²´ ìµœì )
	ì˜ˆ)
	- ë™ì „ ê±°ìŠ¤ë¦„ëˆ ë¬¸ì œ
	- í™œë™ ì„ íƒ ë¬¸ì œ
	- ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (í¬ë£¨ìŠ¤ì¹¼)
2.  í‚¤ì›Œë“œ:
	- â€œìµœì†Œ ê°œìˆ˜/ìµœì†Œ íšŸìˆ˜â€ë¥¼ êµ¬í•˜ë¼ëŠ” ë¬¸ì œ
	- â€œìµœì†Œ ë¹„ìš©/ìµœëŒ€ ì´ìµâ€ì„ êµ¬í•˜ë¼ëŠ” ë¬¸ì œ
	- â€œìˆœì„œ/ìœ„ì¹˜â€ë¥¼ ì˜ ì •ë¦¬í•´ì„œ ê²°ì •í•´ì•¼ í•˜ëŠ” ë¬¸ì œ
3. ë°˜ë¡€ ì²´í¬:
	- â€œëª¨ë“  ê²½ìš°ë¥¼ ê³ ë ¤í•  í•„ìš” ì—†ëŠ” ë¬¸ì œâ€
	- â€œê° ë‹¨ê³„ì—ì„œ ìµœì ì´ë¼ê³  ë³´ì´ëŠ” ê²ƒë§Œ ê³ ë¥´ë©´ ì „ì²´ë„ ìµœì â€ì´ë¼ëŠ” ì•”ì‹œê°€ ìˆìœ¼ë©´ ê·¸ë¦¬ë””
> ì •ë ¬ -> ê·œì¹™ -> ë°˜ë³µ
> 1. ì •ë ¬ ê¸°ì¤€ ì°¾ê¸°
> 2. ì„ íƒ ê·œì¹™ ì •ì˜
> 3. ë°˜ë³µ êµ¬ì¡° í™•ì¸
> 4. ë°˜ë¡€ë¥¼ ë¬¸ì œ êµ¬ì¡°ë¡œ í™•ì¸

### íŒ¨í„´
1. í˜„ì¬ ì„ íƒì´ ìµœì ì´ë‹¤.
	1. ê° ë‹¨ê³„ì—ì„œ í•  ìˆ˜ ìˆëŠ” ìµœì ì„ ì°¾ëŠ”ë‹¤.
	2. ì´ë¥¼ ì´ì–´ ë¶™ì´ë©´ ì „ì²´ ìµœì í•´ê°€ ëœë‹¤.
2. íŒ¨í„´
	1. ì •ë ¬ + ì„ íƒ
		1. íšŒì˜ì‹¤ ë°°ì •
		2. ë³´ìƒ ì¹´ë“œ
		3. ì²´ìœ¡ë³µ
		4. (ë³´ìƒ, ë¹„ìš©) ì¼€ì´ìŠ¤
	2. ìš°ì„  ìˆœìœ„ í
		1. ë³´ìƒ ì¹´ë“œ
		2. í—ˆí”„ë§Œ
		3. ìµœì†Œë¹„ìš© ì—°ê²°
		4. í›„ë³´ë¥¼ í•œêº¼ë²ˆì— ë‘ê³  ì¢‹ì€ ê²ƒì„ ê³¨ë¼ì„œ ì“°ëŠ” ê²½ìš°
		5. ê° ì„ íƒì´ í•œ ë²ˆë§Œ ì“°ì´ê³ , ê·¸ ì„ íƒìœ¼ë¡œ ì „ì²´ ê²°ê³¼ê°€ ë³´ì¥
	3. ë‹¨ì¼ ê²½ë¡œ íƒìƒ‰
		1. ì”ëˆ ê±°ìŠ¤ë¦„
		2. ë°°ë‚­
		3. ê° ì„ íƒì´ ë‹¤ë¥¸ ì„ íƒì— ì˜í–¥ì„ ì£¼ì§€ ì•Šê³ , ë…ë¦½ì ìœ¼ë¡œ ìµœì  ì„ íƒì´ ë˜ëŠ” ê²½ìš°
	4. ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •
		1. í™œë™ ì„œíƒ
		2. ìµœì†Œ íšŒì˜ì‹¤
		3. ì¼ì° ëë‚˜ëŠ” ìˆœì„œëŒ€ë¡œ í˜¹ì€ ì‹œì‘ ì¡°ê±´ìœ¼ë¡œ ì •ë ¬

### 1. ì •ë ¬ + ì„ íƒ
- ì „ì²´ ë°ì´í„° ì •ë ¬ í›„ ìˆœì°¨ ì„ íƒ
- ê¸°ì¤€
	- ì •ë ¬ ê¸°ì¤€ì´ ëª…í™•í•œê°€?
	- ì „ì²´ë¥¼ ë¯¸ë¦¬ ë³¼ ìˆ˜ ìˆëŠ”ê°€?

### 2. ìš°ì„  ìˆœìœ„ í
- í›„ë³´êµ°ì—ì„œ ë™ì ìœ¼ë¡œ ìµœì  ì„ íƒ
- ê¸°ì¤€
	- ì„ íƒ í›„ ìƒˆ í›„ë³´ê°€ ì¶”ê°€ë˜ëŠ”ê°€?
	- ë§¤ë²ˆ ìµœì„ ì„ ê³¨ë¼ì•¼ í•˜ëŠ”ê°€?

### 3. ë‹¨ì¼ ê²½ë¡œ íƒìƒ‰
- ê° ë‹¨ê³„ì˜ ì„ íƒì´ ë™ë¦½ì 
- ê¸°ì¤€
	- ì´ì „ íŒë³„ì´ ë‹¤ìŒì— ì˜í–¥ì„ ì£¼ëŠ”ê°€?
	- í•œ ë°©í–¥ìœ¼ë¡œë§Œ ê°€ëŠ”ê°€?

### 4. ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •
- ì¢…ë£Œ/ ì‹œì‘ ì‹œì  ê¸°ì¤€ ì •ë ¬
- ê¸°ì¤€
	- ì‹œê°„ êµ¬ê°„ ë¬¸ì œì¸ê°€?
	- ê²¹ì¹¨ íŒë‹¨ì´ í•„ìš”í•œê°€?

## ì˜ˆì‹œ ë¬¸ì œ
1) íšŒì˜ì‹¤ ë°°ì • ë¬¸ì œ - ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •
```kotlin
class MeetingRoom {  
    /**  
     * ğŸŸ© íšŒì˜ì‹¤ ë°°ì • ë¬¸ì œ  
     *  
     * âœ… ë¬¸ì œ ì„¤ëª…  
     * í•œ ê°œì˜ íšŒì˜ì‹¤ì´ ìˆìŠµë‹ˆë‹¤.  
     * Nê°œì˜ íšŒì˜ê°€ ìˆê³ , ê° íšŒì˜ë§ˆë‹¤ ì‹œì‘ ì‹œê°„ê³¼ ëë‚˜ëŠ” ì‹œê°„ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ê° íšŒì˜ëŠ” í•œ ë²ˆì— í•œ ê°œì”©ë§Œ ì§„í–‰í•  ìˆ˜ ìˆìœ¼ë©°,  
     * íšŒì˜ê°€ ëë‚˜ëŠ” ì‹œê°„ê³¼ ë‹¤ìŒ íšŒì˜ì˜ ì‹œì‘ ì‹œê°„ì€ ê°™ì•„ë„ ë©ë‹ˆë‹¤.  
     *    
     * ğŸ‘‰ íšŒì˜ì‹¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” íšŒì˜ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     *    
     * â¸»  
     *  
     * âœ… ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: íšŒì˜ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 100,000)  
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì—: íšŒì˜ì˜ ì‹œì‘ ì‹œê°„ê³¼ ëë‚˜ëŠ” ì‹œê°„ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ì‹œì‘ ì‹œê°„ê³¼ ëë‚˜ëŠ” ì‹œê°„ì€ 0 ì´ìƒ 2^31-1 ì´í•˜ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤.  
     *
	 * âœ… ì¶œë ¥  
     *  â€¢  íšŒì˜ì‹¤ì—ì„œ ì§„í–‰í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ íšŒì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     * 
     * âœ… ì˜ˆì œ ì…ë ¥  
     * íšŒì˜ ê°œìˆ˜: 5  
     * | ì‹œì‘ | ë |  
     * |  1  | 4 |    
     * |  2  | 3 |
     * |  3  | 5 |
     * |  0  | 6 |
     * |  5  | 7 | 
     *    
     * âœ… ì˜ˆì œ ì¶œë ¥  
     * 3  
     */


//ì¼ë‹¨ ë¬¸ì œë§Œìœ¼ë¡œ êµ¬ì²´í™”í•´ì„œ í’€ì–´ë³´ë©´?
	@Test  
    fun solution(){  
        val timetable: Array<IntArray> = arrayOf(  
                intArrayOf(1, 4),  
                intArrayOf(2, 3),  
                intArrayOf(3, 5),  
                intArrayOf(0, 6),  
                intArrayOf(5, 7)  
            )  
        val excepted = 3  
  
        /**  
         * 2-3 -> 3-5 -> 5-7ë¡œ ì´ 3ê°œë¡œ ì˜ˆìƒ  
         *  
         * 1. ì´ì „ ì‹œê°„ê³¼ ê²¹ì¹˜ëŠ”ì§€ í™•ì¸  
         *  1. ê²¹ì¹˜ë©´ ì‹œê°„ ì²´í¬  
         *      1. running íƒ€ì„ ë¹„êµ  
         *  2. ì•ˆê²¹ì¹˜ë©´ ì¶”ê°€  
         */  
  
        assertEquals(excepted, useGreedy(timetable))  
        assertEquals(excepted, optimizeUseGreedy(timetable))
    }  
  
    private fun useGreedy(timetable: Array<IntArray>): Int {  
        val deque = ArrayDeque<IntArray>();  
        deque.add(timetable[0])  
  
        for( i in 1 ..< timetable.size) {  
            val before = deque.last()  
  
            if( before[1] <= timetable[i][0]) {  
                deque.add(timetable[i])  
            }  
            else {  
                val beforeRunningTime = before[1] - before[0]  
                val nowRunningTime = timetable[i][1] - timetable[i][0]  
  
                if(  
                    nowRunningTime < beforeRunningTime ||  
                    nowRunningTime == beforeRunningTime && before[1] > timetable[i][1]  
                ){  
                    deque.removeLast()  
                    deque.add(timetable[i])  
                }  
            }  
        }  
  
  
        return deque.size  
    }
    
    
    //ì¡°ê¸ˆ ë” ì‰½ê²Œ ìƒê°í•˜ë©´ ëë‚˜ëŠ” ì‹œê°„ë§Œ ìƒê°í•˜ë©´ ëœë‹¤.  
  
	private fun optimizeUseGreedy(timetable: Array<IntArray>): Int {  
	    timetable.sortBy { it[1] }  
	    var count = 1  
	    var lastEndTime = timetable[0][1]  
	  
	    for( i in 1 until  timetable.size) {  
	        if(timetable[i][0] >= lastEndTime) {  
	            count ++  
	            lastEndTime = timetable[i][1]  
	        }  
	    }  
	  
	   return count  
	}
}
```

2) ë™ì „ ê°œìˆ˜ ë¬¸ì œ - ë‹¨ì¼ ê²½ë¡œ íƒìƒ‰
```kotlin
class MinimumCoins {  
    /**  
     * ğŸŸ© ë¬¸ì œ ì´ë¦„: ìµœì†Œ ë™ì „ ê°œìˆ˜ ê³„ì‚°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ì£¼ì–´ì§„ ë™ì „ìœ¼ë¡œ ëª©í‘œ ê¸ˆì•¡ì„ ë§ì¶”ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ë™ì „ ë‹¨ìœ„ëŠ” ì„œë¡œ ë°°ìˆ˜ ê´€ê³„ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìœ¼ë©°, ê°€ëŠ¥í•œ ê²½ìš° ê°€ì¥ ì ì€ ë™ì „ ê°œìˆ˜ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.  
     *     
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: ë™ì „ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 10)    
     *  â€¢  ë‘˜ì§¸ ì¤„: ë™ì „ ë‹¨ìœ„ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ëœ Nê°œì˜ ìì—°ìˆ˜)  
     *  â€¢  ì…‹ì§¸ ì¤„: ëª©í‘œ ê¸ˆì•¡ M (1 â‰¤ M â‰¤ 10,000)  
     *   
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ëª©í‘œ ê¸ˆì•¡ Mì„ ë§Œë“¤ê¸° ìœ„í•œ ìµœì†Œ ë™ì „ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     *     
     * ğŸ§ª ì˜ˆì œ ì…ë ¥ 1   
     * ë™ì „ ê°œìˆ˜ : 4    
     * ë™ì „ ë‹¨ìœ„ : 500 100 50 10    
     * ëª©í‘œ ê¸ˆì•¡ : 1260    
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥ 1    
     * 6     
     *     
     * ğŸ§ª ì˜ˆì œ ì…ë ¥ 2   
     * ë™ì „ ê°œìˆ˜ : 3   
     * ë™ì „ ë‹¨ìœ„ : 9 6 1    
     * ëª©í‘œ ê¸ˆì•¡ : 15   
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥ 2   
     * 2    
     */
       
    @Test  
    fun solution1() {  
        val coinCount = 4  
        val coinTypes = intArrayOf(500, 100, 50, 10)  
        val target = 1260  
        val expected = 6  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    @Test  
    fun solution2() {  
        val coinCount = 3  
        val coinTypes = intArrayOf(9,6,1)  
        val target = 15  
        val expected = 2  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    private fun greedy(coinTypes: IntArray, target: Int): Int {  
        var usedCount = 0  
        var targetAmount = target  
        coinTypes.sortDescending()  
  
  
        for( coin in coinTypes ) {  
            if( targetAmount <= 0) break  
            if( targetAmount / coin > 0) {  
                val div = targetAmount/coin  
                usedCount += div  
                targetAmount -= coin * div  
            }  
        }  
  
        return usedCount  
    }  
  
}
```

3) ë³´ìƒ ì¹´ë“œ ì‚¬ìš© ì „ëµ ë¬¸ì œ - ìš°ì„  ìˆœìœ„ í
```kotlin
package renewal.greedy  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.PriorityQueue  
  
class StrategyOfSelectionAboutRewardCard {  
    /**  
     * ğŸŸ© ë¬¸ì œ ì´ë¦„: ë³´ìƒ ì¹´ë“œ ì‚¬ìš© ì „ëµ  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ë‹¹ì‹ ì—ê²ŒëŠ” ë‹¤ì–‘í•œ ë³´ìƒ ì¹´ë“œë¥¼ ì‚¬ìš©í•  ê¸°íšŒê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ê° ë³´ìƒ ì¹´ë“œëŠ” ì‚¬ìš© ê¸°í•œ(ë‚ ì§œ)ê³¼ ë³´ìƒ ê¸ˆì•¡ì´ ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤.  
     * í•˜ë£¨ì— í•œ ë²ˆì”©, ê¸°í•œì´ ë˜ê¸° ì „(í¬í•¨)ê¹Œì§€ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì¹´ë“œ ì¤‘ ë³´ìƒì´ ê°€ì¥ í° ì¹´ë“œë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     *   
     * ì£¼ì–´ì§„ ì¹´ë“œ ì •ë³´ë¡œ, ë³´ìƒ ê¸ˆì•¡ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì˜ ì´ ë³´ìƒ ê¸ˆì•¡ì„ êµ¬í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: ì¹´ë“œì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 1,000)     
     *  â€¢  ë‘˜ì§¸ ì¤„ ~ N+1ë²ˆì§¸ ì¤„: ê° ì¹´ë“œì˜ ì‚¬ìš© ê¸°í•œ d(1 â‰¤ d â‰¤ 1,000)ì™€ ë³´ìƒ ê¸ˆì•¡ p(1 â‰¤ p â‰¤ 100,000) 
     *
	 * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ë³´ìƒ ê¸ˆì•¡ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ëŠ” ê°’ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     * 
     *
	 * 
	 * ğŸ§ª ì˜ˆì œ ì…ë ¥ 1   
	 *  3  
	 * 1 10 
	 * 2 20 
	 * 3 30     * -> 1ì¼ì°¨(10) + 2ì¼ì°¨(20) +3ì¼ì°¨(30)  
     *    
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥ 1  
     * 60   
     *    
     * ğŸ§ª ì˜ˆì œ ì…ë ¥ 2   
     * 5    
     * 3 50    
     * 3 10    
     * 1 20     
     * 2 40   
     * 2 30    
     *   
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥ 2     
     * 120   
     *     
     * -> 1ì¼ì°¨ (3 50), (3 10), (1 20), (2 40), âœ… (2 30)    
     * -> 2ì¼ì°¨ (3 50), (3 10), âœ… (2 40)    
     * -> 3ì¼ì°¨ âœ… (3 50), (3 10)
     */  
  
    @Test  
    fun solution1() {  
        val table = arrayOf(  
            intArrayOf(1, 10),  
            intArrayOf(2, 20),  
            intArrayOf(3, 30),  
        )  
  
        val expected = 60  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution2() {  
        val table = arrayOf(  
            intArrayOf(3, 50),  
            intArrayOf(3, 10),  
            intArrayOf(1, 20),  
            intArrayOf(2, 40),  
            intArrayOf(2, 30),  
        )  
  
        val expected = 110  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution3() {  
        val table = arrayOf(  
            intArrayOf(1, 10),  
            intArrayOf(2, 20),  
            intArrayOf(3, 100),  
            intArrayOf(1, 100),  
            intArrayOf(2, 1),  
        )  
  
        val expected = 220  
  
        assertEquals(expected, greedy(table))  
    }  
  
  
    private fun greedy(table: Array<IntArray>): Int {  
        val sortedTable = table.sortedBy { it[0] }  
        val dueDate = sortedTable.maxOf { it[0] }  
        val queue = PriorityQueue<Int> (compareByDescending { it })  
  
        var result = 0  
        var index = 0  
  
        for (day in 1 .. dueDate) {  
           while(index < sortedTable.size && sortedTable[index][0] <= day){  
               queue.add(sortedTable[index][1])  
               index++  
           }  
  
  
            if(queue.isNotEmpty()) {  
                result += queue.poll()  
            }  
        }  
  
  
        return result  
    }  
}
```
4) íƒë°° ë°°ì†¡ ë¬¸ì œ - ìš°ì„  ìˆœìœ„ í
```kotlin
package renewal.greedy  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.PriorityQueue  
  
class Delivery {  
    /**  
     * ğŸŸ© ë¬¸ì œ ì´ë¦„: ğŸ“¦ íƒë°° ë°°ì†¡  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * í•œ ë§ˆì„ì— Nê°œì˜ íƒë°° ì£¼ë¬¸ì´ ìˆìŠµë‹ˆë‹¤.  
     * ê° ì£¼ë¬¸ì€ ë°°ì†¡ ì‹œì‘ ê°€ëŠ¥ì¼(start), ë°°ì†¡ ë§ˆê°ì¼(end), ê·¸ë¦¬ê³  **ë°°ì†¡ë¹„(payment)**ê°€ ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤.  
     * í•˜ë£¨ì— í•˜ë‚˜ì˜ ì£¼ë¬¸ë§Œ ì²˜ë¦¬í•  ìˆ˜ ìˆê³ ,  
     * ë°°ì†¡ë¹„ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ ë°°ì†¡ ì¼ì •ì„ ì •í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: ì£¼ë¬¸ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 10,000) 
     *  â€¢  ì´í›„ Nì¤„: ê° ì£¼ë¬¸ì˜ ë°°ì†¡ ì‹œì‘ì¼ start, ë°°ì†¡ ë§ˆê°ì¼ end, ë°°ì†¡ë¹„ payment (1 â‰¤ start â‰¤ end â‰¤ 1,000 / 1 â‰¤ payment â‰¤ 100,000)    
     *     
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ê°€ëŠ¥í•œ ìµœëŒ€ ë°°ì†¡ë¹„ì˜ í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *   
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     *  4  
     * 1 2 50   
     * 1 3 10   
     * 2 2 20   
     * 3 3 30    
     *    
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥  
     * 100  
     * 
     * 1ì¼ -> âœ…(1, 2, 50), (1, 3, 10)  
     * 2ì¼ -> âœ…(2, 2, 20)  
     * 3ì¼ -> (1, 3, 10), âœ…(3, 3, 30)  
     */  
    @Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 3, 10),  
            intArrayOf(2, 2, 20),  
            intArrayOf(3, 3, 30),  
        )  
  
        val expected = 100  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution2() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 2, 40),  
            intArrayOf(1, 2, 30),  
        )  
  
        val expected = 90  
  
        assertEquals(expected, greedy(table))  
    }  
  
    private fun greedy(table: Array<IntArray>): Int {  
        val sortedTable = table.sortedWith(compareBy({ it[0] }, { it[1] }))  
        val pq = PriorityQueue<IntArray>(compareByDescending { it[2] })  
        val maxDay = table.maxOf { it[1] }  
  
        var index = 0  
        var result = 0  
  
        for (day in 1..maxDay) {  
  
            while (index < sortedTable.size && sortedTable[index][0] <= day) {  
                pq.add(sortedTable[index])  
                index++  
            }  
  
            while (pq.isNotEmpty()) {  
                val content = pq.poll()  
                if(content[1] >= day){  
                    result += content[2]  
                    break  
                }  
            }  
  
        }  
  
        return result  
    }  
}
```
5) ê³¼ì¼ ë°”êµ¬ë‹ˆ ì±„ìš°ê¸° - ìš°ì„  ìˆœìœ„ í
```kotlin
class FruitsBox {  
    /**  
     * ğŸŸ© ë¬¸ì œ ì´ë¦„: ğŸ“¦ ê³¼ì¼ ë°”êµ¬ë‹ˆ ì±„ìš°ê¸°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ë‹¹ì‹ ì€ ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ê³¼ì¼ì„ íŒ”ê³  ìˆëŠ” ìƒì¸ì´ë©°, ê°ê°ì˜ ê³¼ì¼ì—ëŠ” ê°€ê²©ì´ ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤.  
     * ë‹¹ì‹ ì€ í•˜ë£¨ ë™ì•ˆ í•œ ì¢…ë¥˜ì˜ ê³¼ì¼ì„ í•˜ë‚˜ì”©ë§Œ íŒ” ìˆ˜ ìˆìœ¼ë©°, ê³¼ì¼ì„ íŒ” ìˆ˜ ìˆëŠ” ê¸°ê°„ë„ ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤.  
     * ë‹¹ì‹ ì€ í•˜ë£¨ì— í•œ ë²ˆ, íŒ” ìˆ˜ ìˆëŠ” ê³¼ì¼ ì¤‘ ê°€ì¥ ë¹„ì‹¼ ê³¼ì¼ì„ íŒ”ì•„ì•¼ í•©ë‹ˆë‹¤.  
     *    
     * ê³¼ì¼ë§ˆë‹¤ ì£¼ì–´ì§„ íŒë§¤ ê°€ëŠ¥ ê¸°ê°„ ì¤‘, ê°€ì¥ ë¹„ì‹¼ ê³¼ì¼ì„ íŒ”ì•„ ì–»ì„ ìˆ˜ ìˆëŠ” ì´ ìˆ˜ìµì„ êµ¬í•˜ì„¸ìš”.  
     *    
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²« ë²ˆì§¸ ì¤„: ê³¼ì¼ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 1,000)    
     *  â€¢  ì´í›„ Nì¤„: ê° ê³¼ì¼ì˜ íŒë§¤ ì‹œì‘ì¼ start, íŒë§¤ ì¢…ë£Œì¼ end, ê°€ê²© price (1 â‰¤ start â‰¤ end â‰¤ 1,000 / 1 â‰¤ price â‰¤ 100,000)    
     *   
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  í•˜ë£¨ì— í•˜ë‚˜ì”©ë§Œ íŒ” ìˆ˜ ìˆì„ ë•Œ, ê°€ëŠ¥í•œ ìµœëŒ€ ìˆ˜ìµì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 4  
     * 1 2 50   
     * 1 3 10    
     * 2 2 20     
     * 3 3 30   
     *    
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 100  
     */ 
     
	@Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 3, 10),  
            intArrayOf(2, 2, 20),  
            intArrayOf(3, 3, 30)  
        )  
  
        val expected = 100  
  
        assertEquals(expected, greedy(table))  
    }  
  
    private fun greedy(table: Array<IntArray>): Int {  
        table.sortWith(compareBy ({ it[0] }, {it[1]}))  
        val maxDay = table.maxOf { it[1] }  
        val queue = PriorityQueue<IntArray>(compareByDescending { it[2] })  
        var index = 0  
        var result = 0  
  
        for(day in 1 .. maxDay) {  
  
            while( index < table.size && day >= table[index][0]) {  
                queue.add(table[index++])  
            }  
  
  
            while (queue.isNotEmpty()) {  
                val element = queue.poll()  
                if( element[1] >= day ) {  
                    result += element[2]  
                    break  
                }  
            }  
        }  
  
        return result  
    }  
}
```
6) ìµœì†Œ íšŒì˜ì‹¤ ë¬¸ì œ - ìš°ì„  ìˆœìœ„ í
```kotlin
class MeetingRoomMinimum {  
    /**  
     * ğŸŸ© íŒ¨í„´: ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •  
     *  
     * 2. ìµœì†Œ íšŒì˜ì‹¤ ë¬¸ì œ  
     *  
     * ğŸ’¡ ë¬¸ì œ ì´ë¦„  
     * ğŸª‘ ìµœì†Œ íšŒì˜ì‹¤ ê°œìˆ˜  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ì—¬ëŸ¬ ê°œì˜ íšŒì˜ê°€ ì£¼ì–´ì ¸ ìˆê³ , ê° íšŒì˜ëŠ” ì‹œì‘ ì‹œê°„ê³¼ ì¢…ë£Œ ì‹œê°„ì´ ìˆìŠµë‹ˆë‹¤.  
     * ë™ì‹œì— ì—¬ëŸ¬ íšŒì˜ë¥¼ ì—´ ìˆ˜ ìˆì§€ë§Œ, ê°™ì€ íšŒì˜ì‹¤ì—ì„œ ê²¹ì¹˜ëŠ” íšŒì˜ëŠ” ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.  
     * ëª¨ë“  íšŒì˜ë¥¼ ì—´ê¸° ìœ„í•´ í•„ìš”í•œ ìµœì†Œ íšŒì˜ì‹¤ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: íšŒì˜ ìˆ˜ N (1 â‰¤ N â‰¤ 1,000)
     *  â€¢  ì´í›„ Nì¤„: ê° íšŒì˜ì˜ ì‹œì‘ ì‹œê°„, ì¢…ë£Œ ì‹œê°„ (0 â‰¤ s < e â‰¤ 1,000)    
     *  
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  í•„ìš”í•œ ìµœì†Œ íšŒì˜ì‹¤ì˜ ìˆ˜  
     *  
     * â¸»  
     *  
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 3  
     * 0 5 
     * 1 2    
     * 1 10   
     *    
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥  
     * 3  
     */  
 
    @Test  
    fun solution() {  
        val timetable = arrayOf(  
            intArrayOf(0, 5),  
            intArrayOf(1, 2),  
            intArrayOf(1, 10)  
        )  
  
        val expected = 3  
  
        assertEquals(expected, greedy((timetable)))  
    }  
  
    private fun greedy(timetable: Array<IntArray>): Int {  
        timetable.sortWith(compareBy({ it[0] }, { it[1] }))  
        val queue = PriorityQueue<IntArray>(compareBy { it[1] })  
        queue.add(timetable[0])  
        for (i in 1 until timetable.size) {  
            if (queue.peek()[1] <= timetable[i][0]) {  
                queue.poll()  
            }  
            queue.add(timetable[i])  
        }  
        return timetable.size  
    }  
}
```
---
6-1) ìµœì†Œ íšŒì˜ì‹¤ ë¬¸ì œ ì‘ìš©
```kotlin
class `í˜¸í…” ëŒ€ì‹¤` {  
    /**  
     * https://school.programmers.co.kr/learn/courses/30/lessons/155651     */  
    @Test  
    fun solution1() {  
        val book_time = arrayOf(  
            arrayOf("15:00", "17:00"),  
            arrayOf("16:40", "18:20"),  
            arrayOf("14:20", "15:20"),  
            arrayOf("14:10", "19:20"),  
            arrayOf("18:20", "21:20")  
        )  
        val expected = 3  
  
        assertEquals(expected, calculate(book_time))  
    }  
  
    @Test  
    fun solution2() {  
        val book_time = arrayOf(  
            arrayOf("09:10", "10:10"),  
            arrayOf("10:20", "12:20")  
        )  
        val expected = 1  
  
        assertEquals(expected, calculate(book_time))  
    }  
  
    @Test  
    fun solution3() {  
        val book_time = arrayOf(  
            arrayOf("10:20", "12:30"),  
            arrayOf("10:20", "12:30"),  
            arrayOf("10:20", "12:30")  
        )  
        val expected = 3  
  
        assertEquals(expected, calculate(book_time))  
    }  
  
    @Test  
    fun test() {  
        println("00:00" <= "01:00")  
        println("11:30" <= "12:30")  
        println("12:30" <= "23:30")  
        println(calculateTime("12:30"))  
        println(calculateTime("12:59"))  
        println(calculateTime("23:59"))  
    }  
  
    private fun calculate(book_time: Array<Array<String>>): Int {  
        val priorityQueue = PriorityQueue<String>()  
        val sortedArray = book_time.sortedWith(compareBy({ it[0] }, { it[1] }))  
  
  
        for (i in sortedArray.indices) {  
            val time = sortedArray[i]  
            if (priorityQueue.isNotEmpty() && priorityQueue.peek() <= time[0]) {  
                priorityQueue.poll()  
            }  
            priorityQueue.add(calculateTime(time[1]))  
        }  
  
  
        return priorityQueue.size  
    }  
  
    private fun calculateTime(time: String): String {  
        val split = time.split(":")  
        var hours = split[0].toInt()  
        var minutes = split[1].toInt() + 10  
        if (minutes >= 60) {  
            minutes -= 60  
            hours += 1  
        }  
  
        return "${if(hours < 10) "0$hours" else hours}:${if (minutes < 10) "0$minutes" else minutes}"  
    }  
}
```


---

7) ê¸°íƒ€ ìˆ˜ë¦¬ - ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •
```kotlin
class GuitarRepairShop {  
    /**  
     * ğŸŸ© ë¬¸ì œ ì´ë¦„: ğŸ¸ ê¸°íƒ€ ìˆ˜ë¦¬  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ë‹¹ì‹ ì€ ê¸°íƒ€ ìˆ˜ë¦¬ì ì˜ ê¸°ì‚¬ì…ë‹ˆë‹¤.  
     * ê° ì†ë‹˜ì€ **ë„ì°©ì¼(start)**ê³¼ **ìµœëŒ€ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆëŠ” ê¸°ê°„(wait)**ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
     * í•˜ë£¨ì— ê¸°íƒ€ í•˜ë‚˜ë§Œ ìˆ˜ë¦¬í•  ìˆ˜ ìˆìœ¼ë©°, ì†ë‹˜ì€ ìì‹ ì´ ë„ì°©í•œ ë‚ ë¶€í„° ê¸°ë‹¤ë¦´ ìˆ˜ ìˆëŠ” ë‚ ì§œê¹Œì§€ ìˆ˜ë¦¬ë¥¼ ë§¡ê¸°ê³  ì‹¶ì–´ í•©ë‹ˆë‹¤.  
     *    
     * ëª¨ë“  ì†ë‹˜ì˜ ê¸°íƒ€ë¥¼ ìµœëŒ€í•œ ë§ì´ ìˆ˜ë¦¬í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ë‹¹ì‹ ì´ ìˆ˜ë¦¬ ê°€ëŠ¥í•œ ê¸°íƒ€ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„: ì†ë‹˜ ìˆ˜ N (1 â‰¤ N â‰¤ 1,000)    
     *  â€¢  ì´í›„ Nì¤„: ê° ì†ë‹˜ì˜ ë„ì°©ì¼ start, ìµœëŒ€ ëŒ€ê¸°ì¼ wait (1 â‰¤ start â‰¤ 1,000, 1 â‰¤ wait â‰¤ 1,000)     
     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ìˆ˜ë¦¬í•  ìˆ˜ ìˆëŠ” ê¸°íƒ€ì˜ ìµœëŒ€ ê°œìˆ˜  
     * â¸»  
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 5  
     * 1 2    
     * 3 1   
     * 2 3    
     * 4 2    
     * 5 1   
     * ğŸ§ª ì˜ˆì œ ì¶œë ¥  
     * 5  
     */  
     
    @Test  
    fun solution() {  
        val timetable = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(3, 1),  
            intArrayOf(2, 3),  
            intArrayOf(4, 2),  
            intArrayOf(5, 1),  
        )  
  
        val expected = 5  
  
        assertEquals(expected, greedy(timetable))  
    }  
  
    @Test  
    fun solution1() {  
        val timetable = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 2),  
            intArrayOf(2, 1),  
            intArrayOf(2, 1),  
            intArrayOf(1, 2),  
        )  
  
        val expected = 3  
  
        assertEquals(expected, greedy(timetable))  
    }  
  
  
    private fun greedy(timetable: Array<IntArray>): Int {  
        timetable.sortWith(compareBy { it[0] + it[1] })  
        var day = 1  
        var count = 0  
  
        for (table in timetable) {  
            val start = table[0]  
            val end = table[0] + table[1]  
  
            if(day < start) {  
                day = start  
            }  
  
            if(day in start .. end) {  
                count++  
                day++  
            }  
        }  
  
        return count  
    }  
	
	@Deprecated("ì†ë‹˜ë“¤ì´ ì„œë¡œ ë²”ìœ„ê°€ ê²¹ì¹˜ë©´ ì²˜ë¦¬í•  ìˆ˜ ì—†ë‹¤.")
    private fun failureCase(timetable: Array<IntArray>): Int {  
	    timetable.sortWith(compareBy({ it[0] }, { it[1] }))  
	    val queue = PriorityQueue<IntArray>(compareBy({ -it[0] }, { -it[1] }))  
	    val maxDay = timetable.maxOf { it[0] }  
	    var day = 1  
	    var index = 0  
	    var count = 0  
	  
	    while (day <= maxDay) {  
	        while (index < timetable.size && timetable[index][0] <= day) {  
	            queue.offer(timetable[index])  
	            index++  
	        }  
	  
	        while (queue.isNotEmpty()) {  
	            val poll = queue.poll()  
	            val start = poll[0]  
	            val end = poll[0] + poll[1]  
	  
	            if (day in start..start + end) {  
	                day ++  
	                count ++  
	            }  
	        }  
	  
	        if(queue.isEmpty()) {  
	            day ++  
	        }  
	    }  
	  
	  
	    return count  
	}
}
```
8) ì²´ìœ¡ë³µ ë„ë‚œ - ì •ë ¬ + ì„ íƒ
```kotlin
class GymSuit {  
    /**  
     *<pre>    
      * ## ì²´ìœ¡ë³µ  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     *  
     * í•™êµì—ëŠ” ì²´ìœ¡ ìˆ˜ì—…ì´ ìˆìŠµë‹ˆë‹¤.  
     * ëª¨ë“  í•™ìƒì€ ì²´ìœ¡ë³µì„ í•œ ë²Œì”© ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
     * í•˜ì§€ë§Œ ì¼ë¶€ í•™ìƒë“¤ì€ ì²´ìœ¡ë³µì„ ë„ë‚œë‹¹í–ˆê³ , ì¼ë¶€ í•™ìƒë“¤ì€ ì—¬ë²Œì˜ ì²´ìœ¡ë³µì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
     * ì²´ìœ¡ë³µì´ ì—†ëŠ” í•™ìƒì€ ì•ë²ˆí˜¸ë‚˜ ë’·ë²ˆí˜¸ì˜ í•™ìƒì—ê²Œë§Œ ë¹Œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ëª¨ë“  í•™ìƒì´ ì²´ìœ¡ ìˆ˜ì—…ì„ ë“¤ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ í•™ìƒ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  í•™ìƒ ìˆ˜ N (2 â‰¤ N â‰¤ 30)     
     *  â€¢  ë„ë‚œë‹¹í•œ í•™ìƒ ë²ˆí˜¸ ëª©ë¡ lost[] (ë²ˆí˜¸ëŠ” 1ë¶€í„° Nê¹Œì§€)  
     *  â€¢  ì—¬ë²Œ ì²´ìœ¡ë³µì„ ê°€ì§„ í•™ìƒ ë²ˆí˜¸ ëª©ë¡ reserve[] (ë²ˆí˜¸ëŠ” 1ë¶€í„° Nê¹Œì§€)  
     * â¸»  
     * ì¶œë ¥  
     *  â€¢  ìˆ˜ì—…ì„ ë“¤ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ í•™ìƒ ìˆ˜  
     * â¸»  
     *  
     * ì¡°ê±´  
     *  â€¢  ë„ë‚œë‹¹í•œ í•™ìƒì´ ì—¬ë²Œì„ ê°€ì§€ê³  ìˆë‹¤ë©´, ê·¸ í•™ìƒì€ ìì‹ ì˜ ì—¬ë²Œì„ ì‚¬ìš©í•©ë‹ˆë‹¤.  
     *  â€¢  ë¹Œë ¤ì¤„ ìˆ˜ ìˆëŠ” ì¡°ê±´ì€ ì•ë²ˆí˜¸, ë’·ë²ˆí˜¸ í•™ìƒë§Œ ê°€ëŠ¥.  
     *  â€¢  ëª¨ë“  ì…ë ¥ ê°’ì€ ìì—°ìˆ˜ì´ë©°, ì…ë ¥ ëª©ë¡ì˜ ê¸¸ì´ëŠ” í•™ìƒ ìˆ˜ ì´í•˜ì…ë‹ˆë‹¤.  
     * â¸»  
     * ì˜ˆì œ ì…ë ¥  
     *  
     * N=5    
     * lost=[2, 4]    
     * reserve=[3]   
     * â¸»  
     * ì˜ˆì œ ì¶œë ¥  
     * 4  
     * </pre>    
     */


    @Test  
    fun solution() {  
        val student = 5  
        val lost = intArrayOf(2, 4)  
        val reserve = intArrayOf(3)  
  
        val expected = 4  
  
        assertEquals(expected, greedy(student, lost, reserve))  
    }  
  
    private fun greedy(student: Int, lost: IntArray, reserve: IntArray): Int {  
        val lostStudent = lost.toMutableList()  
        val reserveStudent = reserve.toMutableList()  
        lostStudent.removeAll(reserve.toList())  
        reserveStudent.removeAll(lost.toList())  
        var count = student - lostStudent.size  
  
        for( i in lostStudent) {  
            when {  
                reserveStudent.contains(i - 1) -> {  
                    reserveStudent.remove(i - 1)  
                    count++  
                    lostStudent.remove(i)  
                }  
                reserveStudent.contains(i + 1) -> {  
                    reserveStudent.remove(i + 1)  
                    count++  
                    lostStudent.remove(i)  
                }  
            }  
        }  
  
        return count  
    }  
}
```
9) í—ˆí”„ë§Œ ì½”ë”© ë¬¸ì œ - ìš°ì„  ìˆœìœ„ í
```kotlin
class Huffman {  
 /**  
 * <pre> 
 * í—ˆí”„ë§Œ ì½”ë”© ë¬¸ì œ  
 *  
 * ë¬¸ìë“¤ì´ ì£¼ì–´ì§€ê³ , ê° ë¬¸ìì˜ ë“±ì¥ ë¹ˆë„ê°€ ìˆìŠµë‹ˆë‹¤.  
 * ì´ ë¹ˆë„ë¥¼ ì´ìš©í•´ í—ˆí”„ë§Œ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ì–´ ìµœì†Œí•œì˜ ì¸ì½”ë”© ë¹„ìš©ì„ ê³„ì‚°í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
 * ë‘ ê°œì˜ ê°€ì¥ ì‘ì€ ë¹ˆë„ìˆ˜ë¥¼ ê°€ì§„ ë…¸ë“œë¥¼ í•©ì¹˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬, ëª¨ë“  ë¬¸ìë¥¼ í¬í•¨í•˜ëŠ” í•˜ë‚˜ì˜ íŠ¸ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤.  
 * ì´ë•Œ, í•©ì¹˜ëŠ” ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ë¹„ìš©ì€ ë‘ ë¹ˆë„ìˆ˜ì˜ í•©ì…ë‹ˆë‹¤.  
 * ì „ì²´ ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ë¹„ìš©ì˜ ì´í•©ì„ êµ¬í•˜ì„¸ìš”.  
 * â¸»  
 * ì…ë ¥  
 *  â€¢  ë¹ˆë„ìˆ˜ë¥¼ ë‹´ì€ ì •ìˆ˜ ë°°ì—´ frequencies[] (1 â‰¤ ë°°ì—´ ê¸¸ì´ â‰¤ 1000, ê° ë¹ˆë„ëŠ” ìì—°ìˆ˜)  
 * â¸»  
 * ì¶œë ¥  
 *  â€¢  ìµœì†Œ ì¸ì½”ë”© ë¹„ìš©ì˜ ì´í•© (ì •ìˆ˜)  
 * â¸»  
 * ì˜ˆì œ  
 *  
 * ì…ë ¥: [3, 1, 2, 4]  
 * ì¶œë ¥: 19  
 * 
 *  > ## 1. í—ˆí”„ë§Œ íŠ¸ë¦¬  
 *  > ë°ì´í„° ì••ì¶•ì— ì‚¬ìš©ë˜ëŠ” ì´ì§„ íŠ¸ë¦¬ êµ¬ì¡°  
 *  > ìì£¼ ë“±ì¥í•˜ëŠ” ë¬¸ìì¼ìˆ˜ë¡ ì§§ì€ ë¹„íŠ¸ ìˆ˜ë¡œ, ëœ ë“±ì¥í•˜ëŠ” ë¬¸ìëŠ” ê¸´ ë¹„íŠ¸ìˆ˜ë¡œ ì¸ì½”ë”©í•´ì„œ ì „ì²´ ë°ì´í„° í¬ê¸°ë¥¼ ìµœì†Œí™” í•˜ëŠ” ë°©ì‹  
 *  >  
 *  > ## 2. í—ˆí”„ë§Œ íŠ¸ë¦¬ë¥¼ ë§Œë“œëŠ” ë°©ë²•  
 *  > 1. ëª¨ë“  ë¬¸ìë¥¼ ê°ê° í•˜ë‚˜ì˜ ë…¸ë“œë¡œ ì·¨ê¸‰í•˜ì—¬ ìš°ì„ ìˆœìœ„ íì— ë„£ëŠ”ë‹¤.  
 *  > 2. ìµœì†Œ ë¹ˆë„ ë‘ ê°œë¥¼ êº¼ë‚´ì„œ ìƒˆë¡œìš´ ë¶€ëª¨ ë…¸ë“œë¥¼ ë§Œë“¤ê³ , ë‘ ë…¸ë“œì˜ ë¹ˆë„ í•©ì„ ë¶€ëª¨ ë…¸ë“œì˜ ë¹ˆë„ í•©ìœ¼ë¡œ ì„¤ì •í•œë‹¤.  
 *  > 3. ìƒˆë¡œ ë§Œë“  ë¶€ëª¨ ë…¸ë“œë¥¼ ë‹¤ì‹œ íì— ë„£ëŠ”ë‹¤.  
 *  > 4. íì— ë…¸ë“œê°€ í•˜ë‚˜ ë‚¨ì„ ë•Œê¹Œì§€ 2 ~ 3 ë°˜ë³µ  
 *  
 *   ë¬¸ì ë¹ˆë„  
 *  â€¢  a: 5  
 *  â€¢  b: 2
 *  â€¢  c: 2 
 *  â€¢  d: 1 
 *  â€¢  e: 1
 *  â€¢  f: 1 
 * â¸»  
 * í—ˆí”„ë§Œ íŠ¸ë¦¬ ë‹¨ê³„ë³„ ìƒì„±  
 *  1. d(1) + e(1) = de(2)  
 *  2. f(1) + b(2) = fb(3) 
 *  3. c(2) + de(2) = cde(4) 
 *  4. fb(3) + cde(4) = fbcde(7) 
 *  5. a(5) + fbcde(7) = root(12)
 * â¸»  
 * ìµœì¢… íŠ¸ë¦¬ êµ¬ì¡°  
 *             (12)  
 *           /     \ 
 *         (7)       a(5) 
 *      /      \ 
 *    (3)       (4) 
 *   /   \     /   \ 
 * f(1) b(2) c(2) (2)
 *               /   \
 *            d(1)   e(1) 
 * 
 * * í’€ì´  
 * 1 2 3 4  
 * 
 * 1 + 2 = 3 
 * 3 + 3 = 6
 * 4 + 6 = 10
 * </pre> 
 * */
 
    @Test  
    fun solution() {  
        val input = intArrayOf(3, 1, 2, 4)  
        val expected = 19  
  
        assertEquals(expected, greedy(input))  
    }  
  
    private fun greedy(input: IntArray): Int {  
        input.sort()  
        val queue = PriorityQueue<Int>(compareBy { it })  
        input.forEach { queue.add(it) }  
        var result = 0  
  
        while(queue.size > 1) {  
            val sum = queue.poll() + queue.poll()  
            result  += sum  
            queue.offer(sum)  
        }  
  
        return result  
    }  
}
```

10) MST (Kruskal) - ì •ë ¬ + ì„ íƒ
```kotlin
  
/**  
 * <pre> 
 *     ## ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬  
 *  
 *  - ì •ì˜  
 *  ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ì—°ê²° ê·¸ë˜í”„ì—ì„œ ëª¨ë“  ì •ì (vertex)ë¥¼ í¬í•¨í•˜ë©´ì„œ  
 *  ì‚¬ì´í´ì´ ì—†ê³ (íŠ¸ë¦¬) ê°„ì„ (edge)ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ìµœê³ ê°€ ë˜ëŠ” ë¶€ë¶„ ê·¸ë˜í”„  
 *  
 *  > ê°€ì¤‘ì¹˜ : ê·¸ë˜í”„ì—ì„œ ê°„ì„ ì— ë¶™ëŠ” ìˆ«ì ê°’. ë‘ ë…¸ë“œë¥¼ ì—°ê²°í•˜ëŠ” ë¹„ìš©, ê±°ë¦¬, ì‹œê°„, ìš©ëŸ‰ ë“± ë¬¸ì œì— ë”°ë¼ ì—¬ëŸ¬ ì˜ë¯¸ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆë‹¤.  
 *  > ì •ì : ê·¸ë˜í”„ì—ì„œ í•˜ë‚˜ì˜ ì ì´ë‚˜ ë…¸ë“œ  
 *  > ê°„ì„ : ë‘ ì •ì ì„ ì—°ê²°í•˜ëŠ” ì„   
 *  > ì—°ê²° ê·¸ë˜í”„: ê·¸ë˜í”„ ë‚´ì˜ ëª¨ë“  ì •ì ì´ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆì–´ì„œ ì–´ëŠ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ëª¨ë“  ì •ì ìœ¼ë¡œ ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” ê·¸ë˜í”„  
 *  > ì‚¬ì´í´ : ê·¸ë˜í”„ì—ì„œ í•œ ì •ì ì—ì„œ ì¶œë°œí•´ì„œ ë‹¤ë¥¸ ì •ì ë“¤ì„ ê±°ì³ì„œ ë‹¤ì‹œ ì›ë˜ ì •ì ìœ¼ë¡œ ëŒì•„ì˜¤ëŠ” ê²½ë¡œê°€ ì¡´ì¬í•˜ëŠ” ê²½ìš°  
 *  > íŠ¸ë¦¬ : ì‚¬ì´í´ì´ ì—†ëŠ” ì—°ê²° ê·¸ë˜í”„  
 *  
 * ì˜ˆ)  
 * A -- B -- C 
 *      | 
 *      D 
 * 
 *  - ì£¼ìš” íŠ¹ì§•  
 *  1. ëª¨ë“  ì •ì ì„ ì—°ê²°í•œë‹¤.  
 *  2. ì‚¬ì´í´ì´ ì—†ì–´ì•¼ í•œë‹¤.  
 *  3. ê°„ì„  ê°€ì¤‘ì¹˜ í•© ìµœì†Œ  
 *  4. ë¬´ë°©í–¥ ê·¸ë˜í”„ë‹¤.  
 * </pre>
 * 
 * --- 
 * 
 * <pre>
 *  ## í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜  
 *  - ì£¼ì–´ì§„ ì—°ê²° ê·¸ë˜í”„ì—ì„œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)ë¥¼ ì°¾ëŠ” ê²ƒ  
 *  - ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì„ íƒí•˜ë˜, ì‚¬ì´í´ì„ ë§Œë“¤ì§€ ì•ŠëŠ” ê°„ì„ ë§Œ í¬í•¨  
 *  - ì£¼ìš” ì ˆì°¨  
 *      1. ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬  
 *      2. ìˆœì„œëŒ€ë¡œ ê°„ì„  ì„ íƒ  
 *      3. ì„ íƒí•œ ê°„ì„ ì´ ì‚¬ì´í´ì„ ë§Œë“¤ë©´ ì œì™¸  
 *      4. ëª¨ë“  ì •ì ì´ ì—°ê²°ë  ë•Œê¹Œì§€ ë°˜ë³µ  
 *  - ì‚¬ì´í´  
 *      1. ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Disjoint Set Union, DSU) ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•´ì„œ ë¹ ë¥´ê²Œ íŒë³„  
 *      2. ë‘ ì •ì ì´ ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ì‚¬ì´í´ ë°œìƒ  
 * </pre>  
 * > ## DSU: ì„œë¡œì†Œ ì§‘í•© ìë£Œ êµ¬ì¡°?  
 * > 1. ì—¬ëŸ¬ ê°œì˜ ì›ì†Œê°€ ìˆì„ ë•Œ,  
 * > 2. ê° ì›ì†Œê°€ ì†í•œ ì§‘í•©ì„ ê´€ë¦¬í•˜ê³   
 * > 3. ë‘ ì§‘í•©ì„ í•©ì¹˜ê±°ë‚˜(Union)  
 * > 4. íŠ¹ì • ì›ì†Œê°€ ì–´ë–¤ ì§‘í•©ì— ì†í•˜ëŠ”ì§€ ì°¾ëŠ” ì—°ì‚°ì„ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•˜ëŠ” ìë£Œêµ¬ì¡°  
 * > ## ì£¼ìš” ì—°ì‚°  
 * > 1. find(x)  
 * >   - ì›ì†Œ xê°€ ì†í•œ ì§‘í•©ì˜ ëŒ€í‘œìë¥¼ ì°¾ëŠ”ë‹¤.  
 * >   - ê°™ì€ ì§‘í•©ì— ì†í•œ ì›ì†Œë“¤ì€ ê°™ì€ ëŒ€í‘œìë¥¼ ê°€ì§„ë‹¤.  
 * > 2. Union(a,b) * >   - ì›ì†Œ aê°€ ì†í•œ ì§‘í•©ê³¼ ì›ì†Œ bê°€ ì†í•œ ì§‘í•©ì„ í•©ì¹œë‹¤.  
 * >   - ë‘ ì›ì†Œê°€ ê°™ì€ ì§‘í•©ì´ë©´ í•©ì¹˜ì§€ ì•Šê³  ì‚¬ì´í´ ë°œìƒì„ ë§‰ëŠ”ë‹¤.  
 */
 class DisjointSetUnion(size: Int) {  
    private val parent = IntArray(size) { it }  
    private val rank = IntArray(size) { 0 }  
  
    fun find(x: Int): Int {  
        if (parent[x] != x) {  
            parent[x] = find(parent[x])  
        }  
        return parent[x]  
    }  
  
    fun union(a: Int, b: Int): Boolean {  
        val rootA = find(a)  
        val rootB = find(b)  
  
        if (rootA == rootB) return false  
  
        if (rank[rootA] < rank[rootB]) {  
            parent[rootA] = rootB  
        } else if (rank[rootA] > rank[rootB]) {  
            parent[rootB] = rootA  
        } else {  
            parent[rootB] = rootA  
            rank[rootA]++  
        }  
  
        return true  
    }  
}
```
```kotlin
class Kruskal {  
  
  
    /**  
     * <pre> 
     * ì˜ˆì‹œ ê¸°ì´ˆ ë¬¸ì œ  
     * ë¬¸ì œ: ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜)  
     *    
     * ì •ì ì˜ ê°œìˆ˜ nê³¼ ê°„ì„ ë“¤ì˜ ì •ë³´ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ì´ ê·¸ë˜í”„ëŠ” ë¬´ë°©í–¥ ê·¸ë˜í”„ì´ë©°, ê° ê°„ì„ ì€ ë‘ ì •ì ê³¼ ê°€ì¤‘ì¹˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.  
     *    
     * ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)ë¥¼ ë§Œë“¤ ë•Œ, MSTì— í¬í•¨ë˜ëŠ” ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì„ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„ì— ì •ì ì˜ ê°œìˆ˜ nê³¼ ê°„ì„ ì˜ ê°œìˆ˜ mì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. (1 â‰¤ n â‰¤ 1000, 1 â‰¤ m â‰¤ 10000)  
     *  â€¢  ë‹¤ìŒ mê°œì˜ ì¤„ì—ëŠ” ê°„ì„  ì •ë³´ u v wê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  uì™€ vëŠ” ê°„ì„ ì´ ì—°ê²°í•˜ëŠ” ë‘ ì •ì  (0 â‰¤ u, v < n)   
     *  â€¢  wëŠ” ê°€ì¤‘ì¹˜ (1 â‰¤ w â‰¤ 10000)   
     * â¸»  
     *  
     * ì¶œë ¥  
     *  â€¢  MSTì— í¬í•¨ëœ ê°„ì„  ê°€ì¤‘ì¹˜ í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     * â¸»  
     *  
     * ì˜ˆì‹œ ì…ë ¥  
     * vertex: 4  
     * edge: 5  
     * 0 1 1   
     * 0 2 4   
     * 1 2 2    
     * 1 3 6    
     * 2 3 3    
     *    
     * ì˜ˆì‹œ ì¶œë ¥  
     * 6  
     * </pre>    
     * */  
      
   @Test  
	fun solution() {  
	    val vertex = 4  
	    val edge = 5  
	    val connection = arrayOf(  
	        intArrayOf(0, 1, 1),  
	        intArrayOf(0, 2, 4),  
	        intArrayOf(1, 2, 2),  
	        intArrayOf(1, 3, 6),  
	        intArrayOf(2, 3, 3),  
	    )  
	    val expected = 6  
	    /**  
	     * Q.    
	     * 1. ì–´ë–¤ ë…¸ë“œì—ì„œ ì‹œì‘í•˜ë©´ ì¢‹ì„ê¹Œ?  
	     *    -> ê°€ì¤‘ì¹˜ë¡œ sortí•˜ê³  ë‚®ì€ ê³³ë¶€í„° ì‹œì‘  
	     *    -> ìœ„ ì˜ˆì‹œë¡œëŠ” 0ì´ë‚˜ 1    
	     *      -> ë‹¤ìŒ ë…¸ë“œì˜ ì‹œì‘ì ì„ í™•ì¸í•´ì„œ ì´ì–´ì§€ëŠ” ìª½ ë°˜ëŒ€ìª½ì—ì„œ ì‹œì‘í•˜ë©´ ë  ê²ƒ ê°™ì€ë°?  
	     *         -> 0 -> 1 -> 2 -> 3 (1 + 2 + 3)    
	     *         => A.ì‹œì‘ì ì€ ìƒê´€ ì—†ë‹¤. ì—°ê²°ë§Œ í™•ì¸í•œë‹¤.  
	     *      -> ê·¸ëŸ¼ ë‹¤ìŒ ê²ƒ ì²´í¬í–ˆì„ ë•Œ ì•ˆ ì´ì–´ì ¸ ìˆìœ¼ë©´??  
	     *      -> ê·¸ ë‹¤ìŒ elementë¡œ ë„˜ì–´ê°€ë‚˜?  
	     *          -> ëê¹Œì§€ ì•ˆë˜ë©´?  
	     *          => ì—°ê²° ê·¸ë˜í”„ë¼ëŠ” ì „ì œí•˜ì— ì‹œì‘í•œë‹¤.  
	     *    -> ê·¸ëŸ¼ ì‚¬ì´í´ ì²´í¬ëŠ”?  
	     *      -> ë‹¤ìŒ ê²ƒ ì°¾ì„ ë•Œë§ˆë‹¤ ì§„í–‰í•˜ëŠ”ê°€?  
	     * 2. ë…¸ë“œë¥¼ ì§€ë‚  ë•Œë§ˆë‹¤ vertexë¥¼ ì¤„ì—¬ì„œ ëª¨ë‘ ìˆœíšŒí–ˆëŠ”ì§€ ì²´í¬  
	     * 3. vertex + 1 = edge  
	     *   
	     * Pseudo    
	     *     connectionìœ¼ë¡œ sort    
	     *     var result = 0    
	     *     for( i in connection )    
	     *      resutl += if( DSUì— union ) i[2] else 0   
	     * */  
	  
	    assertEquals(expected, kruskal(vertex, connection))  
	}  
	  
	private fun kruskal(vertex: Int, connection: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex)  
	    connection.sortBy { it[2] }  
	    var result = 0  
	  
	    for (i in connection) {  
	        result += if (dsu.union(i[0], i[1])) i[2] else 0  
	    }  
	  
	  
	    return result  
	}

	private inner class DisjointSetUnion(size: Int) {  
	    private val parent = IntArray(size) { it }  
	    private val rank = IntArray(size) { 0 }  
	  
	    fun find(x: Int): Int {  
	        if (parent[x] != x) {  
	            parent[x] = find(parent[x])  
	        }  
	        return parent[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if (rank[rootA] < rank[rootB]) {  
	            parent[rootA] = rootB  
	        } else if (rank[rootA] > rank[rootB]) {  
	            parent[rootB] = rootA  
	        } else {  
	            parent[rootB] = rootA  
	            rank[rootA]++  
	        }  
	  
	        return true  
	    }  
	}
}
```
11) í™œë™ ì„ íƒ - ì •ë ¬ ê¸°ë°˜ ìˆœì„œ ê²°ì •
```kotlin
class ActivitySelection {  
    /**  
     * ë¬¸ì œ: í™œë™ ì„ íƒ (Activity Selection)   
     *   
     * ì—¬ëŸ¬ ê°œì˜ í™œë™ì´ ìˆê³ , ê° í™œë™ì€ ì‹œì‘ ì‹œê°„ê³¼ ì¢…ë£Œ ì‹œê°„ì´ ì •í•´ì ¸ ìˆìŠµë‹ˆë‹¤.  
     * í•œ ì‚¬ëŒì´ ê²¹ì¹˜ì§€ ì•Šê²Œ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” í™œë™ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     *    
     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  n: í™œë™ì˜ ê°œìˆ˜ (1 â‰¤ n â‰¤ 100,000)    
     *  â€¢  ë‹¤ìŒ nê°œì˜ ì¤„ì—ëŠ” ê°ê° í™œë™ì˜ ì‹œì‘ ì‹œê°„ê³¼ ì¢…ë£Œ ì‹œê°„ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. (ì‹œì‘ ì‹œê°„ < ì¢…ë£Œ ì‹œê°„)  
     *   
     * â¸»  
     *  
     * ì¶œë ¥  
     *  â€¢  ê²¹ì¹˜ì§€ ì•Šê²Œ ì„ íƒí•  ìˆ˜ ìˆëŠ” ìµœëŒ€ í™œë™ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     *     * ì˜ˆì‹œ ì…ë ¥  
     * í™œë™ì˜ ê°œìˆ˜ : 3    
     * ì‹œì‘  ì¢…ë£Œ  
     *  1    4  
     *  3    5     
     *  0    6     
     *     
     * ì˜ˆì‹œ ì¶œë ¥  
     * 1  
     */  
     
    @Test  
    fun solution(){  
        val activity = 3  
        val table = arrayOf(  
            intArrayOf(1, 4),  
            intArrayOf(3, 5),  
            intArrayOf(0, 6)  
        )  
        val expected = 1  
  
  
        assertEquals(expected, greedy(table))  
    }  
  
    fun greedy(table: Array<IntArray>): Int {  
        table.sortBy { it[1] }  
  
        var count = 1;  
        var end = table.first().last()  
  
        for(i in 1 until table.size){  
            if(end <= table[i][0]) {  
                count ++  
                end = table[i][1]  
            }  
        }  
  
        return count  
    }  
}
```

12) ì²´ì¸ ì—°ê²°
```kotlin
class ChangeConnection {  
    /**  
     * ë¬¸ì œ: ì²´ì¸ ì—°ê²° (Chain Connection)   
     *  
     * â¸»  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     *  â€¢  ì—¬ëŸ¬ ê°œì˜ ì²´ì¸ì´ ìˆìŠµë‹ˆë‹¤.  
     *  â€¢  ê° ì²´ì¸ì€ ì–‘ìª½ ëì— ìˆ«ìê°€ ì í˜€ ìˆìŠµë‹ˆë‹¤.  
     *  â€¢  ì²´ì¸ì„ ìµœëŒ€í•œ ê¸¸ê²Œ ì—°ê²°í•˜ë ¤ê³  í•  ë•Œ, ì—°ê²° ì¡°ê±´ì€ ì²´ì¸ì˜ ì˜¤ë¥¸ìª½ ìˆ«ìì™€ ë‹¤ìŒ ì²´ì¸ì˜ ì™¼ìª½ ìˆ«ìê°€ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤.  
     *  â€¢  ì²´ì¸ì„ ì ì ˆíˆ ì¬ë°°ì¹˜í•˜ê±°ë‚˜ ë’¤ì§‘ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     *  â€¢  ìµœëŒ€ ëª‡ ê°œì˜ ì²´ì¸ì„ ì—°ê²°í•  ìˆ˜ ìˆëŠ”ì§€ êµ¬í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì²´ì¸ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 100,000)   
     *  â€¢  ë‹¤ìŒ Nì¤„ì— ê°ê° ì²´ì¸ í•œ ê°œì˜ ì™¼ìª½ ìˆ«ìì™€ ì˜¤ë¥¸ìª½ ìˆ«ì (1 â‰¤ ìˆ«ì â‰¤ 1,000,000)     *   
     * â¸»  
     *  
     * ì¶œë ¥  
     *  â€¢  ìµœëŒ€ ì—°ê²°í•  ìˆ˜ ìˆëŠ” ì²´ì¸ì˜ ê°œìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * ì˜ˆì œ ì…ë ¥  
     * 5  
     * 1 2   
     * 2 3    
     * 3 4   
     * 5 1    
     * 4 5  
     *    
     * ì˜ˆì œ ì¶œë ¥  
     * 5  
     */  
     
    @Test  
    fun solution()  {  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 3),  
            intArrayOf(3, 4),  
            intArrayOf(5, 1),  
            intArrayOf(4, 5),  
        )  
        val expected = 5  
  
        assertEquals(expected, greedy(table))  
    }  
  
    fun greedy(table: Array<IntArray>): Int {  
        val dsu = DisjointUnion((table.flatMap { listOf(it[0], it[1]) }.maxOrNull() ?: 0) + 1)  
  
        for((first, second) in table) {  
            dsu.union(first, second)  
        }  
  
  
        var max = Int.MIN_VALUE  
        val sizeMap = mutableMapOf<Int, Int>()  
        for((first, _) in table) {  
            val root = dsu.find(first)  
  
            sizeMap[root] = (sizeMap[root] ?: 0)+ 1  
            max = maxOf(max, sizeMap[root]!!)  
        }  
  
        println(sizeMap)  
  
  
        return max  
    }  
  
    inner class DisjointUnion(size: Int) {  
        private val parent = IntArray(size) { it }  
        private val rank = IntArray(size) { 0 }  
  
  
        fun find(x: Int): Int {  
            if (parent[x] != x) {  
                parent[x] = find(parent[x])  
            }  
  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = find(a)  
            val rootB = find(b)  
  
            if (rootA == rootB) return false  
  
            if( rank[rootA] < rank[rootB]) {  
                parent[rootA] = rootB  
            }  
            else if(rank[rootA] > rank[rootB]){  
                parent[rootB] = rootA  
            }  
            else {  
                parent[rootB] = rootA  
                rank[rootA] ++  
            }  
  
            return true  
        }  
    }  
}
```
