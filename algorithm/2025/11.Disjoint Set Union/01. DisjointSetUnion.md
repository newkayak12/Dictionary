## 1. 정의
### 유니온 파인드 기초 개념

#### 서로소 집합 (Disjoint Set)이란?

**서로소 집합:** 교집합이 없는 집합들

```
예시: {1, 2, 3}, {4, 5}, {6, 7, 8, 9}
- 각 집합은 겹치는 원소가 없음
- 모든 원소는 정확히 하나의 집합에만 속함
```

## 2. 연산
### 1. Find(x)
- 속한 집합의 대표 원소 찾기
```text
Find(A) = A (A가 대표)
Find(B) = A (B도 A 그룹)
```
### 2. Union(x, y)
- 속한 집합과 y가 속한 집합 합치기
```text
Union(A, C) → {A, B}와 {C, D}를 합쳐서 {A, B, C, D}
```

## 3. 경로 압축
### 3.1. 경로 압축의 필요성

#### 문제: 트리가 일직선으로 늘어지는 경우

```
최악의 경우:
0 → 1 → 2 → 3 → 4 → 5

Find(0) 할 때:
0 → 1 → 2 → 3 → 4 → 5 (5번 이동!)
```

**시간복잡도:** O(N) - 매우 느림!

### 3.2. 경로 압축: 지나간 모든 노드를 루트에 직접 연결

#### Find 과정에서 경로 압축

```
Before: 0 → 1 → 2 → 3 → 4 → 5

Find(0) 실행 중:
1. 0에서 시작해서 5(루트)까지 올라감
2. 돌아오면서 모든 노드를 5에 직접 연결!

After:  5
       /|\|\|
      0 1 2 3 4
```

### 3.3. 경로 압축 구현
```kotlin
fun find(x: Int): Int {
    if (parent[x] == x) return x
    parent[x] = find(parent[x])  // 핵심: 재귀 결과를 parent[x]에 저장!
    return parent[x]
}
```

**동작 원리:**
1. 재귀로 루트 찾기
2. **돌아오면서** `parent[x] = 루트`로 직접 연결
3. 다음번 Find는 O(1)!
**성능 개선**:
- **Before:** Find 시간복잡도 O(N)
- **After:** 거의 O(1) (아커만 함수 역함수)

## 4. 추가 핵심 개념들
#### 1. **Union by Rank (랭크 기반 합치기)**
- 트리 높이를 고려해서 합치기
- 낮은 트리를 높은 트리 아래에 붙임
- 트리 깊이 최소화

#### 2. **Union by Size (크기 기반 합치기)**
- 작은 집합을 큰 집합에 붙임
- 더 균형잡힌 트리 구조

#### 3. **시간복잡도 분석**
- 기본: O(N)
- 경로 압축만: O(log N)
- 경로 압축 + Union by Rank: **거의 O(1)** (α(N) - 아커만 역함수)

#### 4. **핵심 응용 분야**
- **사이클 판별**: 간선 추가 시 사이클 생성 확인
- **연결 요소 개수**: 그래프의 컴포넌트 수 세기
- **크루스칼 MST**: 최소 신장 트리 알고리즘
- **동적 연결성**: 실시간으로 연결 관계 관리

## 5. 구현
```kotlin
class DisjointUnionSet(size: Int) {  
    private val parents = IntArray(size) { it }  
    private val rank = IntArray(size) { 0 }  
  
  
    fun find(x: Int): Int {  
        if (parents[x] != x) {  
            parents[x] = find(parents[x])  
        }  
  
        return parents[x]  
    }  
  
    fun union(a: Int, b: Int): Boolean {  
        val rootA = find(a)  
        val rootB = find(b)  
  
        if (rootA == rootB) return false  
  
        when {  
            rank[rootA] < rank[rootB] -> parents[rootA] = rootB  
            rank[rootA] > rank[rootB] -> parents[rootB] = rootA  
            else -> {  
                parents[rootB] = rootA  
                rank[rootA] ++  
            }  
        }  
  
        return true  
    }  
}
```

---
## Rank 기반 합치기 예시
1. Union(0,1)
```text
Before: 0  1  2  3  4

After:  1  2  3  4
        |
        0
```

2. Union(1,2)
```text
Before: 1  2  3  4
        |
        0

After:  2  3  4
        |
        1
        |
        0
```

3. Union(2,3)
```text
Before: 2  3  4
        |
        1
        |
        0

After:  3  4
        |
        2
        |
        1
        |
        0
```

4. Union(3,4)
```text
Before: 3  4
        |
        2
        |
        1
        |
        0

After:  4
        |
        3
        |
        2
        |
        1
        |
        0  ← 완전 일직선!
```

=> Find(0)
```text
0 → 1 → 2 → 3 → 4   (4번 올라가기!)
```

### Union By Rank?
```text
     4
   / | \
  3  2  1
       /
      0
```

## 6. 예시 문제
### 1. 집합 표현
```kotlin
class SetExpression {  
    /**  
     * 기본 문제 1: 집합의 표현  
     * 문제 설명  
     * 초기에 n+1개의 집합 {0}, {1}, {2}, ... , {n}이 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.  
     * 집합을 표현하는 프로그램을 작성하시오.  
     * 입력  
     *  
     * 첫째 줄에 n(1 ≤ n ≤ 1,000,000)과 m(1 ≤ m ≤ 100,000)이 주어진다.  
     * m개의 줄에는 각각의 연산이 주어진다.  
     * 합집합 연산은 0 a b 의 형태로 입력된다. (a와 b를 같은 집합으로 합친다)  
     * 같은 집합에 포함되어 있는지 확인하는 연산은 1 a b 의 형태로 입력된다.  
     *     * 출력  
     * 1로 시작하는 입력에 대해서 a와 b가 같은 집합에 포함되어 있으면 "YES", 아니면 "NO"를 출력한다.  
     * 예제  
     * 입력:  
     * 7 8   
     * 0 1 3    
     * 1 1 7   
     * 0 7 6   
     * 1 7 1    
     * 0 3 7    
     * 1 3 7    
     * 0 4 2    
     * 1 1 2     
     *    
     * 출력:  
     * NO  
     * NO    
     * YES   
     * NO   
     * */  
    
    
    private inner class DisjointUnionSet(size: Int) {  
        val parent = IntArray(size + 1) { it }  
        val rank = IntArray(size + 1) { 0 }  
  
        fun find(x: Int): Int {  
            if (parent[x] != x) {  
                parent[x] = find(parent[x])  
            }  
  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = parent[a]  
            val rootB = parent[b]  
  
            if (rootA == rootB) false  
  
            when {  
                rank[rootA] > rank[rootB] -> parent[rootB] = rootA  
                rank[rootA] < rank[rootB] -> parent[rootA] = rootB  
                else -> {  
                    parent[rootB] = rootA  
                    rank[rootA]++  
                }  
            }  
  
  
            return true  
        }  
    }  
  
  
    @Test  
    fun solution() {  
        val n = 7  
        val m = 8  
        val action = arrayOf(  
            intArrayOf(0, 1, 3),  
            intArrayOf(1, 1, 7),  
            intArrayOf(0, 7, 6),  
            intArrayOf(1, 7, 1),  
            intArrayOf(0, 3, 7),  
            intArrayOf(1, 3, 7),  
            intArrayOf(0, 4, 2),  
            intArrayOf(1, 1, 2),  
        )  
        val expected = arrayOf(  
            "NO",  
            "NO",  
            "YES",  
            "NO",  
        )  
  
        assertArrayEquals(expected, useDisjointUnionSet(n, m, action))  
    }  
  
    private fun useDisjointUnionSet(n: Int, m: Int, action: Array<IntArray>): Array<String> {  
        val unionSet = DisjointUnionSet(n)  
        val result = mutableListOf<String>()  
  
        for(element in action) {  
            val (action, a, b) = element  
  
            when {  
                action == 0 -> {  
                    unionSet.union(a, b)  
                }  
                else -> {  
                    val aFind = unionSet.find(a)  
                    val bFind = unionSet.find(b)  
  
                    result.add(if(aFind == bFind) "YES" else "NO")  
                }  
            }  
        }  
  
  
        return result.toTypedArray()  
    }  
}
```

### 2. 사이클 판별
```kotlin
  
class CycleDetector {  
    /**  
     * 문제: 사이클 탐지  
     * 문제 설명  
     * 무방향 그래프가 주어졌을 때, 그래프에 사이클이 존재하는지 판별하는 함수를 작성하세요.  
     * 제약사항  
     *  
     * 1 ≤ n ≤ 1,000 (정점의 개수)  
     * 0 ≤ edges.length ≤ 10,000 (간선의 개수)  
     * edges[i] = [u, v]는 정점 u와 v 사이에 간선이 있음을 의미  
     *  
     * 입출력 예  
     *  
     * |n |edges| return|  
     * |:---:|:---:|:---:|   
     * |4|[[0,1],[1,2],[2,3]]|false|    
     * |4|[[0,1],[1,2],[2,3],[3,0]]|true|     
     * |3|[[0,1],[1,2],[0,2]]|true|     
     * */  
    
    
    @Test  
    fun solution1() {  
        val n = 4  
        val edges = arrayOf(  
            intArrayOf(0, 1),  
            intArrayOf(1, 2),  
            intArrayOf(2, 3)  
        )  
        val expected = false  
        assertEquals(expected, hasCycle(n, edges))  
    }  
  
    @Test  
    fun solution2() {  
        val n = 4  
        val edges = arrayOf(  
            intArrayOf(0, 1),  
            intArrayOf(1, 2),  
            intArrayOf(2, 3),  
            intArrayOf(3, 0)  
        )  
        val expected = true  
        assertEquals(expected, hasCycle(n, edges))  
    }  
  
    @Test  
    fun solution3() {  
        val n = 3  
        val edges = arrayOf(  
            intArrayOf(0, 1),  
            intArrayOf(1, 2),  
            intArrayOf(0, 2)  
        )  
        val expected = true  
        assertEquals(expected, hasCycle(n, edges))  
    }  
  
  
    private fun hasCycle(n: Int, edges: Array<IntArray>): Boolean {  
        val unionSet = DisjointUnionSet(n)  
  
        for(edge in edges) {  
            val (a, b) = edge  
            if(!unionSet.union(a, b)) return true  
        }  
  
  
        return false  
    }  
  
    private inner class DisjointUnionSet(size: Int) {  
        val parent = IntArray(size + 1) { it }  
        val rank = IntArray(size + 1) { 0 }  
  
        fun find(x: Int): Int {  
            if (x != parent[x]) {  
                parent[x] = find(parent[x])  
            }  
  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = find(a)  
            val rootB = find(b)  
  
            if (rootA == rootB) return false  
            when {  
                rank[rootA] > rank[rootB] -> parent[rootB] = rootA  
                rank[rootA] < rank[rootB] -> parent[rootA] = rootB  
                else -> {  
                    parent[rootB] = rootA  
                    rank[rootA]++  
                }  
            }  
  
            return true  
        }  
    }  
}
```
