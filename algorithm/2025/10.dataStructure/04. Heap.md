## 정의
- 완전 이진 트리 기반 자요 구조
- Heap Property를 만족
- 우선 순위 큐의 내부 구현체

## 힙의 속성
- 최소 힙: 부모 <= 자식 (루트가 최소 값)
  ```text
  배열: [1, 3, 6, 5, 9, 8]
  인덱스: 0 1 2 3 4 5
  트리에서 인덱스:   0(1)
			   /      \
			1(3)      2(6)
			 / \      / 
		 3(5) 4(9)   5(8)
	```
- 최대 힙: 부모 >= 자식 (투르가 최대 값)
  ```text
	배열: [9, 8, 6, 5, 3, 1]
	인덱스: 0 1 2 3 4 5
	트리에서 인덱스:  0(9)
			    /      \ 
			 1(8)      2(6)
			  / \      /
		  3(5) 4(3)  5(1)	  
	```

> 인덱스의 관계
> - 부모: (i - 1) / 2
> - 왼쪽 자식: 2 * i + 1
> - 오른쪽 자식: 2 * i + 2

## 핵심 연산
- Insert: O(log N) - 마지막에 추가 후 위로 heapify
- Extract: O(long N) - 루트 제거 후 아래로 heapify
- Peek: O(1) - 루트 확인

## 구현
```kotlin
  
class MinHeap {  
    private val firstIndex = 0  
    private val heap = mutableListOf<Int>()  
    private fun MutableList<Int>.swap(firstIndex: Int, secondIndex: Int) {  
        val firstValue = this[firstIndex]  
        val secondValue = this[secondIndex]  
  
        this[firstIndex] = secondValue  
        this[secondIndex] = firstValue  
    }  
  
    fun insert(value: Int) {  
        heap.add(value)  
        heapifyUp(heap.lastIndex)  
    }  
  
    fun extractMin(): Int? {  
        if (heap.isEmpty()) return null  
        if (heap.size == 1) return heap.removeLast()  
  
        val first = heap.removeFirst()  
        heap[firstIndex] = heap.removeLast()  
        heapifyDown(firstIndex)  
  
        return first  
    }  
  
    fun peek(): Int? {  
        return heap.firstOrNull()  
    }  
  
    private fun heapifyUp(index: Int) {  
        if (index == 0) return  
  
        val parentsIndex = parent(index)  
        if (heap[index] < heap[parentsIndex]) {  
            heap.swap(index, parentsIndex)  
            heapifyUp(parentsIndex)  
        }  
    }  
  
    private fun heapifyDown(index: Int) {  
        var smallest = index  
        val leftChildIndex = leftChild(index)  
        val rightChildIndex = rightChild(index)  
  
  
        if (leftChildIndex < heap.size && heap[leftChildIndex] < heap[smallest]) {  
            smallest = leftChildIndex  
        }  
  
        if (rightChildIndex < heap.size && heap[rightChildIndex] < heap[smallest]) {  
            smallest = rightChildIndex  
        }  
  
        if (smallest != index) {  
            heap.swap(index, smallest)  
            heapifyDown(smallest)  
        }  
    }  
  
  
    private fun parent(i: Int) = (i - 1) / 2  
    private fun leftChild(i: Int) = 2 * i + 1  
    private fun rightChild(i: Int) = 2 * i + 2  
}  
  /////
class MaxHeap {  
    private val firstIndex = 0  
    private val heap = mutableListOf<Int>()  
    private fun MutableList<Int>.swap(firstIndex: Int, secondIndex: Int) {  
        val firstValue = this[firstIndex]  
        val secondValue = this[secondIndex]  
  
        this[firstIndex] = secondValue  
        this[secondIndex] = firstValue  
    }  
  
    fun insert(value: Int) {  
        heap.add(value)  
        heapifyUp(heap.lastIndex)  
    }  
  
    fun extractMax(): Int? {  
        if (heap.isEmpty()) return null  
        if (heap.size == 1) return heap.removeLast()  
  
        val first = heap.removeFirst()  
        heap[firstIndex] = heap.removeLast()  
        heapifyDown(firstIndex)  
  
        return first  
    }  
  
    fun peek(): Int? {  
        return heap.first()  
    }  
  
    private fun heapifyUp(index: Int) {  
        if (index == 0) return  
  
        val parentsIndex = parent(index)  
        if (heap[index] > heap[parentsIndex]) {  
            heap.swap(index, parentsIndex)  
            heapifyUp(parentsIndex)  
        }  
    }  
  
    private fun heapifyDown(index: Int) {  
        var largest = index  
        val leftChildIndex = leftChild(index)  
        val rightChildIndex = rightChild(index)  
  
        if (leftChildIndex in heap.indices && heap[leftChildIndex] > heap[largest]) {  
            largest = leftChildIndex  
        }  
  
        if (rightChildIndex in heap.indices && heap[rightChildIndex] > heap[largest]) {  
            largest = rightChildIndex  
        }  
  
        if (largest != index) {  
            heap.swap(index, largest)  
            heapifyDown(largest)  
        }  
    }  
  
    private fun parent(i: Int) = (i - 1) / 2  
    private fun leftChild(i: Int) = 2 * i + 1  
    private fun rightChild(i: Int) = 2 * i + 2  
}
```
