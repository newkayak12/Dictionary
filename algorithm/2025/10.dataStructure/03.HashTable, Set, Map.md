## HashTable
### 정의

- **해시 테이블** - 키-값 쌍을 저장하는 자료구조
- **해시 함수** - 키를 배열 인덱스로 변환
- **O(1) 평균 시간** - 삽입, 삭제, 검색
### 활용 분야

- **중복 탐지** - 이미 본 원소인가?
- **빈도 계산** - 각 원소가 몇 번 나왔나?
- **빠른 검색** - 특정 원소가 존재하나?
- **캐싱** - 계산 결과 저장


### 구현

```kotlin
class Marathon {  
    /**  
     * 기본 문제 1: 완주하지 못한 선수  
     * 문제 설명  
     * 수많은 마라톤 선수들이 마라톤에 참여했습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주했습니다.  
     * 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 매개변수로 주어질 때,  
     * 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.  
     *    
     * 제한사항  
     *  
     * 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.  
     * completion의 길이는 participant의 길이보다 1 작습니다.  
     * 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.  
     * 참가자 중에는 동명이인이 있을 수 있습니다.  
     *    
     * 입출력 예  
     * participant: ["leo", "kiki", "eden"]  
     * completion: ["eden", "kiki"]     
     * return: "leo"  
     *    
     * participant: ["marina", "josipa", "nikola", "vinko", "filipa"]      
     * completion: ["josipa", "filipa", "marina", "nikola"] 
     * return: "vinko"    
     *   
     * participant: ["mislav", "stanko", "mislav", "ana"]    
     * completion: ["stanko", "ana", "mislav"]  
     * return: "mislav"
     * */  
  
    @Test  
    fun solution1() {  
        val participant = arrayOf("leo", "kiki", "eden")  
        val completion = arrayOf("eden", "kiki")  
        val expected = "leo"  
  
        assertEquals(expected, hashMap(participant, completion))  
    }  
  
    @Test  
    fun solution2() {  
        val participant = arrayOf("marina", "josipa", "nikola", "vinko", "filipa")  
        val completion = arrayOf("josipa", "filipa", "marina", "nikola")  
        val expected = "vinko"  
  
        assertEquals(expected, hashMap(participant, completion))  
    }  
  
    @Test  
    fun solution3() {  
        val participant = arrayOf("mislav", "stanko", "mislav", "ana")  
        val completion = arrayOf("stanko", "ana", "mislav")  
        val expected = "mislav"  
  
        assertEquals(expected, hashMap(participant, completion))  
    }  
  
  
    private fun hashMap(participant: Array<String>, completion: Array<String>): String {  
        val participantMap: MutableMap<String, Int> = participant  
            .groupBy { it }  
            .mapValues { entry -> entry.value.size }  
            .toMutableMap()  
  
        for (complete in completion) {  
            participantMap.computeIfPresent(complete) { _, value -> value - 1 }  
        }  
  
        return  participantMap.filterValues { it > 0 }.keys.first()  
    }  
}
```

#### 옷 조합 고르기
```kotlin
class Clothes {  
    /**  
     * 기본 문제 2: 의상 (코디 조합)  
     * 문제 설명  
     * 코니는 매일 다른 옷을 조합하여 입으려고 합니다.  
     * 코니가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때, 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.  
     * 제약조건:  
     *    
     * 코니는 하루에 최소 한 개의 의상은 입습니다.  
     * 같은 이름을 가진 의상은 존재하지 않습니다.  
     *     
     * 입출력 예  
     * clothes: [["yellow_hat", "headgear"], ["blue_sunglasses", "eyewear"], ["green_turban", "headgear"]]  
     * return: 5    
     *    
     * clothes: [["crow_mask", "face"], ["blue_sunglasses", "eyewear"], ["smoky_makeup", "face"], ["silver_bracelet", "accessory"]] 
     * return: 11   
     * */  
    
    
    @Test  
    fun solution1() {  
        val clothes = arrayOf(  
            arrayOf("yellow_hat", "headgear"),  
            arrayOf("blue_sunglasses", "eyewear"),  
            arrayOf("green_turban", "headgear"),  
        )  
        val expected = 5  
  
        assertEquals(expected, hash(clothes))  
    }  
  
    @Test  
    fun solution2() {  
        val clothes = arrayOf(  
            arrayOf("crow_mask", "face"),  
            arrayOf("blue_sunglasses", "eyewear"),  
            arrayOf("smoky_makeup", "face"),  
            arrayOf("silver_bracelet", "accessory"),  
        )  
        val expected = 11  
  
        assertEquals(expected, hash(clothes))  
    }  
  
    private fun hash(clothes: Array<Array<String>>): Int {  
        var count = 1  
        val map = clothes.groupBy { it[1] }.mapValues { entry -> entry.value.map { it[0] } }  
        map.forEach { entry -> count *= (entry.value.size + 1) }  
        return count - 1  
    }  
}
```