## 1.정의 
- FIFO가 아닌 우선순위 기반으로 원소를 처리하는 자료 구조
- 가장 높은(또는 낮은) 우선순위 원소가 먼저 처리됨

## 2. 구현 방식
- Heap: 완전 이진 트리
- 최대 힙: 부모 >= 자식
- 최소 힙: 부모 <= 자식

## 3. 구현 예시

### 1. 더 맵게

```kotlin
class Spicier {  
    /**  
     * 더 맵게 (프로그래머스)  
     * 문제 설명  
     * 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다.  
     *    
     *  섞는 규칙:  
     * - 가장 맵지 않은 음식 + (두 번째로 맵지 않은 음식 × 2)   
     *     
     *  제한사항:  
     *   
     * - 스코빌 지수 배열 scoville (2 ≤ length ≤ 1,000,000)    
     * - K (0 ≤ K ≤ 1,000,000,000)  
     * - 모든 음식을 K 이상으로 만들 수 없는 경우 -1 반환  
     *  
     * 입출력 예  
     * scoville: [1, 2, 3, 9, 10, 12]  
     * K: 7    
     * return: 2  
     * */  

    @Test  
    fun solution() {  
        val scoville = listOf(1, 2, 3, 9, 10, 12)  
        val K = 7  
  
        val expected = 2  
        assertEquals(expected, pq(scoville, K))  
    }  
  
    private fun pq(scoville: List<Int>, K: Int): Int {  
        val pq = PriorityQueue<Int>(compareBy { it })  
        var count  = 0  
        for(element in scoville){  
            pq.add(element)  
        }  
  
        while( pq.isNotEmpty() ) {  
            if(pq.peek() >= K) break  
  
            pq.add(pq.poll() + (2 * pq.poll()))  
            count ++  
        }  
  
  
        return if(count == 0) -1 else count  
    }  
}
```

### 2. 디스크 컨트롤러
```kotlin
class DiskController {  
    /**  
     * 디스크 컨트롤러 (프로그래머스)  
     * 문제 설명  
     * 하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다.  
     * 디스크 컨트롤러를 구현하여 각 작업의 요청부터 종료까지의 시간의 평균을 가장 줄이려고 합니다.  
     *  
     *  입력:  
     * jobs[i] = [요청시점, 소요시간]  
     *     
     *   
     *  목표:  
     * 평균 작업 완료시간을 최소화  
     *  
     * 입출력 예  
     * jobs: [[0,3], [1,9], [2,6]]  
     * return: 9    
     * */
     
    @Test  
    fun solution() {  
        val jobs = arrayOf(  
            intArrayOf(0, 3),  
            intArrayOf(1, 9),  
            intArrayOf(2, 6)  
        )  
        val expected = 9  
  
        assertEquals(expected, pq(jobs))  
    }  
  
    private fun pq(jobs: Array<IntArray>): Int {  
        val jobQueue = PriorityQueue<IntArray>(compareBy { it[0] })  
        val availableQueue = PriorityQueue<IntArray>(compareBy { it[1] })  
  
        var currentTime = 0  
        var waitTime = 0  
  
  
        for (element in jobs) {  
            jobQueue.add(element)  
        }  
  
        while(jobQueue.isNotEmpty() || availableQueue.isNotEmpty()) {  
            while(jobQueue.isNotEmpty() && jobQueue.peek()[0] <= currentTime) {  
                availableQueue.add(jobQueue.poll())  
            }  
  
            if( availableQueue.isNotEmpty()) {  
                val (start, duration) = availableQueue.poll()  
                currentTime += duration  
                waitTime += (currentTime - start)  
            }  
            else {  
                currentTime = jobQueue.peek()[0]  
            }  
        }  
  
  
        return waitTime / jobs.size  
    }  
}
```

### 3. 이중 우선 순위 큐
```kotlin
  
class DoublePriorityQueue {  
    /**  
     * 이중우선순위큐 (프로그래머스)  
     * 문제 설명  
     * 이중우선순위큐는 다음 연산을 지원하는 자료구조입니다.  
     *   
     *  명령어:  
     * - I 숫자 - 큐에 주어진 숫자를 삽입  
     * - D 1 - 큐에서 최댓값을 삭제  
     * - D -1 - 큐에서 최솟값을 삭제  
     *  
     * 제한사항:  
     * - 빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시  
     * - 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 반환  
     * - 비어있지 않으면 [최댓값, 최솟값] 반환  
     *  
     * 입출력 예  
     * operations: ["I 16", "I -5643", "D -1", "D 1", "D 1", "I 123", "D -1"]  
     * return: [0, 0]     
     *    
     * 과정:  
     * 1. I 16 → [16]    
     * 2. I -5643 → [-5643, 16]   
     * 3. D -1 → [16] (최솟값 -5643 삭제)  
     * 4. D 1 → [] (최댓값 16 삭제)  
     * 5. D 1 → [] (빈 큐라 무시)  
     * 6. I 123 → [123]   
	 * 7. D -1 → [] (최솟값 123 삭제)  
     * 최종: 빈 큐 → [0, 0] 
     */  
  
    @Test  
    fun solution() {  
        val operations = arrayOf("I 16", "I -5643", "D -1", "D 1", "D 1", "I 123", "D -1")  
        val expected = intArrayOf(0, 0)  
  
        assertArrayEquals(expected, pq(operations))  
    }  
  
    private fun pq(operations: Array<String>): IntArray {  
        val minPq = PriorityQueue<Int>(compareBy { it })  
        val maxPq = PriorityQueue<Int>(compareByDescending { it })  
        val result = IntArray(2)  
  
  
  
        for (element in operations) {  
            val split = element.split(" ")  
            val operation = split[0]  
            val number = split[1].toInt()  
  
  
            when (operation) {  
                "I" -> {  
                    minPq.offer(number)  
                    maxPq.offer(number)  
                };  
                "D" -> {  
  
                    if (number == -1 && minPq.isNotEmpty()) {  
                        maxPq.remove(minPq.poll())  
                    }                    if (number == 1 && maxPq.isNotEmpty()) {  
                        minPq.remove(maxPq.poll())  
                    }                }  
            }  
        }  
  
        if(maxPq.isNotEmpty()) {  
            result[0]  = maxPq.poll()  
        }  
        if(minPq.isNotEmpty()) {  
            result[1]  = minPq.poll()  
        }  
  
        return result  
    }  
}
```

### 4. 야근 지수
```kotlin
class NightWork {  
    /**  
     * 야근 지수 (프로그래머스)  
     * 문제 설명  
     * 회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다.  
     * 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다.  
     * 목표: 남은 n시간 동안 야근 피로도를 최소화하려고 합니다.  
     * 제한사항:  
     *    
     * works 배열의 크기: 1 ≤ length ≤ 20,000  
     * 각 작업량: 1 ≤ works[i] ≤ 50,000   
     * 1 ≤ n ≤ 1,000,000    
     *    
     * 입출력 예  
     * works: [4, 3, 3]  
     * n: 4    
     * return: 12   
     *    
     * 과정:  
     * 1시간: [3, 3, 3] (4에서 1 감소)  
     * 2시간: [2, 3, 3] (3에서 1 감소)  
     * 3시간: [2, 2, 3] (3에서 1 감소)  
     * 4시간: [2, 2, 2] (3에서 1 감소)  
     *    
     * 야근 지수: 2² + 2² + 2² = 12  
     */  
    
    @Test  
    fun solution() {  
        val works = intArrayOf(4, 3, 3)  
        val n = 4  
        val expected = 12  
  
  
        assertEquals(expected, pq(works, n))  
    }  
  
    private fun pq(works: IntArray, n: Int): Int {  
        val pq = PriorityQueue<Int>(compareByDescending { it })  
        for (element in works) {  
            pq.offer(element)  
        }  
  
        for (i in 0 until n) {  
            val number = pq.poll()  
            if(number <= 0) break  
            pq.offer( number - 1)  
        }  
  
  
        var result = 0  
        while (pq.isNotEmpty()) {  
            result += pq.poll().toDouble().pow(2.0).toInt()  
        }  
  
        return result  
    }  
}
```

### 5. K 번째 수 
```kotlin
  
class NumberK {  
    /**  
     * K번째 수 (프로그래머스)  
     * 문제 설명  
     * 배열 array의 i번째 숫자부터 j번째 숫자까지 자르고 정렬했을 때, k번째에 있는 수를 구하려 합니다.  
     * commands 배열: [i, j, k] 형태의 명령들이 여러 개  
     * 입출력 예  
     * array: [1, 5, 2, 6, 3, 7, 4]  
     * commands: [[2, 5, 3], [4, 4, 1], [1, 7, 3]] 
     * return: [5, 6, 3] 
     *    
     * 과정:  
     * 1. [2,5,3]: 2~5번째 → [5,2,6,3] → 정렬 [2,3,5,6] → 3번째 = 5 
     * 2. [4,4,1]: 4번째 → [6] → 정렬 [6] → 1번째 = 6   
     * 3. [1,7,3]: 1~7번째 → [1,5,2,6,3,7,4] → 정렬 [1,2,3,4,5,6,7] → 3번째 = 3     */  
  
    @Test  
    fun solution() {  
        val array = intArrayOf(1, 5, 2, 6, 3, 7, 4)  
        val commands = arrayOf(  
            intArrayOf(2, 5, 3),  
            intArrayOf(4, 4, 1),  
            intArrayOf(1, 7, 3),  
        )  
  
        val expected = intArrayOf(5, 6, 3)  
  
        assertArrayEquals(expected, pq(array, commands))  
    }  
  
    private fun pq(array: IntArray, commands: Array<IntArray>): IntArray {  
        val result = IntArray(commands.size)  
  
        for ((index, command) in commands.withIndex()) {  
            val start = command[0]  
            val end = command[1]  
            val point = command[2]  
            var idx = 0  
            val pq = PriorityQueue<Int>()  
  
  
            for(element in array.slice(start - 1..<end)) {  
                pq.offer(element)  
            }  
  
            while(pq.isNotEmpty()) {  
                idx ++  
                val poll = pq.poll()  
                if(point == idx) {  
                    result[index] = poll  
                    break  
                }  
            }  
        }  
  
        return result  
    }  
}
```

### 6. 카드 정렬
```kotlin
class SortCard {  
    /**  
     * 카드 정렬하기 (백준 1715번)  
     * 문제 설명  
     * 정렬된 두 묶음의 숫자 카드가 있을 때, 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교가 필요하다.  
     * 예를 들어 20장의 카드 묶음과 30장의 카드 묶음을 합치려면 50번의 비교가 필요하다.  
     * 매우 많은 카드 묶음을 차례로 합쳐나가며 하나의 묶음으로 만들려고 한다. 최종적으로 필요한 최소 비교 횟수를 구하는 프로그램을 작성하시오.  
     * 입출력 예  
     * 카드 묶음: [10, 20, 40]  
     * 최적 순서:  
     * 1. 10 + 20 = 30 (비교 30회)  
     * 2. 30 + 40 = 70 (비교 70회)  
     * 총 비교: 30 + 70 = 100회  
     *  
     * vs 다른 순서:  
     * 1. 20 + 40 = 60 (비교 60회)  
     * 2. 10 + 60 = 70 (비교 70회)  
     * 총 비교: 60 + 70 = 130회  
     *  
     * → 첫 번째가 더 효율적!  
     */  
  
    @Test  
    fun solution() {  
        val pileOfCards = intArrayOf(10, 20, 40)  
        val expected = 100  
  
        assertEquals(expected, pq(pileOfCards))  
    }  
  
    private fun pq(pileOfCards: IntArray): Int {  
        val pq = PriorityQueue<Int>(compareBy { it })  
        var result = 0  
  
        for (cards in pileOfCards) {  
            pq.offer(cards)  
        }  
  
        while (pq.isNotEmpty() && pq.size > 1) {  
  
            // p1 + p2 + ((p1 + p2) + p3)  
            val number = pq.poll() + pq.poll()  
            result += number  
            pq.offer(number)  
  
        }  
  
        return result  
    }  
}
```

### 7. Network
```kotlin
class Network {  
    /**  
     * 네트워크 (프로그래머스)  
     * 문제 설명  
     * n개의 컴퓨터가 있습니다. 몇 개의 컴퓨터는 서로 네트워크를 통해 연결되어 있습니다.  
     * 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어 있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 있다고 할 수 있습니다.  
     * 모든 컴퓨터를 연결하는 데 필요한 최소 비용을 구하려고 합니다.  
     * 입출력 예  
     * n: 4  
     * costs: [[0,1,1], [0,2,2], [1,2,5], [1,3,1], [2,3,8]]  
     * return: 4    
     *     
     * 설명:  
     * - [0,1]: 비용 1  
     * - [0,2]: 비용 2   
     * - [1,3]: 비용 1    
     * 총 비용: 1 + 2 + 1 = 4로 모든 컴퓨터 연결  
     *  
     */  
  
    @Test  
    fun solution() {  
        val n = 4  
        val costs = arrayOf(  
            intArrayOf(0, 1, 1),  
            intArrayOf(0, 2, 2),  
            intArrayOf(1, 2, 5),  
            intArrayOf(1, 3, 1),  
            intArrayOf(2, 3, 8)  
        )  
  
        val expected = 4  
  
        assertEquals(expected, pq(n, costs))  
    }  
  
    private fun pq(n: Int, costs: Array<IntArray>): Int {  
        val pq = PriorityQueue<IntArray>(compareBy { it[2] })  
        for (cost in costs) {  
            pq.offer(cost)  
        }  
  
        var totalCost = 0  
        var edgeCount = 0  
  
        val disjointUnion = DisjointSetUnion(n)  
        while (pq.isNotEmpty() && edgeCount < n - 1) {  
            val (from, to, cost) = pq.poll()  
  
            if(disjointUnion.union(from, to)) {  
                totalCost += cost  
                edgeCount ++  
            }  
        }  
  
        return totalCost  
    }  
  
    inner class DisjointSetUnion(size: Int) {  
        private val parent = IntArray(size + 1) { it }  
        private val rank = IntArray(size + 1)  
  
        fun find(x: Int): Int {  
            if (x != parent[x]) {  
                parent[x] = find(parent[x])  
            }  
  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = find(a)  
            val rootB = find(b)  
  
            val rankA = rank[rootA]  
            val rankB = rank[rootB]  
  
            if (rootA == rootB) return false  
  
            if (rankA < rankB) {  
                parent[rootA] = rootB  
            } else if (rankA > rankB) {  
                parent[rootB] = rootA  
            } else {  
                parent[rootB] = rootA  
                rank[rootA]++  
            }  
  
            return true  
        }  
    }  
}
```