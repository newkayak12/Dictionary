# Stack
## 1. 정의 
- LIFO(Last-In, First-Out) 구조의 자료구조
- 가장 최근에 삽입된 데이터가 가장 먼저 제거된다.

## 2. 구현 방식
- List + Index 또는 LinkedList로 구현
- Kt라면 ArrayDequeue로 사용

## 3. 활용 사례
1. 괄호의 짝 검사
2. 후위 표기식 계산
3. DFS 재귀 대체
4. 되돌리기 기능
5. Histogram, Stack-based 정답 누적


### 1. 괄호의 짝 검사
```kotlin
class Bracket {  
  
    /**  
     * 🧪 10-1-2. 스택 – 개념 문제  
     *  
     * 💡 문제: 올바른 괄호  
     *  
     * 설명  
     * 문자열이 주어졌을 때, 모든 괄호가 올바르게 열고 닫혀 있는지 판단하시오.  
     *  •  입력: "(()())"  
     *  •  출력: "YES"  
     *  •  입력: ")(()"  
     *  •  출력: "NO"  
     *   
     * ⸻  
     *  
     * ✅ 조건  
     *  •  괄호 종류는 ( 와 ) 만 있음  
     *  •  길이 최대 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. 후위 표기식 계산
```kotlin
class Postfix {  
    /**  
     * 📘 실습 문제 – 후위 표기식 계산 (기초 버전)  
     *     
     * 🧾 문제 설명  
     *  
     * 중위 표기식(예: 2 + 3)이 아닌 후위 표기식(Postfix, 예: 2 3 +)이 주어집니다.  
     * 이를 스택을 이용해서 계산하세요.  
     *     
     * 📥 입력 형식  
     *  •  문자열로 된 후위 표기식이 한 줄에 주어집니다.  
     *  •  피연산자는 한 자리 숫자(0~9)로만 주어지며, 공백으로 구분되어 있습니다.  
     *  •  연산자는 +, -, *, / 중 하나입니다.  
     *    
     * 예: "2 3 + 4 *"  
     * → (2 + 3) * 4 = 20   
     *    
     * 📤 출력 형식  
     *  •  계산 결과를 출력하세요. (정수만)  
     *    
     * ⸻  
     *  
     * ✅ 예시 입출력  
     *  
     * |입력 | 출력|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```
