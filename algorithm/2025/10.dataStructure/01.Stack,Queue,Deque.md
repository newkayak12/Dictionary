# Stack
## 1. 정의 
- LIFO(Last-In, First-Out) 구조의 자료구조
- 가장 최근에 삽입된 데이터가 가장 먼저 제거된다.

## 2. 구현 방식
- List + Index 또는 LinkedList로 구현
- Kt라면 ArrayDequeue로 사용

## 3. 활용 사례
1. 괄호의 짝 검사
2. 후위 표기식 계산
3. DFS 재귀 대체
4. 되돌리기 기능
5. Histogram, Stack-based 정답 누적


### 1. 괄호의 짝 검사
```kotlin
class Bracket {  
  
    /**  
     * 🧪 10-1-2. 스택 – 개념 문제  
     *  
     * 💡 문제: 올바른 괄호  
     *  
     * 설명  
     * 문자열이 주어졌을 때, 모든 괄호가 올바르게 열고 닫혀 있는지 판단하시오.  
     *  •  입력: "(()())"  
     *  •  출력: "YES"  
     *  •  입력: ")(()"  
     *  •  출력: "NO"  
     *   
     * ⸻  
     *  
     * ✅ 조건  
     *  •  괄호 종류는 ( 와 ) 만 있음  
     *  •  길이 최대 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. 후위 표기식 계산
```kotlin
class Postfix {  
    /**  
     * 📘 실습 문제 – 후위 표기식 계산 (기초 버전)  
     *     
     * 🧾 문제 설명  
     *  
     * 중위 표기식(예: 2 + 3)이 아닌 후위 표기식(Postfix, 예: 2 3 +)이 주어집니다.  
     * 이를 스택을 이용해서 계산하세요.  
     *     
     * 📥 입력 형식  
     *  •  문자열로 된 후위 표기식이 한 줄에 주어집니다.  
     *  •  피연산자는 한 자리 숫자(0~9)로만 주어지며, 공백으로 구분되어 있습니다.  
     *  •  연산자는 +, -, *, / 중 하나입니다.  
     *    
     * 예: "2 3 + 4 *"  
     * → (2 + 3) * 4 = 20   
     *    
     * 📤 출력 형식  
     *  •  계산 결과를 출력하세요. (정수만)  
     *    
     * ⸻  
     *  
     * ✅ 예시 입출력  
     *  
     * |입력 | 출력|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```

### Histogram
```kotlin
class Histogram {  
    /**  
     * 📘 실습 문제 – 가장 큰 직사각형 (Histogram)   
	 *    
	 * 💡 문제 설명  
     *  
     * 세로선의 높이가 주어졌을 때, 연속된 막대들로 만들 수 있는 가장 큰 직사각형의 넓이를 구하세요.  
     * (단, 모든 막대의 너비는 1입니다.)  
     *    
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  정수 배열 형태로 n개의 막대 높이가 주어짐  
     *  
     * 예: [2, 1, 5, 6, 2, 3]  
     *    
     * ⸻  
     *  
     * 📤 출력 형식  
     *  •  만들 수 있는 최대 직사각형 넓이를 출력  
     *  
     * ⸻  
     *  
     * 🧮 예시  
     *  
     * |입력|출력|  
     * |:---:|:---:|    
     * |[2, 1, 5, 6, 2, 3]|10| 
     * |[2, 4]|4|    
     * |[6, 2, 5, 4, 5, 1, 6]|12| 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = listOf(2, 1, 5, 6, 2, 3)  
        val expected = 10  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf(2, 4)  
        val expected = 4  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf(6, 2, 5, 4, 5, 1, 6)  
        val expected = 12  
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<Int>): Int {  
        val extendedInput = List(input.size + 1) { input.getOrElse(it) { 0 } }  
        val stack = ArrayDeque<Int>()  
        var maxArea = 0  
  
  
        for (i in extendedInput.indices) {  
  
            while (stack.isNotEmpty() && extendedInput[i] < extendedInput[stack.last()]) {  
                val topIndex = stack.removeLast()  
                val height = extendedInput[topIndex]  
                val width = if (stack.isEmpty()) i else i - stack.last() - 1  
                maxArea = max(maxArea, width * height)  
            }  
  
            stack.addLast(i)  
        }  
  
        return maxArea  
    }  
}
```


# Queue
## 1. 정의 
1. FIFO(First-In, First-Out) - 선입 선출
2. 먼저 들어온 데이터가 먼저 나간다.
## 2. 구현 방식
1. Kotlin에서는 ArrayDequeue를 일반적으로 선택한다.
2. Java에서는 LinkedList\<T\>()를 사용한다.

## 3. 활용 사례
1. BFS
2. 프린터 출력 순서
3. RoundRobin
4. 캐시 또는 요청 큐

### 1. 카드 뽑기
```kotlin
class DrawCard {  
    /**  
     * 📘 실습 문제 – 카드 뽑기 시뮬레이션 (BOJ 2161 변형)  
     *    
     * ⸻  
     *  
     * 🧾 문제 설명  
     *  
     * 1부터 N까지 번호가 적힌 카드가 1번이 제일 위, N번이 제일 아래로 놓여 있습니다.  
     * 다음 과정을 반복합니다:  
     *  1. 제일 위에 있는 카드를 버린다  
     *  2. 그 다음 위에 있는 카드를 맨 아래로 옮긴다  
     *  
     * 이 과정을 반복해 카드가 한 장 남을 때까지 진행했을 때,  
     * 버린 카드들을 순서대로 출력하고, 마지막 남은 카드도 출력하세요.  
     *   
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  첫째 줄에 카드의 개수 N이 주어집니다. (1 ≤ N ≤ 1000)  
     *   
     * 예:  
     * 7    
     *    
     * 📤 출력 형식  
     *  •  첫째 줄: 버린 카드 번호를 순서대로 출력 (공백 구분)  
     *  •  둘째 줄: 마지막에 남은 카드 번호 출력  
     *  
     * 예:  
     * 1 3 5 7 4 2 
     * 6   
     * */  
  
    @Test  
    fun solution() {  
        val size = 7  
        val expectedDiscarded = listOf(1,3,5,7,4,2)  
        val expectedResult = 6  
  
        val (resultDiscarded, resultNumber) = useQueue(size)  
  
        assertEquals(expectedDiscarded,resultDiscarded)  
        assertEquals(expectedResult, resultNumber)  
    }  
  
    private fun useQueue(size: Int): Pair<List<Int>, Int> {  
        val pile = ArrayDeque<Int>()  
        for( i in 1 .. size) {  
            pile.addLast(i)  
        }  
        var index = 0;  
        val discarded = mutableListOf<Int>()  
  
  
        while(pile.size != 1) {  
            val element = pile.removeFirst()  
            if( index%2==0) {  
                discarded.add(element)  
            }  
            else {  
                pile.addLast(element)  
            }  
  
            index ++  
        }  
  
        val pick = pile.removeFirst()  
  
        println(discarded)  
        println(pick)  
  
  
        return discarded to pick  
    }  
}
```


# Deque