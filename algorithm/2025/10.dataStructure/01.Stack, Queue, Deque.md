# Stack
## 1. ì •ì˜ 
- LIFO(Last-In, First-Out) êµ¬ì¡°ì˜ ìë£Œêµ¬ì¡°
- ê°€ì¥ ìµœê·¼ì— ì‚½ì…ëœ ë°ì´í„°ê°€ ê°€ì¥ ë¨¼ì € ì œê±°ëœë‹¤.

## 2. êµ¬í˜„ ë°©ì‹
- List + Index ë˜ëŠ” LinkedListë¡œ êµ¬í˜„
- Ktë¼ë©´ ArrayDequeueë¡œ ì‚¬ìš©

## 3. í™œìš© ì‚¬ë¡€
1. ê´„í˜¸ì˜ ì§ ê²€ì‚¬
2. í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚°
3. DFS ì¬ê·€ ëŒ€ì²´
4. ë˜ëŒë¦¬ê¸° ê¸°ëŠ¥
5. Histogram, Stack-based ì •ë‹µ ëˆ„ì 


### 1. ê´„í˜¸ì˜ ì§ ê²€ì‚¬
```kotlin
class Bracket {  
  
    /**  
     * ğŸ§ª 10-1-2. ìŠ¤íƒ â€“ ê°œë… ë¬¸ì œ  
     *  
     * ğŸ’¡ ë¬¸ì œ: ì˜¬ë°”ë¥¸ ê´„í˜¸  
     *  
     * ì„¤ëª…  
     * ë¬¸ìì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ê´„í˜¸ê°€ ì˜¬ë°”ë¥´ê²Œ ì—´ê³  ë‹«í˜€ ìˆëŠ”ì§€ íŒë‹¨í•˜ì‹œì˜¤.  
     *  â€¢  ì…ë ¥: "(()())"  
     *  â€¢  ì¶œë ¥: "YES"  
     *  â€¢  ì…ë ¥: ")(()"  
     *  â€¢  ì¶œë ¥: "NO"  
     *   
     * â¸»  
     *  
     * âœ… ì¡°ê±´  
     *  â€¢  ê´„í˜¸ ì¢…ë¥˜ëŠ” ( ì™€ ) ë§Œ ìˆìŒ  
     *  â€¢  ê¸¸ì´ ìµœëŒ€ 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚°
```kotlin
class Postfix {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚° (ê¸°ì´ˆ ë²„ì „)  
     *     
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì¤‘ìœ„ í‘œê¸°ì‹(ì˜ˆ: 2 + 3)ì´ ì•„ë‹Œ í›„ìœ„ í‘œê¸°ì‹(Postfix, ì˜ˆ: 2 3 +)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ì´ë¥¼ ìŠ¤íƒì„ ì´ìš©í•´ì„œ ê³„ì‚°í•˜ì„¸ìš”.  
     *     
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ë¬¸ìì—´ë¡œ ëœ í›„ìœ„ í‘œê¸°ì‹ì´ í•œ ì¤„ì— ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  í”¼ì—°ì‚°ìëŠ” í•œ ìë¦¬ ìˆ«ì(0~9)ë¡œë§Œ ì£¼ì–´ì§€ë©°, ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
     *  â€¢  ì—°ì‚°ìëŠ” +, -, *, / ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.  
     *    
     * ì˜ˆ: "2 3 + 4 *"  
     * â†’ (2 + 3) * 4 = 20   
     *    
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ê³„ì‚° ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ì„¸ìš”. (ì •ìˆ˜ë§Œ)  
     *    
     * â¸»  
     *  
     * âœ… ì˜ˆì‹œ ì…ì¶œë ¥  
     *  
     * |ì…ë ¥ | ì¶œë ¥|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```

### Histogram
```kotlin
class Histogram {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ ê°€ì¥ í° ì§ì‚¬ê°í˜• (Histogram)   
	 *    
	 * ğŸ’¡ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì„¸ë¡œì„ ì˜ ë†’ì´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì—°ì†ëœ ë§‰ëŒ€ë“¤ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì§ì‚¬ê°í˜•ì˜ ë„“ì´ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * (ë‹¨, ëª¨ë“  ë§‰ëŒ€ì˜ ë„ˆë¹„ëŠ” 1ì…ë‹ˆë‹¤.)  
     *    
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ í˜•íƒœë¡œ nê°œì˜ ë§‰ëŒ€ ë†’ì´ê°€ ì£¼ì–´ì§  
     *  
     * ì˜ˆ: [2, 1, 5, 6, 2, 3]  
     *    
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì§ì‚¬ê°í˜• ë„“ì´ë¥¼ ì¶œë ¥  
     *  
     * â¸»  
     *  
     * ğŸ§® ì˜ˆì‹œ  
     *  
     * |ì…ë ¥|ì¶œë ¥|  
     * |:---:|:---:|    
     * |[2, 1, 5, 6, 2, 3]|10| 
     * |[2, 4]|4|    
     * |[6, 2, 5, 4, 5, 1, 6]|12| 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = listOf(2, 1, 5, 6, 2, 3)  
        val expected = 10  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf(2, 4)  
        val expected = 4  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf(6, 2, 5, 4, 5, 1, 6)  
        val expected = 12  
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<Int>): Int {  
        val extendedInput = List(input.size + 1) { input.getOrElse(it) { 0 } }  
        val stack = ArrayDeque<Int>()  
        var maxArea = 0  
  
  
        for (i in extendedInput.indices) {  
  
            while (stack.isNotEmpty() && extendedInput[i] < extendedInput[stack.last()]) {  
                val topIndex = stack.removeLast()  
                val height = extendedInput[topIndex]  
                val width = if (stack.isEmpty()) i else i - stack.last() - 1  
                maxArea = max(maxArea, width * height)  
            }  
  
            stack.addLast(i)  
        }  
  
        return maxArea  
    }  
}
```


# Queue
## 1. ì •ì˜ 
1. FIFO(First-In, First-Out) - ì„ ì… ì„ ì¶œ
2. ë¨¼ì € ë“¤ì–´ì˜¨ ë°ì´í„°ê°€ ë¨¼ì € ë‚˜ê°„ë‹¤.
## 2. êµ¬í˜„ ë°©ì‹
1. Kotlinì—ì„œëŠ” ArrayDequeueë¥¼ ì¼ë°˜ì ìœ¼ë¡œ ì„ íƒí•œë‹¤.
2. Javaì—ì„œëŠ” LinkedList\<T\>()ë¥¼ ì‚¬ìš©í•œë‹¤.

## 3. í™œìš© ì‚¬ë¡€
1. BFS
2. í”„ë¦°í„° ì¶œë ¥ ìˆœì„œ
3. RoundRobin
4. ìºì‹œ ë˜ëŠ” ìš”ì²­ í

### 1. ì¹´ë“œ ë½‘ê¸°
```kotlin
class DrawCard {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ ì¹´ë“œ ë½‘ê¸° ì‹œë®¬ë ˆì´ì…˜ (BOJ 2161 ë³€í˜•)  
     *    
     * â¸»  
     *  
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * 1ë¶€í„° Nê¹Œì§€ ë²ˆí˜¸ê°€ ì íŒ ì¹´ë“œê°€ 1ë²ˆì´ ì œì¼ ìœ„, Në²ˆì´ ì œì¼ ì•„ë˜ë¡œ ë†“ì—¬ ìˆìŠµë‹ˆë‹¤.  
     * ë‹¤ìŒ ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤:  
     *  1. ì œì¼ ìœ„ì— ìˆëŠ” ì¹´ë“œë¥¼ ë²„ë¦°ë‹¤  
     *  2. ê·¸ ë‹¤ìŒ ìœ„ì— ìˆëŠ” ì¹´ë“œë¥¼ ë§¨ ì•„ë˜ë¡œ ì˜®ê¸´ë‹¤  
     *  
     * ì´ ê³¼ì •ì„ ë°˜ë³µí•´ ì¹´ë“œê°€ í•œ ì¥ ë‚¨ì„ ë•Œê¹Œì§€ ì§„í–‰í–ˆì„ ë•Œ,  
     * ë²„ë¦° ì¹´ë“œë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ê³ , ë§ˆì§€ë§‰ ë‚¨ì€ ì¹´ë“œë„ ì¶œë ¥í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„ì— ì¹´ë“œì˜ ê°œìˆ˜ Nì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. (1 â‰¤ N â‰¤ 1000)  
     *   
     * ì˜ˆ:  
     * 7    
     *    
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„: ë²„ë¦° ì¹´ë“œ ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ ì¶œë ¥ (ê³µë°± êµ¬ë¶„)  
     *  â€¢  ë‘˜ì§¸ ì¤„: ë§ˆì§€ë§‰ì— ë‚¨ì€ ì¹´ë“œ ë²ˆí˜¸ ì¶œë ¥  
     *  
     * ì˜ˆ:  
     * 1 3 5 7 4 2 
     * 6   
     * */  
  
    @Test  
    fun solution() {  
        val size = 7  
        val expectedDiscarded = listOf(1,3,5,7,4,2)  
        val expectedResult = 6  
  
        val (resultDiscarded, resultNumber) = useQueue(size)  
  
        assertEquals(expectedDiscarded,resultDiscarded)  
        assertEquals(expectedResult, resultNumber)  
    }  
  
    private fun useQueue(size: Int): Pair<List<Int>, Int> {  
        val pile = ArrayDeque<Int>()  
        for( i in 1 .. size) {  
            pile.addLast(i)  
        }  
        var index = 0;  
        val discarded = mutableListOf<Int>()  
  
  
        while(pile.size != 1) {  
            val element = pile.removeFirst()  
            if( index%2==0) {  
                discarded.add(element)  
            }  
            else {  
                pile.addLast(element)  
            }  
  
            index ++  
        }  
  
        val pick = pile.removeFirst()  
  
        println(discarded)  
        println(pick)  
  
  
        return discarded to pick  
    }  
}
```


# Deque
## 1. ì •ì˜ 
- Double-Ended Queue: ì–‘ìª½ì—ì„œ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥í•œ ì–‘ë°©í–¥ í
## 2. êµ¬í˜„ ë°©ì‹
 - KTì—ì„œ ArrayDeque
 - Javaì—ì„œ LinkedList
## 3. í™œìš© ì‚¬ë¡€
1. ìŠ¬ë¼ì´ë”© ë¬¸ì œ
2. AC ë¬¸ì œ
3. 0-1 BFS

#### 1. ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
```kotlin
class BasicSlidingWindow {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ìµœì†Ÿê°’ (ì •ì„, ì¼ë°˜ì  ìŠ¤íƒ€ì¼)  
     *     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ numsì™€ ì •ìˆ˜ kê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ê¸¸ì´ kì˜ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ì”© ì´ë™ì‹œí‚¤ë©´ì„œ,  
     * ê° ìœˆë„ìš°ì—ì„œ ìµœì†Ÿê°’ì„ êµ¬í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•˜ì„¸ìš”.  
     *     
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ nums: ê¸¸ì´ N (1 â‰¤ N â‰¤ 10â¶)  
     *  â€¢  ìœˆë„ìš° í¬ê¸° k: 1 â‰¤ k â‰¤ N 
     *    
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ê° ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ìµœì†Ÿê°’ì„ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì œ 1   
     *    
     * ì…ë ¥:  
     * nums = [1, 3, -1, -3, 5, 3, 6, 7]   
     * k = 3    
     * ì¶œë ¥:  
     * [-1, -3, -3, -3, 3, 3]    
     * */  
  
    @Test  
    fun solution(){  
        val numbs = intArrayOf(1, 3, -1, -3, 5, 3, 6, 7)  
        val windowSize = 3  
        val expected = intArrayOf(-1, -3, -3, -3, 3, 3)  
  
        assertArrayEquals(expected, useSlidingWindow(numbs, windowSize))  
    }  
  
  
    private fun useSlidingWindow(number: IntArray, windowSize: Int): IntArray {  
        val resultList = mutableListOf<Int>()  
        val deque = ArrayDeque<Int>()  
  
        for(i in number.indices) {  
            while(deque.isNotEmpty() && deque.first() <= i - windowSize) {  
                deque.removeFirst()  
            }  
            while(deque.isNotEmpty() && number[deque.last()] >= number[i]){  
                deque.removeLast()  
            }  
  
            deque.addLast(i)  
            if(i - windowSize + 1 >= 0){  
                resultList.add(number[deque.first()])  
            }  
  
        }  
  
  
  
        return resultList.toIntArray()  
    }  
}
```

#### 2. AC(ArrayControll)
```kotlin
class AC {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: AC (BOJ 5430 ë³€í˜•)  
     *     
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     * R(ë’¤ì§‘ê¸°)ê³¼ D(ë²„ë¦¬ê¸°)ë¡œ ì´ë£¨ì–´ì§„ ëª…ë ¹ì–´ ë¬¸ìì—´ê³¼, ì •ìˆ˜ ë°°ì—´ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ëª…ë ¹ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ìˆ˜í–‰í•˜ë©´ì„œ ë°°ì—´ì— ë³€í™”ë¥¼ ì ìš©í•˜ì„¸ìš”.  
     * ë‹¨, ë°°ì—´ì´ ë¹„ì–´ìˆì„ ë•Œ D ëª…ë ¹ì–´ê°€ ë“¤ì–´ì˜¤ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.  
     *     
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ T (1 â‰¤ T â‰¤ 100)     
     *  â€¢  ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤:  
     *  â€¢  ëª…ë ¹ì–´ ë¬¸ìì—´ p (ê¸¸ì´ 1 â‰¤ p â‰¤ 100,000)    
     *  â€¢  ì •ìˆ˜ n (0 â‰¤ n â‰¤ 100,000)     
     *  â€¢  ë°°ì—´: [xâ‚,xâ‚‚,â€¦,xâ‚™] í˜•ì‹ì˜ ë¬¸ìì—´  
     *  
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ëª…ë ¹ì–´ ìˆ˜í–‰ ê²°ê³¼ ë°°ì—´ì„ ë¬¸ìì—´ë¡œ ì¶œë ¥  
     *  â€¢  ì—ëŸ¬ ë°œìƒ ì‹œ "error" ì¶œë ¥  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì œ  
     *  
     * ì…ë ¥:  
     * 4    
     * --- ì˜ˆì œ 1    
     * ëª…ë ¹ì–´: RDD  
     * ë°°ì—´ ê¸¸ì´: 4  
     * ë°°ì—´: [1,2,3,4]  
     *     
     * --- ì˜ˆì œ 2    
     * ëª…ë ¹ì–´: DD  
     * ë°°ì—´ ê¸¸ì´: 1  
     * ë°°ì—´: [42]  
     *     
     * --- ì˜ˆì œ 3   
	 * ëª…ë ¹ì–´: RRD  
     * ë°°ì—´ ê¸¸ì´: 6  
     * ë°°ì—´: [1,1,2,3,5,8]  
     *     
     * --- ì˜ˆì œ 4   
     * ëª…ë ¹ì–´: D  
     * ë°°ì—´ ê¸¸ì´: 0  
     * ë°°ì—´: []  
     *     
     * ì¶œë ¥:  
     * --- ì¶œë ¥ 1     
     * [2,1]     
     *     
     * --- ì¶œë ¥ 2    
     * error    
     *    
     * --- ì¶œë ¥ 3    
     * [1,2,3,5,8]   
     *    
     * --- ì¶œë ¥ 4    
     * error   
     * */  
 
    @Test  
    fun solution1() {  
        val command = "RDD"  
        val arraySize = 4  
        val array = intArrayOf(1,2,3,4)  
        val expected = intArrayOf(2,1).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution2() {  
        val command = "DD"  
        val arraySize = 1  
        val array = intArrayOf(42)  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution3() {  
        val command = "D"  
        val arraySize = 6  
        val array = intArrayOf(1,1,2,3,5,8)  
        val expected = intArrayOf(1,2,3,5,8).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution4() {  
        val command = "RDD"  
        val arraySize = 0  
        val array = intArrayOf()  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    private fun useDeque(command: String, array: IntArray): String {  
        val deque = ArrayDeque<Int>()  
        val result = mutableListOf<Int>()  
        var leftToRight = true  
        val reverse = 'R'  
        val delete = 'D'  
  
        for(element in array) {  
            deque.addLast(element)  
        }  
  
        for(element in command) {  
            when(element) {  
                reverse -> leftToRight = !leftToRight  
                delete -> {  
                    if(deque.isEmpty()) return "error"  
  
                    if(leftToRight){  
                        deque.removeFirst()  
                    } 
                    else {  
                        deque.removeLast()  
                    }
				}  
            }  
        }  
  
        while(deque.isNotEmpty()) {  
            if(leftToRight) {  
                result.add(deque.removeFirst())  
            }  
            else {  
                result.add(deque.removeLast())  
            }  
        }  
  
  
        return result.toIntArray().contentToString()  
    }  
}
```

#### 3. 0-1 BFS
```kotlin
class `0-1BFS` {  
    /**  
     * 0-1 BFSëŠ” ê°„ì„  ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•  ë•Œ ì‚¬ìš©í•˜ëŠ”  
     * íŠ¹ìˆ˜í•œ BFS ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.  
     *     
     * ì¼ë°˜ì ì¸ BFSì™€ Dijkstra ì•Œê³ ë¦¬ì¦˜ì˜ ì¤‘ê°„ í˜•íƒœì´ë©°,  
     * ì‹œê°„ ë³µì¡ë„ëŠ” Dijkstraë³´ë‹¤ ë¹ ë¥´ê³  BFSë§Œí¼ ê°„ë‹¨í•œ êµ¬ì¡°ë¥¼ ê°€ì§‘ë‹ˆë‹¤.  
     *     
     * âœ… ê°œë… ì •ë¦¬  
     *  
     * |í•­ëª©| ì„¤ëª…|  
     * |:---:|:---:|   
     * |ëª©ì | ê°„ì„  ê°€ì¤‘ì¹˜ê°€ 0 ë˜ëŠ” 1ì¸ ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°|  
     * |í–‰ì‹¬ ì•„ì´ë””ì–´|ê°„ì„  ê°€ì¤‘ì¹˜ê°€ 0ì´ë©´ ì•, 1ì´ë©´ ë’¤ì— ë„£ëŠ” ë°©ì‹|  
     * |ìë£Œêµ¬ì¡°|Deque(Double-ended queue)|  
     * |ì‹œê°„ ë³µì¡ë„|O(V+E)|  
     *     
     * ## ì¼ë°˜ BFSëŠ” ì™œ ì•ˆë˜ëŠ”ê°€?  
     * - BFSëŠ” ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ë™ì¼ì¼ ë•Œë§Œ ìœ íš¨í•˜ë‹¤.  
     * - ê°€ì¤‘ì¹˜ 0 ë˜ëŠ” 1ì¼ ê²½ìš°, ì¼ë°˜ BFSëŠ” 0 ê°€ì¤‘ì¹˜ ê°„ì„ ì„ ë” ë¹¨ë¦¬ ë°˜ì˜í•˜ì§€ ëª»í•¨  
     * - DijkstraëŠ” ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•´ì„œ ì •í™•í•˜ì§€ë§Œ, ë³µì¡í•˜ê³  ëŠë¦¬ë‹¤.  
     * - 0-1 BFSëŠ” ë‘ ë‹¨ì ì„ ë³´ì™„  
     *  
     *    
     * ## Pseudo     
     *     
     * ```text    
     * ì‹œì‘ ì •ì ì—ì„œ Deque ì´ˆê¸°í™”  
     * ë°©ë¬¸ ë°°ì—´ì„ ëª¨ë‘ ì´ˆê¸°í™”  
     *  
     * íê°€ ë¹Œ ë•Œê¹Œì§€:  
     *      í˜„ì¬ ë…¸ë“œë¥¼ êº¼ë‚¸ë‹¤.  
     *      ì¸ì ‘í•œ ë…¸ë“œë¥¼ ìˆœíšŒ  
     *          ê°€ì¤‘ì¹˜ê°€ 0ì´ë©´ -> Dequeì˜ ì•ì— ì‚½ì…  
     *          ê°€ì¤‘ì¹˜ê°€ 1ì´ë©´ -> Dequeì˜ ë’¤ì— ì‚½ì…  
     *  
     *     
     * ```   
     * ### 1ê³¼ 0ì— ëŒ€í•œ ì²˜ë¦¬  
     * - ë” ë¹ ë¥´ê²Œ ë„ì°©í•  ìˆ˜ ìˆëŠ” ê²½ë¡œë¶€í„° íƒìƒ‰í•œë‹¤.  
     * - ê°€ì¤‘ì¹˜ë¡œ ìš°ì„ ìˆœìœ„ë¥¼ ë‚˜ëˆˆë‹¤.  
     *     
     *     
     * ## ì˜ˆì‹œ ë¬¸ì œ  
     *  
     * | ë¬¸ì œ ì´ë¦„ | ì„¤ëª… |     
     * |:----:|:----:|    
     * |ë²½ ë¶€ìˆ˜ê³  ì´ë™| ë²½ì„ 1ê°œê¹Œì§€ ë¶€ìˆ  ìˆ˜ ìˆëŠ” ìƒíƒœ í™•ì¥í˜•|  
     * |íŠ¹ì • ìœ„ì¹˜ê¹Œì§€ ìµœì†Œ ì‹œê°„| ìˆœê°„ì´ë™(0ì´ˆ) + ê±·ê¸°(1ì´ˆ) ë“±ì˜ ì¡°í•©|  
     * |ê°€ì¤‘ì¹˜ 0/1 ë„ë¡œë¡œ ëœ ê·¸ë˜í”„ì˜ ìµœì†Œ ê²½ë¡œ ì°¾ê¸°| ë„ë¡œì˜ ì¢…ë¥˜ì— ë”°ë¼ ìš°ì„ ìˆœìœ„ ë‹¤ë¥´ê²Œ ì ìš©|  
     */  
    data class State(val x: Int, val y: Int, val wallBreakCount: Int, val dist: Int)  
  
    @Nested  
    inner class BreakWall {  
        /**  
         * ğŸ§± ë¬¸ì œ: ë²½ ë¶€ìˆ˜ê³  íƒˆì¶œí•˜ê¸° (0-1 BFS ë³€í˜•)  
         *        
         * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
         *  
         * ë‹¹ì‹ ì€ N x M í¬ê¸°ì˜ ë¯¸ë¡œì— ê°‡í˜”ìŠµë‹ˆë‹¤.  
         * ë‹¹ì‹ ì€ (1,1) ìœ„ì¹˜ì—ì„œ ì¶œë°œí•´ (N,M) ìœ„ì¹˜ë¡œ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
         * ì´ ë¯¸ë¡œì—ëŠ” **ë¹ˆ ì¹¸(0)**ê³¼ **ë²½(1)**ì´ ì¡´ì¬í•˜ë©°, ë‹¹ì‹ ì€ ë²½ì„ ì—¬ëŸ¬ ê°œ ë¶€ìˆ  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
         * í•˜ì§€ë§Œ, ë¶€ìˆ  ìˆ˜ ìˆëŠ” ë²½ì˜ ìµœëŒ€ ê°œìˆ˜ëŠ” Kê°œì…ë‹ˆë‹¤.  
         *       
         * ì´ë™í•  ìˆ˜ ìˆëŠ” ë°©í–¥ì€ ìƒí•˜ì¢Œìš°ì´ë©°, í•œ ì¹¸ì„ ì´ë™í•  ë•ŒëŠ” 1ì´ˆê°€ ê±¸ë¦½ë‹ˆë‹¤.  
         * ê°€ëŠ¥í•œ ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì— íƒˆì¶œí•  ìˆ˜ ìˆë„ë¡ í•˜ì„¸ìš”.  
         * íƒˆì¶œí•  ìˆ˜ ì—†ë‹¤ë©´ -1ì„ ì¶œë ¥í•©ë‹ˆë‹¤.  
         *        
         * â¸»  
         *  
         * ğŸ“¥ ì…ë ¥ í˜•ì‹  
         * N M K  
         * <ë¯¸ë¡œ ì •ë³´> (Nì¤„)  
         *        
         * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
         *  â€¢  ìµœë‹¨ ì‹œê°„ (ì´ë™ íšŸìˆ˜)ì„ ì¶œë ¥  
         *  â€¢  íƒˆì¶œì´ ë¶ˆê°€ëŠ¥í•œ ê²½ìš° -1 ì¶œë ¥  
         *  
         *        
         * ğŸ’¡ ì˜ˆì œ ì…ë ¥  
         * 6 6 2  
         * 010000        
         * 111000         
         * 100000         
         * 000001        
         * 011111         
         * 000000        
		 *         
		 * ğŸ’¡ ì˜ˆì œ ì¶œë ¥  
         * 10  
         */  
  
        @Test  
        fun solution() {  
            val N = 6  
            val M = 6  
            val K = 2  
            val miro = arrayOf(  
                intArrayOf(0, 1, 0, 0, 0, 0),  
                intArrayOf(1, 1, 1, 0, 0, 0),  
                intArrayOf(1, 0, 0, 0, 0, 0),  
                intArrayOf(0, 0, 0, 0, 0, 1),  
                intArrayOf(0, 1, 1, 1, 1, 1),  
                intArrayOf(0, 0, 0, 0, 0, 0),  
            )  
            val expected = 10  
  
  
            assertEquals(expected, useBFS(N, M, K, miro))  
        }  
  
  
        private fun useBFS(N: Int, M: Int, K: Int, miro: Array<IntArray>): Int {  
            val visit = Array(N) { Array(M) { Array(K + 1) { false } } }  
            val deque = ArrayDeque<State>()  
            val endPointX = N - 1  
            val endPointY = M - 1  
            val direction = listOf(  
                Pair(-1, 0),  
                Pair(1, 0),  
                Pair(0, -1),  
                Pair(0, 1)  
            )  
  
            deque.addLast(State(0, 0, 0, 0))  
  
            while (deque.isNotEmpty()) {  
                val state = deque.removeFirst()  
                if (state.x == endPointX && state.y == endPointY) return state.dist  
  
                for ((nextX, nextY) in direction) {  
                    val moveX = nextX + state.x  
                    val moveY = nextY + state.y  
  
                    if (moveY !in miro.indices) continue  
                    if (moveX !in miro.first().indices) continue  
  
                    val isWall = miro[moveY][moveX] == 1  
                    val wallBreakCount = state.wallBreakCount + if (isWall) 1 else 0  
  
                    if (wallBreakCount > K) continue  
                    if (visit[moveY][moveX][wallBreakCount]) continue  
  
                    visit[moveY][moveX][wallBreakCount] = true  
                    deque.addLast(State(moveX, moveY, wallBreakCount, state.dist + 1))  
                }  
            }  
  
            return -1  
        }  
  
    }  
  
  
    @Nested  
    inner class HideAndSeek {  
        /**  
         * ğŸ§­ ë¬¸ì œ: ìˆ¨ë°”ê¼­ì§ˆ 3 (BOJ 13549 ë³€í˜•)  
         *      
         * â¸»  
         *  
         * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
         *  
         * ìˆ˜ë¹ˆì´ëŠ” í˜„ì¬ ìœ„ì¹˜ Nì— ìˆê³ , ë™ìƒì€ Kì— ìˆìŠµë‹ˆë‹¤.  
         * ìˆ˜ë¹ˆì´ëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:  
         *  1. X - 1 (ê±·ê¸°) â†’ 1ì´ˆ ì†Œìš”  
         *  2. X + 1 (ê±·ê¸°) â†’ 1ì´ˆ ì†Œìš”  
         *  3. 2 * X (ìˆœê°„ì´ë™) â†’ 0ì´ˆ ì†Œìš”  
         *  
         * ìˆ˜ë¹ˆì´ëŠ” ë™ìƒì„ ì°¾ê¸° ìœ„í•´ ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì— ë„ì°©í•˜ê³ ì í•©ë‹ˆë‹¤.  
         * ìµœì†Œ ì‹œê°„ì„ êµ¬í•˜ì„¸ìš”.  
         *         
         * â¸»  
         *  
         * ğŸ“¥ ì…ë ¥ í˜•ì‹  
         * N K  
         *        
         *  â€¢  0 â‰¤ N, K â‰¤ 100,000    
         *        
         * â¸»  
         *  
         * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
         *  â€¢  ìˆ˜ë¹ˆì´ê°€ ë™ìƒì—ê²Œ ë„ë‹¬í•˜ëŠ” ë° ê±¸ë¦¬ëŠ” ìµœì†Œ ì‹œê°„ ì¶œë ¥  
         *  
         * â¸»  
         *  
         * ğŸ’¡ ì˜ˆì œ ì…ë ¥  
         * 5 17  
         *        
         * ğŸ’¡ ì˜ˆì œ ì¶œë ¥  
         * 2  
         *        
         * > ê²½ë¡œ: 5 â†’ 10 (ìˆœê°„ì´ë™, 0ì´ˆ) â†’ 9 â†’ 18 -> 17 (1ì´ˆ + 1ì´ˆ)  
         */  
        @Test  
        fun solution() {  
            val N = 5  
            val K = 17  
            val expected = 2  
  
            assertEquals(expected, useBFS(N, K))  
        }  
  
        private fun useBFS(N: Int, K: Int): Int {  
            val deque = ArrayDeque<Pair<Int, Int>>()  
            val visit = BooleanArray(100_001)  
            val direction = listOf<Pair<(Int) -> Int, (Int) -> Int>>(  
                ({ i: Int -> i + 1 } to { i: Int -> i + 1 }),  
                ({ i: Int -> i - 1 } to { i: Int -> i + 1 }),  
                ({ i: Int -> i * 2 } to { i: Int -> i + 0 })  
  
            )  
            deque.addLast(N to 0)  
  
            while (deque.isNotEmpty()) {  
                val (position, time) = deque.removeFirst()  
                if (position == K) return time  
  
                for ((move, spend) in direction) {  
                    val next = move(position)  
                    val spendedTime = spend(time)  
  
                    if (next !in 0..100_000) continue  
                    if (visit[next]) continue  
                    visit[next] = true  
  
                    if (spendedTime == time) {  
                        deque.addFirst(next to spendedTime)  
                    } else {  
                        deque.addLast(next to spendedTime)  
                    }                }  
  
            }  
  
            return -1  
        }  
    }  
  
    @Nested  
    inner class `0-1Graph` {  
        /**  
         * ğŸ§­ ë¬¸ì œ: ì•Œê³ ìŠ¤íŒŸ (BOJ 1261 ë³€í˜•)  
         *        
         * â¸»  
         *  
         * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
         *  
         * ë‹¹ì‹ ì€ N x M í¬ê¸°ì˜ ë¯¸ë¡œì˜ (0,0)ì—ì„œ (N-1, M-1)ë¡œ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
         * ì´ ë¯¸ë¡œëŠ” **ë¹ˆ ì¹¸(0)**ê³¼ **ë²½(1)**ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ ìˆìœ¼ë©°,  
         * ë¹ˆ ì¹¸ì€ ë¹„ìš© 0, ë²½ì€ ë¹„ìš© 1ì…ë‹ˆë‹¤.  
         *       
         * ì´ë™ì€ ìƒí•˜ì¢Œìš°ë¡œë§Œ ê°€ëŠ¥í•˜ë©°,  
         * ë„ì°© ì§€ì ê¹Œì§€ ë„ë‹¬í•  ë•Œ **ë¶€ìˆœ ë²½ì˜ ìˆ˜ì˜ ìµœì†Œê°’(=ì´ ë¹„ìš©)**ì„ ì¶œë ¥í•˜ì„¸ìš”.  
         *        
         * â¸»  
         *  
         * ğŸ“¥ ì…ë ¥ í˜•ì‹  
         * M N  
         * <ë¯¸ë¡œ ì •ë³´> (Nì¤„, ê° ì¤„ Mê°œì˜ 0 ë˜ëŠ” 1)      
         *  â€¢  1 â‰¤ N, M â‰¤ 100       
         *  â€¢  0: ë¹ˆ ì¹¸ â†’ ì´ë™ ê°€ëŠ¥ (ë¹„ìš© 0)     
         *  â€¢  1: ë²½ â†’ ë¶€ìˆ˜ê³  ì´ë™ ê°€ëŠ¥ (ë¹„ìš© 1)       
         * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
         *      â€¢  (0,0) â†’ (N-1,M-1) ê¹Œì§€ ë„ë‹¬í•˜ëŠ” ìµœì†Œ ë¹„ìš© (ë¶€ìˆœ ë²½ ê°œìˆ˜)  
         *        
         *  â¸»  
         *  
         *  ğŸ’¡ ì˜ˆì œ ì…ë ¥  
         * 3 3  
         * 011       
         * 111        
         * 110       
         *         
         * ğŸ’¡ ì˜ˆì œ ì¶œë ¥  
         * 3  
         */  
        @Test  
        fun solution() {  
            val N = 3  
            val M = 3  
            val miro = arrayOf(  
                intArrayOf(0, 1, 1),  
                intArrayOf(1, 1, 1),  
                intArrayOf(1, 1, 0),  
            )  
            val expected = 3  
  
            assertEquals(expected, useBFS(N, M, miro))  
        }  
  
        private fun useBFS(N: Int, M: Int, miro: Array<IntArray>): Int {  
            val deque = ArrayDeque<State>()  
            val endPointX = N - 1  
            val endPointY = M - 1  
            val visited = Array(N){IntArray(M){Int.MAX_VALUE} }  
            val direction = listOf(  
                1 to 0,  
                -1 to 0,  
                0 to 1,  
                0 to -1  
            )  
            deque.addLast(State(0, 0, 0, 0))  
  
  
  
            while(deque.isNotEmpty()){  
                val state = deque.removeFirst()  
                if(state.x == endPointX && state.y == endPointY) return state.wallBreakCount  
                for((x, y) in direction) {  
                    val nextX = x + state.x  
                    val nextY = y + state.y  
  
                    if(nextX !in 0 until N) continue  
                    if(nextY !in 0 until M) continue  
                    val nextStep = miro[nextY][nextX]  
                    val cost = state.wallBreakCount + nextStep  
  
                    if(visited[nextY][nextX] <= cost) continue  
  
                    val nextState = State(nextX, nextY, cost, 0)  
                    visited[nextY][nextX] = cost  
                    if(nextStep == 1) {  
                        deque.addLast(nextState)  
                    }                    else {  
                        deque.addFirst(nextState)  
                    }                }  
            }  
  
            return -1  
        }  
    }  
}
```