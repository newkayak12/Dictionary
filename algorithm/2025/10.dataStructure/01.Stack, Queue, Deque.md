# Stack
## 1. 정의 
- LIFO(Last-In, First-Out) 구조의 자료구조
- 가장 최근에 삽입된 데이터가 가장 먼저 제거된다.

## 2. 구현 방식
- List + Index 또는 LinkedList로 구현
- Kt라면 ArrayDequeue로 사용

## 3. 활용 사례
1. 괄호의 짝 검사
2. 후위 표기식 계산
3. DFS 재귀 대체
4. 되돌리기 기능
5. Histogram, Stack-based 정답 누적


### 1. 괄호의 짝 검사
```kotlin
class Bracket {  
  
    /**  
     * 🧪 10-1-2. 스택 – 개념 문제  
     *  
     * 💡 문제: 올바른 괄호  
     *  
     * 설명  
     * 문자열이 주어졌을 때, 모든 괄호가 올바르게 열고 닫혀 있는지 판단하시오.  
     *  •  입력: "(()())"  
     *  •  출력: "YES"  
     *  •  입력: ")(()"  
     *  •  출력: "NO"  
     *   
     * ⸻  
     *  
     * ✅ 조건  
     *  •  괄호 종류는 ( 와 ) 만 있음  
     *  •  길이 최대 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. 후위 표기식 계산
```kotlin
class Postfix {  
    /**  
     * 📘 실습 문제 – 후위 표기식 계산 (기초 버전)  
     *     
     * 🧾 문제 설명  
     *  
     * 중위 표기식(예: 2 + 3)이 아닌 후위 표기식(Postfix, 예: 2 3 +)이 주어집니다.  
     * 이를 스택을 이용해서 계산하세요.  
     *     
     * 📥 입력 형식  
     *  •  문자열로 된 후위 표기식이 한 줄에 주어집니다.  
     *  •  피연산자는 한 자리 숫자(0~9)로만 주어지며, 공백으로 구분되어 있습니다.  
     *  •  연산자는 +, -, *, / 중 하나입니다.  
     *    
     * 예: "2 3 + 4 *"  
     * → (2 + 3) * 4 = 20   
     *    
     * 📤 출력 형식  
     *  •  계산 결과를 출력하세요. (정수만)  
     *    
     * ⸻  
     *  
     * ✅ 예시 입출력  
     *  
     * |입력 | 출력|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```

### Histogram
```kotlin
class Histogram {  
    /**  
     * 📘 실습 문제 – 가장 큰 직사각형 (Histogram)   
	 *    
	 * 💡 문제 설명  
     *  
     * 세로선의 높이가 주어졌을 때, 연속된 막대들로 만들 수 있는 가장 큰 직사각형의 넓이를 구하세요.  
     * (단, 모든 막대의 너비는 1입니다.)  
     *    
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  정수 배열 형태로 n개의 막대 높이가 주어짐  
     *  
     * 예: [2, 1, 5, 6, 2, 3]  
     *    
     * ⸻  
     *  
     * 📤 출력 형식  
     *  •  만들 수 있는 최대 직사각형 넓이를 출력  
     *  
     * ⸻  
     *  
     * 🧮 예시  
     *  
     * |입력|출력|  
     * |:---:|:---:|    
     * |[2, 1, 5, 6, 2, 3]|10| 
     * |[2, 4]|4|    
     * |[6, 2, 5, 4, 5, 1, 6]|12| 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = listOf(2, 1, 5, 6, 2, 3)  
        val expected = 10  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf(2, 4)  
        val expected = 4  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf(6, 2, 5, 4, 5, 1, 6)  
        val expected = 12  
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<Int>): Int {  
        val extendedInput = List(input.size + 1) { input.getOrElse(it) { 0 } }  
        val stack = ArrayDeque<Int>()  
        var maxArea = 0  
  
  
        for (i in extendedInput.indices) {  
  
            while (stack.isNotEmpty() && extendedInput[i] < extendedInput[stack.last()]) {  
                val topIndex = stack.removeLast()  
                val height = extendedInput[topIndex]  
                val width = if (stack.isEmpty()) i else i - stack.last() - 1  
                maxArea = max(maxArea, width * height)  
            }  
  
            stack.addLast(i)  
        }  
  
        return maxArea  
    }  
}
```


# Queue
## 1. 정의 
1. FIFO(First-In, First-Out) - 선입 선출
2. 먼저 들어온 데이터가 먼저 나간다.
## 2. 구현 방식
1. Kotlin에서는 ArrayDequeue를 일반적으로 선택한다.
2. Java에서는 LinkedList\<T\>()를 사용한다.

## 3. 활용 사례
1. BFS
2. 프린터 출력 순서
3. RoundRobin
4. 캐시 또는 요청 큐

### 1. 카드 뽑기
```kotlin
class DrawCard {  
    /**  
     * 📘 실습 문제 – 카드 뽑기 시뮬레이션 (BOJ 2161 변형)  
     *    
     * ⸻  
     *  
     * 🧾 문제 설명  
     *  
     * 1부터 N까지 번호가 적힌 카드가 1번이 제일 위, N번이 제일 아래로 놓여 있습니다.  
     * 다음 과정을 반복합니다:  
     *  1. 제일 위에 있는 카드를 버린다  
     *  2. 그 다음 위에 있는 카드를 맨 아래로 옮긴다  
     *  
     * 이 과정을 반복해 카드가 한 장 남을 때까지 진행했을 때,  
     * 버린 카드들을 순서대로 출력하고, 마지막 남은 카드도 출력하세요.  
     *   
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  첫째 줄에 카드의 개수 N이 주어집니다. (1 ≤ N ≤ 1000)  
     *   
     * 예:  
     * 7    
     *    
     * 📤 출력 형식  
     *  •  첫째 줄: 버린 카드 번호를 순서대로 출력 (공백 구분)  
     *  •  둘째 줄: 마지막에 남은 카드 번호 출력  
     *  
     * 예:  
     * 1 3 5 7 4 2 
     * 6   
     * */  
  
    @Test  
    fun solution() {  
        val size = 7  
        val expectedDiscarded = listOf(1,3,5,7,4,2)  
        val expectedResult = 6  
  
        val (resultDiscarded, resultNumber) = useQueue(size)  
  
        assertEquals(expectedDiscarded,resultDiscarded)  
        assertEquals(expectedResult, resultNumber)  
    }  
  
    private fun useQueue(size: Int): Pair<List<Int>, Int> {  
        val pile = ArrayDeque<Int>()  
        for( i in 1 .. size) {  
            pile.addLast(i)  
        }  
        var index = 0;  
        val discarded = mutableListOf<Int>()  
  
  
        while(pile.size != 1) {  
            val element = pile.removeFirst()  
            if( index%2==0) {  
                discarded.add(element)  
            }  
            else {  
                pile.addLast(element)  
            }  
  
            index ++  
        }  
  
        val pick = pile.removeFirst()  
  
        println(discarded)  
        println(pick)  
  
  
        return discarded to pick  
    }  
}
```


# Deque
## 1. 정의 
- Double-Ended Queue: 양쪽에서 삽입과 삭제가 가능한 양방향 큐
## 2. 구현 방식
 - KT에서 ArrayDeque
 - Java에서 LinkedList
## 3. 활용 사례
1. 슬라이딩 문제
2. AC 문제
3. 0-1 BFS

#### 1. 슬라이딩 윈도우
```kotlin
class BasicSlidingWindow {  
    /**  
     * 📘 문제: 슬라이딩 윈도우의 최솟값 (정석, 일반적 스타일)  
     *     * 🧾 문제 설명  
     *  
     * 정수 배열 nums와 정수 k가 주어집니다.  
     * 길이 k의 슬라이딩 윈도우를 오른쪽으로 한 칸씩 이동시키면서,  
     * 각 윈도우에서 최솟값을 구하여 리스트로 반환하세요.  
     *     
     * ⸻  
     *  
     * 📥 입력  
     *  •  정수 배열 nums: 길이 N (1 ≤ N ≤ 10⁶)  
     *  •  윈도우 크기 k: 1 ≤ k ≤ N 
     *    
     * ⸻  
     *  
     * 📤 출력  
     *  •  각 슬라이딩 윈도우의 최솟값을 순서대로 담은 정수 리스트  
     *  
     * ⸻  
     *  
     * ✅ 예제 1   
     *    
     * 입력:  
     * nums = [1, 3, -1, -3, 5, 3, 6, 7]   
     * k = 3    
     * 출력:  
     * [-1, -3, -3, -3, 3, 3]    
     * */  
  
    @Test  
    fun solution(){  
        val numbs = intArrayOf(1, 3, -1, -3, 5, 3, 6, 7)  
        val windowSize = 3  
        val expected = intArrayOf(-1, -3, -3, -3, 3, 3)  
  
        assertArrayEquals(expected, useSlidingWindow(numbs, windowSize))  
    }  
  
  
    private fun useSlidingWindow(number: IntArray, windowSize: Int): IntArray {  
        val resultList = mutableListOf<Int>()  
        val deque = ArrayDeque<Int>()  
  
        for(i in number.indices) {  
            while(deque.isNotEmpty() && deque.first() <= i - windowSize) {  
                deque.removeFirst()  
            }  
            while(deque.isNotEmpty() && number[deque.last()] >= number[i]){  
                deque.removeLast()  
            }  
  
            deque.addLast(i)  
            if(i - windowSize + 1 >= 0){  
                resultList.add(number[deque.first()])  
            }  
  
        }  
  
  
  
        return resultList.toIntArray()  
    }  
}
```

#### 2. AC(ArrayControll)
```kotlin
class AC {  
    /**  
     * 📘 문제: AC (BOJ 5430 변형)  
     *     
     * 🧾 문제 설명  
     * R(뒤집기)과 D(버리기)로 이루어진 명령어 문자열과, 정수 배열이 주어집니다.  
     * 명령어를 앞에서부터 순서대로 수행하면서 배열에 변화를 적용하세요.  
     * 단, 배열이 비어있을 때 D 명령어가 들어오면 에러가 발생합니다.  
     *     
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  첫 줄에 테스트 케이스 T (1 ≤ T ≤ 100)     
     *  •  각 테스트 케이스마다:  
     *  •  명령어 문자열 p (길이 1 ≤ p ≤ 100,000)    
     *  •  정수 n (0 ≤ n ≤ 100,000)     
     *  •  배열: [x₁,x₂,…,xₙ] 형식의 문자열  
     *  
     * ⸻  
     *  
     * 📤 출력 형식  
     *  •  명령어 수행 결과 배열을 문자열로 출력  
     *  •  에러 발생 시 "error" 출력  
     *  
     * ⸻  
     *  
     * ✅ 예제  
     *  
     * 입력:  
     * 4    
     * --- 예제 1    
     * 명령어: RDD  
     * 배열 길이: 4  
     * 배열: [1,2,3,4]  
     *     
     * --- 예제 2    
     * 명령어: DD  
     * 배열 길이: 1  
     * 배열: [42]  
     *     
     * --- 예제 3   
	 * 명령어: RRD  
     * 배열 길이: 6  
     * 배열: [1,1,2,3,5,8]  
     *     
     * --- 예제 4   
     * 명령어: D  
     * 배열 길이: 0  
     * 배열: []  
     *     
     * 출력:  
     * --- 출력 1     
     * [2,1]     
     *     
     * --- 출력 2    
     * error    
     *    
     * --- 출력 3    
     * [1,2,3,5,8]   
     *    
     * --- 출력 4    
     * error   
     * */  
 
    @Test  
    fun solution1() {  
        val command = "RDD"  
        val arraySize = 4  
        val array = intArrayOf(1,2,3,4)  
        val expected = intArrayOf(2,1).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution2() {  
        val command = "DD"  
        val arraySize = 1  
        val array = intArrayOf(42)  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution3() {  
        val command = "D"  
        val arraySize = 6  
        val array = intArrayOf(1,1,2,3,5,8)  
        val expected = intArrayOf(1,2,3,5,8).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution4() {  
        val command = "RDD"  
        val arraySize = 0  
        val array = intArrayOf()  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    private fun useDeque(command: String, array: IntArray): String {  
        val deque = ArrayDeque<Int>()  
        val result = mutableListOf<Int>()  
        var leftToRight = true  
        val reverse = 'R'  
        val delete = 'D'  
  
        for(element in array) {  
            deque.addLast(element)  
        }  
  
        for(element in command) {  
            when(element) {  
                reverse -> leftToRight = !leftToRight  
                delete -> {  
                    if(deque.isEmpty()) return "error"  
  
                    if(leftToRight){  
                        deque.removeFirst()  
                    } 
                    else {  
                        deque.removeLast()  
                    }
				}  
            }  
        }  
  
        while(deque.isNotEmpty()) {  
            if(leftToRight) {  
                result.add(deque.removeFirst())  
            }  
            else {  
                result.add(deque.removeLast())  
            }  
        }  
  
  
        return result.toIntArray().contentToString()  
    }  
}
```

