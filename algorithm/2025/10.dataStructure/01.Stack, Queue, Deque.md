# Stack
## 1. 정의 
- LIFO(Last-In, First-Out) 구조의 자료구조
- 가장 최근에 삽입된 데이터가 가장 먼저 제거된다.

## 2. 구현 방식
- List + Index 또는 LinkedList로 구현
- Kt라면 ArrayDequeue로 사용

## 3. 활용 사례
1. 괄호의 짝 검사
2. 후위 표기식 계산
3. DFS 재귀 대체
4. 되돌리기 기능
5. Histogram, Stack-based 정답 누적


### 1. 괄호의 짝 검사
```kotlin
class Bracket {  
  
    /**  
     * 🧪 10-1-2. 스택 – 개념 문제  
     *  
     * 💡 문제: 올바른 괄호  
     *  
     * 설명  
     * 문자열이 주어졌을 때, 모든 괄호가 올바르게 열고 닫혀 있는지 판단하시오.  
     *  •  입력: "(()())"  
     *  •  출력: "YES"  
     *  •  입력: ")(()"  
     *  •  출력: "NO"  
     *   
     * ⸻  
     *  
     * ✅ 조건  
     *  •  괄호 종류는 ( 와 ) 만 있음  
     *  •  길이 최대 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. 후위 표기식 계산
```kotlin
class Postfix {  
    /**  
     * 📘 실습 문제 – 후위 표기식 계산 (기초 버전)  
     *     
     * 🧾 문제 설명  
     *  
     * 중위 표기식(예: 2 + 3)이 아닌 후위 표기식(Postfix, 예: 2 3 +)이 주어집니다.  
     * 이를 스택을 이용해서 계산하세요.  
     *     
     * 📥 입력 형식  
     *  •  문자열로 된 후위 표기식이 한 줄에 주어집니다.  
     *  •  피연산자는 한 자리 숫자(0~9)로만 주어지며, 공백으로 구분되어 있습니다.  
     *  •  연산자는 +, -, *, / 중 하나입니다.  
     *    
     * 예: "2 3 + 4 *"  
     * → (2 + 3) * 4 = 20   
     *    
     * 📤 출력 형식  
     *  •  계산 결과를 출력하세요. (정수만)  
     *    
     * ⸻  
     *  
     * ✅ 예시 입출력  
     *  
     * |입력 | 출력|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```

### Histogram
```kotlin
class Histogram {  
    /**  
     * 📘 실습 문제 – 가장 큰 직사각형 (Histogram)   
	 *    
	 * 💡 문제 설명  
     *  
     * 세로선의 높이가 주어졌을 때, 연속된 막대들로 만들 수 있는 가장 큰 직사각형의 넓이를 구하세요.  
     * (단, 모든 막대의 너비는 1입니다.)  
     *    
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  정수 배열 형태로 n개의 막대 높이가 주어짐  
     *  
     * 예: [2, 1, 5, 6, 2, 3]  
     *    
     * ⸻  
     *  
     * 📤 출력 형식  
     *  •  만들 수 있는 최대 직사각형 넓이를 출력  
     *  
     * ⸻  
     *  
     * 🧮 예시  
     *  
     * |입력|출력|  
     * |:---:|:---:|    
     * |[2, 1, 5, 6, 2, 3]|10| 
     * |[2, 4]|4|    
     * |[6, 2, 5, 4, 5, 1, 6]|12| 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = listOf(2, 1, 5, 6, 2, 3)  
        val expected = 10  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf(2, 4)  
        val expected = 4  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf(6, 2, 5, 4, 5, 1, 6)  
        val expected = 12  
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<Int>): Int {  
        val extendedInput = List(input.size + 1) { input.getOrElse(it) { 0 } }  
        val stack = ArrayDeque<Int>()  
        var maxArea = 0  
  
  
        for (i in extendedInput.indices) {  
  
            while (stack.isNotEmpty() && extendedInput[i] < extendedInput[stack.last()]) {  
                val topIndex = stack.removeLast()  
                val height = extendedInput[topIndex]  
                val width = if (stack.isEmpty()) i else i - stack.last() - 1  
                maxArea = max(maxArea, width * height)  
            }  
  
            stack.addLast(i)  
        }  
  
        return maxArea  
    }  
}
```


# Queue
## 1. 정의 
1. FIFO(First-In, First-Out) - 선입 선출
2. 먼저 들어온 데이터가 먼저 나간다.
## 2. 구현 방식
1. Kotlin에서는 ArrayDequeue를 일반적으로 선택한다.
2. Java에서는 LinkedList\<T\>()를 사용한다.

## 3. 활용 사례
1. BFS
2. 프린터 출력 순서
3. RoundRobin
4. 캐시 또는 요청 큐

### 1. 카드 뽑기
```kotlin
class DrawCard {  
    /**  
     * 📘 실습 문제 – 카드 뽑기 시뮬레이션 (BOJ 2161 변형)  
     *    
     * ⸻  
     *  
     * 🧾 문제 설명  
     *  
     * 1부터 N까지 번호가 적힌 카드가 1번이 제일 위, N번이 제일 아래로 놓여 있습니다.  
     * 다음 과정을 반복합니다:  
     *  1. 제일 위에 있는 카드를 버린다  
     *  2. 그 다음 위에 있는 카드를 맨 아래로 옮긴다  
     *  
     * 이 과정을 반복해 카드가 한 장 남을 때까지 진행했을 때,  
     * 버린 카드들을 순서대로 출력하고, 마지막 남은 카드도 출력하세요.  
     *   
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  첫째 줄에 카드의 개수 N이 주어집니다. (1 ≤ N ≤ 1000)  
     *   
     * 예:  
     * 7    
     *    
     * 📤 출력 형식  
     *  •  첫째 줄: 버린 카드 번호를 순서대로 출력 (공백 구분)  
     *  •  둘째 줄: 마지막에 남은 카드 번호 출력  
     *  
     * 예:  
     * 1 3 5 7 4 2 
     * 6   
     * */  
  
    @Test  
    fun solution() {  
        val size = 7  
        val expectedDiscarded = listOf(1,3,5,7,4,2)  
        val expectedResult = 6  
  
        val (resultDiscarded, resultNumber) = useQueue(size)  
  
        assertEquals(expectedDiscarded,resultDiscarded)  
        assertEquals(expectedResult, resultNumber)  
    }  
  
    private fun useQueue(size: Int): Pair<List<Int>, Int> {  
        val pile = ArrayDeque<Int>()  
        for( i in 1 .. size) {  
            pile.addLast(i)  
        }  
        var index = 0;  
        val discarded = mutableListOf<Int>()  
  
  
        while(pile.size != 1) {  
            val element = pile.removeFirst()  
            if( index%2==0) {  
                discarded.add(element)  
            }  
            else {  
                pile.addLast(element)  
            }  
  
            index ++  
        }  
  
        val pick = pile.removeFirst()  
  
        println(discarded)  
        println(pick)  
  
  
        return discarded to pick  
    }  
}
```


# Deque
## 1. 정의 
- Double-Ended Queue: 양쪽에서 삽입과 삭제가 가능한 양방향 큐
## 2. 구현 방식
 - KT에서 ArrayDeque
 - Java에서 LinkedList
## 3. 활용 사례
1. 슬라이딩 문제
2. AC 문제
3. 0-1 BFS

#### 1. 슬라이딩 윈도우
```kotlin
class BasicSlidingWindow {  
    /**  
     * 📘 문제: 슬라이딩 윈도우의 최솟값 (정석, 일반적 스타일)  
     *     * 🧾 문제 설명  
     *  
     * 정수 배열 nums와 정수 k가 주어집니다.  
     * 길이 k의 슬라이딩 윈도우를 오른쪽으로 한 칸씩 이동시키면서,  
     * 각 윈도우에서 최솟값을 구하여 리스트로 반환하세요.  
     *     
     * ⸻  
     *  
     * 📥 입력  
     *  •  정수 배열 nums: 길이 N (1 ≤ N ≤ 10⁶)  
     *  •  윈도우 크기 k: 1 ≤ k ≤ N 
     *    
     * ⸻  
     *  
     * 📤 출력  
     *  •  각 슬라이딩 윈도우의 최솟값을 순서대로 담은 정수 리스트  
     *  
     * ⸻  
     *  
     * ✅ 예제 1   
     *    
     * 입력:  
     * nums = [1, 3, -1, -3, 5, 3, 6, 7]   
     * k = 3    
     * 출력:  
     * [-1, -3, -3, -3, 3, 3]    
     * */  
  
    @Test  
    fun solution(){  
        val numbs = intArrayOf(1, 3, -1, -3, 5, 3, 6, 7)  
        val windowSize = 3  
        val expected = intArrayOf(-1, -3, -3, -3, 3, 3)  
  
        assertArrayEquals(expected, useSlidingWindow(numbs, windowSize))  
    }  
  
  
    private fun useSlidingWindow(number: IntArray, windowSize: Int): IntArray {  
        val resultList = mutableListOf<Int>()  
        val deque = ArrayDeque<Int>()  
  
        for(i in number.indices) {  
            while(deque.isNotEmpty() && deque.first() <= i - windowSize) {  
                deque.removeFirst()  
            }  
            while(deque.isNotEmpty() && number[deque.last()] >= number[i]){  
                deque.removeLast()  
            }  
  
            deque.addLast(i)  
            if(i - windowSize + 1 >= 0){  
                resultList.add(number[deque.first()])  
            }  
  
        }  
  
  
  
        return resultList.toIntArray()  
    }  
}
```

#### 2. AC(ArrayControll)
```kotlin
class AC {  
    /**  
     * 📘 문제: AC (BOJ 5430 변형)  
     *     
     * 🧾 문제 설명  
     * R(뒤집기)과 D(버리기)로 이루어진 명령어 문자열과, 정수 배열이 주어집니다.  
     * 명령어를 앞에서부터 순서대로 수행하면서 배열에 변화를 적용하세요.  
     * 단, 배열이 비어있을 때 D 명령어가 들어오면 에러가 발생합니다.  
     *     
     * ⸻  
     *  
     * 📥 입력 형식  
     *  •  첫 줄에 테스트 케이스 T (1 ≤ T ≤ 100)     
     *  •  각 테스트 케이스마다:  
     *  •  명령어 문자열 p (길이 1 ≤ p ≤ 100,000)    
     *  •  정수 n (0 ≤ n ≤ 100,000)     
     *  •  배열: [x₁,x₂,…,xₙ] 형식의 문자열  
     *  
     * ⸻  
     *  
     * 📤 출력 형식  
     *  •  명령어 수행 결과 배열을 문자열로 출력  
     *  •  에러 발생 시 "error" 출력  
     *  
     * ⸻  
     *  
     * ✅ 예제  
     *  
     * 입력:  
     * 4    
     * --- 예제 1    
     * 명령어: RDD  
     * 배열 길이: 4  
     * 배열: [1,2,3,4]  
     *     
     * --- 예제 2    
     * 명령어: DD  
     * 배열 길이: 1  
     * 배열: [42]  
     *     
     * --- 예제 3   
	 * 명령어: RRD  
     * 배열 길이: 6  
     * 배열: [1,1,2,3,5,8]  
     *     
     * --- 예제 4   
     * 명령어: D  
     * 배열 길이: 0  
     * 배열: []  
     *     
     * 출력:  
     * --- 출력 1     
     * [2,1]     
     *     
     * --- 출력 2    
     * error    
     *    
     * --- 출력 3    
     * [1,2,3,5,8]   
     *    
     * --- 출력 4    
     * error   
     * */  
 
    @Test  
    fun solution1() {  
        val command = "RDD"  
        val arraySize = 4  
        val array = intArrayOf(1,2,3,4)  
        val expected = intArrayOf(2,1).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution2() {  
        val command = "DD"  
        val arraySize = 1  
        val array = intArrayOf(42)  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution3() {  
        val command = "D"  
        val arraySize = 6  
        val array = intArrayOf(1,1,2,3,5,8)  
        val expected = intArrayOf(1,2,3,5,8).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution4() {  
        val command = "RDD"  
        val arraySize = 0  
        val array = intArrayOf()  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    private fun useDeque(command: String, array: IntArray): String {  
        val deque = ArrayDeque<Int>()  
        val result = mutableListOf<Int>()  
        var leftToRight = true  
        val reverse = 'R'  
        val delete = 'D'  
  
        for(element in array) {  
            deque.addLast(element)  
        }  
  
        for(element in command) {  
            when(element) {  
                reverse -> leftToRight = !leftToRight  
                delete -> {  
                    if(deque.isEmpty()) return "error"  
  
                    if(leftToRight){  
                        deque.removeFirst()  
                    } 
                    else {  
                        deque.removeLast()  
                    }
				}  
            }  
        }  
  
        while(deque.isNotEmpty()) {  
            if(leftToRight) {  
                result.add(deque.removeFirst())  
            }  
            else {  
                result.add(deque.removeLast())  
            }  
        }  
  
  
        return result.toIntArray().contentToString()  
    }  
}
```

#### 3. 0-1 BFS
```kotlin
class `0-1BFS` {  
    /**  
     * 0-1 BFS는 간선 가중치가 0 또는 1인 그래프에서 최단 거리를 구할 때 사용하는  
     * 특수한 BFS 알고리즘입니다.  
     *     
     * 일반적인 BFS와 Dijkstra 알고리즘의 중간 형태이며,  
     * 시간 복잡도는 Dijkstra보다 빠르고 BFS만큼 간단한 구조를 가집니다.  
     *     
     * ✅ 개념 정리  
     *  
     * |항목| 설명|  
     * |:---:|:---:|   
     * |목적| 간선 가중치가 0 또는 1인 그래프에서 최단 거리 계산|  
     * |행심 아이디어|간선 가중치가 0이면 앞, 1이면 뒤에 넣는 방식|  
     * |자료구조|Deque(Double-ended queue)|  
     * |시간 복잡도|O(V+E)|  
     *     
     * ## 일반 BFS는 왜 안되는가?  
     * - BFS는 모든 간선의 가중치가 동일일 때만 유효하다.  
     * - 가중치 0 또는 1일 경우, 일반 BFS는 0 가중치 간선을 더 빨리 반영하지 못함  
     * - Dijkstra는 우선순위 큐를 사용해서 정확하지만, 복잡하고 느리다.  
     * - 0-1 BFS는 두 단점을 보완  
     *  
     *    
     * ## Pseudo     
     *     
     * ```text    
     * 시작 정점에서 Deque 초기화  
     * 방문 배열을 모두 초기화  
     *  
     * 큐가 빌 때까지:  
     *      현재 노드를 꺼낸다.  
     *      인접한 노드를 순회  
     *          가중치가 0이면 -> Deque의 앞에 삽입  
     *          가중치가 1이면 -> Deque의 뒤에 삽입  
     *  
     *     
     * ```   
     * ### 1과 0에 대한 처리  
     * - 더 빠르게 도착할 수 있는 경로부터 탐색한다.  
     * - 가중치로 우선순위를 나눈다.  
     *     
     *     
     * ## 예시 문제  
     *  
     * | 문제 이름 | 설명 |     
     * |:----:|:----:|    
     * |벽 부수고 이동| 벽을 1개까지 부술 수 있는 상태 확장형|  
     * |특정 위치까지 최소 시간| 순간이동(0초) + 걷기(1초) 등의 조합|  
     * |가중치 0/1 도로로 된 그래프의 최소 경로 찾기| 도로의 종류에 따라 우선순위 다르게 적용|  
     */  
    data class State(val x: Int, val y: Int, val wallBreakCount: Int, val dist: Int)  
  
    @Nested  
    inner class BreakWall {  
        /**  
         * 🧱 문제: 벽 부수고 탈출하기 (0-1 BFS 변형)  
         *        
         * 📘 문제 설명  
         *  
         * 당신은 N x M 크기의 미로에 갇혔습니다.  
         * 당신은 (1,1) 위치에서 출발해 (N,M) 위치로 이동하려고 합니다.  
         * 이 미로에는 **빈 칸(0)**과 **벽(1)**이 존재하며, 당신은 벽을 여러 개 부술 수 있습니다.  
         * 하지만, 부술 수 있는 벽의 최대 개수는 K개입니다.  
         *       
         * 이동할 수 있는 방향은 상하좌우이며, 한 칸을 이동할 때는 1초가 걸립니다.  
         * 가능한 가장 빠른 시간에 탈출할 수 있도록 하세요.  
         * 탈출할 수 없다면 -1을 출력합니다.  
         *        
         * ⸻  
         *  
         * 📥 입력 형식  
         * N M K  
         * <미로 정보> (N줄)  
         *        
         * 📤 출력 형식  
         *  •  최단 시간 (이동 횟수)을 출력  
         *  •  탈출이 불가능한 경우 -1 출력  
         *  
         *        
         * 💡 예제 입력  
         * 6 6 2  
         * 010000        
         * 111000         
         * 100000         
         * 000001        
         * 011111         
         * 000000        
		 *         
		 * 💡 예제 출력  
         * 10  
         */  
  
        @Test  
        fun solution() {  
            val N = 6  
            val M = 6  
            val K = 2  
            val miro = arrayOf(  
                intArrayOf(0, 1, 0, 0, 0, 0),  
                intArrayOf(1, 1, 1, 0, 0, 0),  
                intArrayOf(1, 0, 0, 0, 0, 0),  
                intArrayOf(0, 0, 0, 0, 0, 1),  
                intArrayOf(0, 1, 1, 1, 1, 1),  
                intArrayOf(0, 0, 0, 0, 0, 0),  
            )  
            val expected = 10  
  
  
            assertEquals(expected, useBFS(N, M, K, miro))  
        }  
  
  
        private fun useBFS(N: Int, M: Int, K: Int, miro: Array<IntArray>): Int {  
            val visit = Array(N) { Array(M) { Array(K + 1) { false } } }  
            val deque = ArrayDeque<State>()  
            val endPointX = N - 1  
            val endPointY = M - 1  
            val direction = listOf(  
                Pair(-1, 0),  
                Pair(1, 0),  
                Pair(0, -1),  
                Pair(0, 1)  
            )  
  
            deque.addLast(State(0, 0, 0, 0))  
  
            while (deque.isNotEmpty()) {  
                val state = deque.removeFirst()  
                if (state.x == endPointX && state.y == endPointY) return state.dist  
  
                for ((nextX, nextY) in direction) {  
                    val moveX = nextX + state.x  
                    val moveY = nextY + state.y  
  
                    if (moveY !in miro.indices) continue  
                    if (moveX !in miro.first().indices) continue  
  
                    val isWall = miro[moveY][moveX] == 1  
                    val wallBreakCount = state.wallBreakCount + if (isWall) 1 else 0  
  
                    if (wallBreakCount > K) continue  
                    if (visit[moveY][moveX][wallBreakCount]) continue  
  
                    visit[moveY][moveX][wallBreakCount] = true  
                    deque.addLast(State(moveX, moveY, wallBreakCount, state.dist + 1))  
                }  
            }  
  
            return -1  
        }  
  
    }  
  
  
    @Nested  
    inner class HideAndSeek {  
        /**  
         * 🧭 문제: 숨바꼭질 3 (BOJ 13549 변형)  
         *      
         * ⸻  
         *  
         * 📘 문제 설명  
         *  
         * 수빈이는 현재 위치 N에 있고, 동생은 K에 있습니다.  
         * 수빈이는 다음 세 가지 방법으로 이동할 수 있습니다:  
         *  1. X - 1 (걷기) → 1초 소요  
         *  2. X + 1 (걷기) → 1초 소요  
         *  3. 2 * X (순간이동) → 0초 소요  
         *  
         * 수빈이는 동생을 찾기 위해 가장 빠른 시간에 도착하고자 합니다.  
         * 최소 시간을 구하세요.  
         *         
         * ⸻  
         *  
         * 📥 입력 형식  
         * N K  
         *        
         *  •  0 ≤ N, K ≤ 100,000    
         *        
         * ⸻  
         *  
         * 📤 출력 형식  
         *  •  수빈이가 동생에게 도달하는 데 걸리는 최소 시간 출력  
         *  
         * ⸻  
         *  
         * 💡 예제 입력  
         * 5 17  
         *        
         * 💡 예제 출력  
         * 2  
         *        
         * > 경로: 5 → 10 (순간이동, 0초) → 9 → 18 -> 17 (1초 + 1초)  
         */  
        @Test  
        fun solution() {  
            val N = 5  
            val K = 17  
            val expected = 2  
  
            assertEquals(expected, useBFS(N, K))  
        }  
  
        private fun useBFS(N: Int, K: Int): Int {  
            val deque = ArrayDeque<Pair<Int, Int>>()  
            val visit = BooleanArray(100_001)  
            val direction = listOf<Pair<(Int) -> Int, (Int) -> Int>>(  
                ({ i: Int -> i + 1 } to { i: Int -> i + 1 }),  
                ({ i: Int -> i - 1 } to { i: Int -> i + 1 }),  
                ({ i: Int -> i * 2 } to { i: Int -> i + 0 })  
  
            )  
            deque.addLast(N to 0)  
  
            while (deque.isNotEmpty()) {  
                val (position, time) = deque.removeFirst()  
                if (position == K) return time  
  
                for ((move, spend) in direction) {  
                    val next = move(position)  
                    val spendedTime = spend(time)  
  
                    if (next !in 0..100_000) continue  
                    if (visit[next]) continue  
                    visit[next] = true  
  
                    if (spendedTime == time) {  
                        deque.addFirst(next to spendedTime)  
                    } else {  
                        deque.addLast(next to spendedTime)  
                    }                }  
  
            }  
  
            return -1  
        }  
    }  
  
    @Nested  
    inner class `0-1Graph` {  
        /**  
         * 🧭 문제: 알고스팟 (BOJ 1261 변형)  
         *        
         * ⸻  
         *  
         * 📘 문제 설명  
         *  
         * 당신은 N x M 크기의 미로의 (0,0)에서 (N-1, M-1)로 이동하려고 합니다.  
         * 이 미로는 **빈 칸(0)**과 **벽(1)**으로 구성되어 있으며,  
         * 빈 칸은 비용 0, 벽은 비용 1입니다.  
         *       
         * 이동은 상하좌우로만 가능하며,  
         * 도착 지점까지 도달할 때 **부순 벽의 수의 최소값(=총 비용)**을 출력하세요.  
         *        
         * ⸻  
         *  
         * 📥 입력 형식  
         * M N  
         * <미로 정보> (N줄, 각 줄 M개의 0 또는 1)      
         *  •  1 ≤ N, M ≤ 100       
         *  •  0: 빈 칸 → 이동 가능 (비용 0)     
         *  •  1: 벽 → 부수고 이동 가능 (비용 1)       
         * 📤 출력 형식  
         *      •  (0,0) → (N-1,M-1) 까지 도달하는 최소 비용 (부순 벽 개수)  
         *        
         *  ⸻  
         *  
         *  💡 예제 입력  
         * 3 3  
         * 011       
         * 111        
         * 110       
         *         
         * 💡 예제 출력  
         * 3  
         */  
        @Test  
        fun solution() {  
            val N = 3  
            val M = 3  
            val miro = arrayOf(  
                intArrayOf(0, 1, 1),  
                intArrayOf(1, 1, 1),  
                intArrayOf(1, 1, 0),  
            )  
            val expected = 3  
  
            assertEquals(expected, useBFS(N, M, miro))  
        }  
  
        private fun useBFS(N: Int, M: Int, miro: Array<IntArray>): Int {  
            val deque = ArrayDeque<State>()  
            val endPointX = N - 1  
            val endPointY = M - 1  
            val visited = Array(N){IntArray(M){Int.MAX_VALUE} }  
            val direction = listOf(  
                1 to 0,  
                -1 to 0,  
                0 to 1,  
                0 to -1  
            )  
            deque.addLast(State(0, 0, 0, 0))  
  
  
  
            while(deque.isNotEmpty()){  
                val state = deque.removeFirst()  
                if(state.x == endPointX && state.y == endPointY) return state.wallBreakCount  
                for((x, y) in direction) {  
                    val nextX = x + state.x  
                    val nextY = y + state.y  
  
                    if(nextX !in 0 until N) continue  
                    if(nextY !in 0 until M) continue  
                    val nextStep = miro[nextY][nextX]  
                    val cost = state.wallBreakCount + nextStep  
  
                    if(visited[nextY][nextX] <= cost) continue  
  
                    val nextState = State(nextX, nextY, cost, 0)  
                    visited[nextY][nextX] = cost  
                    if(nextStep == 1) {  
                        deque.addLast(nextState)  
                    }                    else {  
                        deque.addFirst(nextState)  
                    }                }  
            }  
  
            return -1  
        }  
    }  
}
```