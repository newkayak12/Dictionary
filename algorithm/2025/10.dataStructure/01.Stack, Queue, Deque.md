# Stack
## 1. ì •ì˜ 
- LIFO(Last-In, First-Out) êµ¬ì¡°ì˜ ìë£Œêµ¬ì¡°
- ê°€ì¥ ìµœê·¼ì— ì‚½ì…ëœ ë°ì´í„°ê°€ ê°€ì¥ ë¨¼ì € ì œê±°ëœë‹¤.

## 2. êµ¬í˜„ ë°©ì‹
- List + Index ë˜ëŠ” LinkedListë¡œ êµ¬í˜„
- Ktë¼ë©´ ArrayDequeueë¡œ ì‚¬ìš©

## 3. í™œìš© ì‚¬ë¡€
1. ê´„í˜¸ì˜ ì§ ê²€ì‚¬
2. í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚°
3. DFS ì¬ê·€ ëŒ€ì²´
4. ë˜ëŒë¦¬ê¸° ê¸°ëŠ¥
5. Histogram, Stack-based ì •ë‹µ ëˆ„ì 


### 1. ê´„í˜¸ì˜ ì§ ê²€ì‚¬
```kotlin
class Bracket {  
  
    /**  
     * ğŸ§ª 10-1-2. ìŠ¤íƒ â€“ ê°œë… ë¬¸ì œ  
     *  
     * ğŸ’¡ ë¬¸ì œ: ì˜¬ë°”ë¥¸ ê´„í˜¸  
     *  
     * ì„¤ëª…  
     * ë¬¸ìì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ, ëª¨ë“  ê´„í˜¸ê°€ ì˜¬ë°”ë¥´ê²Œ ì—´ê³  ë‹«í˜€ ìˆëŠ”ì§€ íŒë‹¨í•˜ì‹œì˜¤.  
     *  â€¢  ì…ë ¥: "(()())"  
     *  â€¢  ì¶œë ¥: "YES"  
     *  â€¢  ì…ë ¥: ")(()"  
     *  â€¢  ì¶œë ¥: "NO"  
     *   
     * â¸»  
     *  
     * âœ… ì¡°ê±´  
     *  â€¢  ê´„í˜¸ ì¢…ë¥˜ëŠ” ( ì™€ ) ë§Œ ìˆìŒ  
     *  â€¢  ê¸¸ì´ ìµœëŒ€ 100,000 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = ")(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = "()"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution4() {  
        val input = "(()())"  
        val expected = "YES"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution5() {  
        val input = ")("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution6() {  
        val input = "((("  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution7() {  
        val input = "(()"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution8() {  
        val input = "())"  
        val expected = "NO"  
        assertEquals(expected, useStack(input))  
    }  
  
  
    private fun useStack(input: String): String {  
        val stack = ArrayDeque<Char>()  
        val left = '('  
        var index = 0  
  
  
  
        while (index < input.length) {  
            val char = input[index++]  
  
            if (char == left) {  
                stack.addLast(char)  
                continue  
            }  
  
            if (stack.isEmpty()) {  
                return "NO"  
            }  
  
            stack.removeLast()  
        }  
  
        return if (stack.isEmpty()) "YES" else "NO"  
    }  
  
  
}
```

### 2. í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚°
```kotlin
class Postfix {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ í›„ìœ„ í‘œê¸°ì‹ ê³„ì‚° (ê¸°ì´ˆ ë²„ì „)  
     *     
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì¤‘ìœ„ í‘œê¸°ì‹(ì˜ˆ: 2 + 3)ì´ ì•„ë‹Œ í›„ìœ„ í‘œê¸°ì‹(Postfix, ì˜ˆ: 2 3 +)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ì´ë¥¼ ìŠ¤íƒì„ ì´ìš©í•´ì„œ ê³„ì‚°í•˜ì„¸ìš”.  
     *     
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ë¬¸ìì—´ë¡œ ëœ í›„ìœ„ í‘œê¸°ì‹ì´ í•œ ì¤„ì— ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  í”¼ì—°ì‚°ìëŠ” í•œ ìë¦¬ ìˆ«ì(0~9)ë¡œë§Œ ì£¼ì–´ì§€ë©°, ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
     *  â€¢  ì—°ì‚°ìëŠ” +, -, *, / ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.  
     *    
     * ì˜ˆ: "2 3 + 4 *"  
     * â†’ (2 + 3) * 4 = 20   
     *    
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ê³„ì‚° ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ì„¸ìš”. (ì •ìˆ˜ë§Œ)  
     *    
     * â¸»  
     *  
     * âœ… ì˜ˆì‹œ ì…ì¶œë ¥  
     *  
     * |ì…ë ¥ | ì¶œë ¥|  
     * |:---:|:---:|  
     * |2 3 + | 5|     
     * |2 3 + 4 * | 20|    
     * |5 1 2 + 4 * + 3 - | 14|   
     *    
     * */ 
    
    @Test  
    fun solution1() {  
        val input = listOf("2", "3", "+")  
        val expected = 5  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf("2", "3", "+", "4", "*")  
        val expected = 20  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf("5", "1", "2", "+", "4", "*", "+", "3", "-")  
        val expected = 14  
        /**  
         * 5 + (((1 + 2) * 4) - 3)   
         * */    
        
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<String>): Int {  
        val stack = ArrayDeque<Int>()  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
        val operator = listOf(plus, minus, multiply, divide)  
  
        for(element in input) {  
  
            if(operator.contains(element)) {  
                val first = stack.removeLast()  
                val second = stack.removeLast()  
                val result = calculate(element, second, first)  
                stack.addLast(result)  
            }  
            else {  
                stack.addLast(element.toInt())  
  
            }  
        }  
  
  
        return stack.removeLast()  
    }  
  
    private fun calculate(operator: String, prev:Int, next: Int): Int {  
        val plus = "+"  
        val minus = "-"  
        val multiply = "*"  
        val divide = "/"  
  
        return when (operator) {  
            plus -> prev + next;  
            minus -> prev - next;  
            multiply -> prev * next;  
            divide -> prev / next;  
            else -> prev  
        }  
    }  
}
```

### Histogram
```kotlin
class Histogram {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ ê°€ì¥ í° ì§ì‚¬ê°í˜• (Histogram)   
	 *    
	 * ğŸ’¡ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì„¸ë¡œì„ ì˜ ë†’ì´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì—°ì†ëœ ë§‰ëŒ€ë“¤ë¡œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ì§ì‚¬ê°í˜•ì˜ ë„“ì´ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * (ë‹¨, ëª¨ë“  ë§‰ëŒ€ì˜ ë„ˆë¹„ëŠ” 1ì…ë‹ˆë‹¤.)  
     *    
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ í˜•íƒœë¡œ nê°œì˜ ë§‰ëŒ€ ë†’ì´ê°€ ì£¼ì–´ì§  
     *  
     * ì˜ˆ: [2, 1, 5, 6, 2, 3]  
     *    
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì§ì‚¬ê°í˜• ë„“ì´ë¥¼ ì¶œë ¥  
     *  
     * â¸»  
     *  
     * ğŸ§® ì˜ˆì‹œ  
     *  
     * |ì…ë ¥|ì¶œë ¥|  
     * |:---:|:---:|    
     * |[2, 1, 5, 6, 2, 3]|10| 
     * |[2, 4]|4|    
     * |[6, 2, 5, 4, 5, 1, 6]|12| 
     *    
     * */  
     
    @Test  
    fun solution1() {  
        val input = listOf(2, 1, 5, 6, 2, 3)  
        val expected = 10  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution2() {  
        val input = listOf(2, 4)  
        val expected = 4  
        assertEquals(expected, useStack(input))  
    }  
  
    @Test  
    fun solution3() {  
        val input = listOf(6, 2, 5, 4, 5, 1, 6)  
        val expected = 12  
        assertEquals(expected, useStack(input))  
    }  
  
    private fun useStack(input: List<Int>): Int {  
        val extendedInput = List(input.size + 1) { input.getOrElse(it) { 0 } }  
        val stack = ArrayDeque<Int>()  
        var maxArea = 0  
  
  
        for (i in extendedInput.indices) {  
  
            while (stack.isNotEmpty() && extendedInput[i] < extendedInput[stack.last()]) {  
                val topIndex = stack.removeLast()  
                val height = extendedInput[topIndex]  
                val width = if (stack.isEmpty()) i else i - stack.last() - 1  
                maxArea = max(maxArea, width * height)  
            }  
  
            stack.addLast(i)  
        }  
  
        return maxArea  
    }  
}
```


# Queue
## 1. ì •ì˜ 
1. FIFO(First-In, First-Out) - ì„ ì… ì„ ì¶œ
2. ë¨¼ì € ë“¤ì–´ì˜¨ ë°ì´í„°ê°€ ë¨¼ì € ë‚˜ê°„ë‹¤.
## 2. êµ¬í˜„ ë°©ì‹
1. Kotlinì—ì„œëŠ” ArrayDequeueë¥¼ ì¼ë°˜ì ìœ¼ë¡œ ì„ íƒí•œë‹¤.
2. Javaì—ì„œëŠ” LinkedList\<T\>()ë¥¼ ì‚¬ìš©í•œë‹¤.

## 3. í™œìš© ì‚¬ë¡€
1. BFS
2. í”„ë¦°í„° ì¶œë ¥ ìˆœì„œ
3. RoundRobin
4. ìºì‹œ ë˜ëŠ” ìš”ì²­ í

### 1. ì¹´ë“œ ë½‘ê¸°
```kotlin
class DrawCard {  
    /**  
     * ğŸ“˜ ì‹¤ìŠµ ë¬¸ì œ â€“ ì¹´ë“œ ë½‘ê¸° ì‹œë®¬ë ˆì´ì…˜ (BOJ 2161 ë³€í˜•)  
     *    
     * â¸»  
     *  
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * 1ë¶€í„° Nê¹Œì§€ ë²ˆí˜¸ê°€ ì íŒ ì¹´ë“œê°€ 1ë²ˆì´ ì œì¼ ìœ„, Në²ˆì´ ì œì¼ ì•„ë˜ë¡œ ë†“ì—¬ ìˆìŠµë‹ˆë‹¤.  
     * ë‹¤ìŒ ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤:  
     *  1. ì œì¼ ìœ„ì— ìˆëŠ” ì¹´ë“œë¥¼ ë²„ë¦°ë‹¤  
     *  2. ê·¸ ë‹¤ìŒ ìœ„ì— ìˆëŠ” ì¹´ë“œë¥¼ ë§¨ ì•„ë˜ë¡œ ì˜®ê¸´ë‹¤  
     *  
     * ì´ ê³¼ì •ì„ ë°˜ë³µí•´ ì¹´ë“œê°€ í•œ ì¥ ë‚¨ì„ ë•Œê¹Œì§€ ì§„í–‰í–ˆì„ ë•Œ,  
     * ë²„ë¦° ì¹´ë“œë“¤ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ê³ , ë§ˆì§€ë§‰ ë‚¨ì€ ì¹´ë“œë„ ì¶œë ¥í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„ì— ì¹´ë“œì˜ ê°œìˆ˜ Nì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. (1 â‰¤ N â‰¤ 1000)  
     *   
     * ì˜ˆ:  
     * 7    
     *    
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„: ë²„ë¦° ì¹´ë“œ ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ ì¶œë ¥ (ê³µë°± êµ¬ë¶„)  
     *  â€¢  ë‘˜ì§¸ ì¤„: ë§ˆì§€ë§‰ì— ë‚¨ì€ ì¹´ë“œ ë²ˆí˜¸ ì¶œë ¥  
     *  
     * ì˜ˆ:  
     * 1 3 5 7 4 2 
     * 6   
     * */  
  
    @Test  
    fun solution() {  
        val size = 7  
        val expectedDiscarded = listOf(1,3,5,7,4,2)  
        val expectedResult = 6  
  
        val (resultDiscarded, resultNumber) = useQueue(size)  
  
        assertEquals(expectedDiscarded,resultDiscarded)  
        assertEquals(expectedResult, resultNumber)  
    }  
  
    private fun useQueue(size: Int): Pair<List<Int>, Int> {  
        val pile = ArrayDeque<Int>()  
        for( i in 1 .. size) {  
            pile.addLast(i)  
        }  
        var index = 0;  
        val discarded = mutableListOf<Int>()  
  
  
        while(pile.size != 1) {  
            val element = pile.removeFirst()  
            if( index%2==0) {  
                discarded.add(element)  
            }  
            else {  
                pile.addLast(element)  
            }  
  
            index ++  
        }  
  
        val pick = pile.removeFirst()  
  
        println(discarded)  
        println(pick)  
  
  
        return discarded to pick  
    }  
}
```


# Deque
## 1. ì •ì˜ 
- Double-Ended Queue: ì–‘ìª½ì—ì„œ ì‚½ì…ê³¼ ì‚­ì œê°€ ê°€ëŠ¥í•œ ì–‘ë°©í–¥ í
## 2. êµ¬í˜„ ë°©ì‹
 - KTì—ì„œ ArrayDeque
 - Javaì—ì„œ LinkedList
## 3. í™œìš© ì‚¬ë¡€
1. ìŠ¬ë¼ì´ë”© ë¬¸ì œ
2. AC ë¬¸ì œ
3. 0-1 BFS

#### 1. ìŠ¬ë¼ì´ë”© ìœˆë„ìš°
```kotlin
class BasicSlidingWindow {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ìµœì†Ÿê°’ (ì •ì„, ì¼ë°˜ì  ìŠ¤íƒ€ì¼)  
     *     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ numsì™€ ì •ìˆ˜ kê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ê¸¸ì´ kì˜ ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œ ì¹¸ì”© ì´ë™ì‹œí‚¤ë©´ì„œ,  
     * ê° ìœˆë„ìš°ì—ì„œ ìµœì†Ÿê°’ì„ êµ¬í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜í•˜ì„¸ìš”.  
     *     
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ nums: ê¸¸ì´ N (1 â‰¤ N â‰¤ 10â¶)  
     *  â€¢  ìœˆë„ìš° í¬ê¸° k: 1 â‰¤ k â‰¤ N 
     *    
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ê° ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì˜ ìµœì†Ÿê°’ì„ ìˆœì„œëŒ€ë¡œ ë‹´ì€ ì •ìˆ˜ ë¦¬ìŠ¤íŠ¸  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì œ 1   
     *    
     * ì…ë ¥:  
     * nums = [1, 3, -1, -3, 5, 3, 6, 7]   
     * k = 3    
     * ì¶œë ¥:  
     * [-1, -3, -3, -3, 3, 3]    
     * */  
  
    @Test  
    fun solution(){  
        val numbs = intArrayOf(1, 3, -1, -3, 5, 3, 6, 7)  
        val windowSize = 3  
        val expected = intArrayOf(-1, -3, -3, -3, 3, 3)  
  
        assertArrayEquals(expected, useSlidingWindow(numbs, windowSize))  
    }  
  
  
    private fun useSlidingWindow(number: IntArray, windowSize: Int): IntArray {  
        val resultList = mutableListOf<Int>()  
        val deque = ArrayDeque<Int>()  
  
        for(i in number.indices) {  
            while(deque.isNotEmpty() && deque.first() <= i - windowSize) {  
                deque.removeFirst()  
            }  
            while(deque.isNotEmpty() && number[deque.last()] >= number[i]){  
                deque.removeLast()  
            }  
  
            deque.addLast(i)  
            if(i - windowSize + 1 >= 0){  
                resultList.add(number[deque.first()])  
            }  
  
        }  
  
  
  
        return resultList.toIntArray()  
    }  
}
```

#### 2. AC(ArrayControll)
```kotlin
class AC {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: AC (BOJ 5430 ë³€í˜•)  
     *     
     * ğŸ§¾ ë¬¸ì œ ì„¤ëª…  
     * R(ë’¤ì§‘ê¸°)ê³¼ D(ë²„ë¦¬ê¸°)ë¡œ ì´ë£¨ì–´ì§„ ëª…ë ¹ì–´ ë¬¸ìì—´ê³¼, ì •ìˆ˜ ë°°ì—´ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ëª…ë ¹ì–´ë¥¼ ì•ì—ì„œë¶€í„° ìˆœì„œëŒ€ë¡œ ìˆ˜í–‰í•˜ë©´ì„œ ë°°ì—´ì— ë³€í™”ë¥¼ ì ìš©í•˜ì„¸ìš”.  
     * ë‹¨, ë°°ì—´ì´ ë¹„ì–´ìˆì„ ë•Œ D ëª…ë ¹ì–´ê°€ ë“¤ì–´ì˜¤ë©´ ì—ëŸ¬ê°€ ë°œìƒí•©ë‹ˆë‹¤.  
     *     
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ T (1 â‰¤ T â‰¤ 100)     
     *  â€¢  ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤:  
     *  â€¢  ëª…ë ¹ì–´ ë¬¸ìì—´ p (ê¸¸ì´ 1 â‰¤ p â‰¤ 100,000)    
     *  â€¢  ì •ìˆ˜ n (0 â‰¤ n â‰¤ 100,000)     
     *  â€¢  ë°°ì—´: [xâ‚,xâ‚‚,â€¦,xâ‚™] í˜•ì‹ì˜ ë¬¸ìì—´  
     *  
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ëª…ë ¹ì–´ ìˆ˜í–‰ ê²°ê³¼ ë°°ì—´ì„ ë¬¸ìì—´ë¡œ ì¶œë ¥  
     *  â€¢  ì—ëŸ¬ ë°œìƒ ì‹œ "error" ì¶œë ¥  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì œ  
     *  
     * ì…ë ¥:  
     * 4    
     * --- ì˜ˆì œ 1    
     * ëª…ë ¹ì–´: RDD  
     * ë°°ì—´ ê¸¸ì´: 4  
     * ë°°ì—´: [1,2,3,4]  
     *     
     * --- ì˜ˆì œ 2    
     * ëª…ë ¹ì–´: DD  
     * ë°°ì—´ ê¸¸ì´: 1  
     * ë°°ì—´: [42]  
     *     
     * --- ì˜ˆì œ 3   
	 * ëª…ë ¹ì–´: RRD  
     * ë°°ì—´ ê¸¸ì´: 6  
     * ë°°ì—´: [1,1,2,3,5,8]  
     *     
     * --- ì˜ˆì œ 4   
     * ëª…ë ¹ì–´: D  
     * ë°°ì—´ ê¸¸ì´: 0  
     * ë°°ì—´: []  
     *     
     * ì¶œë ¥:  
     * --- ì¶œë ¥ 1     
     * [2,1]     
     *     
     * --- ì¶œë ¥ 2    
     * error    
     *    
     * --- ì¶œë ¥ 3    
     * [1,2,3,5,8]   
     *    
     * --- ì¶œë ¥ 4    
     * error   
     * */  
 
    @Test  
    fun solution1() {  
        val command = "RDD"  
        val arraySize = 4  
        val array = intArrayOf(1,2,3,4)  
        val expected = intArrayOf(2,1).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution2() {  
        val command = "DD"  
        val arraySize = 1  
        val array = intArrayOf(42)  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution3() {  
        val command = "D"  
        val arraySize = 6  
        val array = intArrayOf(1,1,2,3,5,8)  
        val expected = intArrayOf(1,2,3,5,8).contentToString()  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    @Test  
    fun solution4() {  
        val command = "RDD"  
        val arraySize = 0  
        val array = intArrayOf()  
        val expected = "error"  
        assertEquals(expected, useDeque(command, array))  
    }  
  
    private fun useDeque(command: String, array: IntArray): String {  
        val deque = ArrayDeque<Int>()  
        val result = mutableListOf<Int>()  
        var leftToRight = true  
        val reverse = 'R'  
        val delete = 'D'  
  
        for(element in array) {  
            deque.addLast(element)  
        }  
  
        for(element in command) {  
            when(element) {  
                reverse -> leftToRight = !leftToRight  
                delete -> {  
                    if(deque.isEmpty()) return "error"  
  
                    if(leftToRight){  
                        deque.removeFirst()  
                    } 
                    else {  
                        deque.removeLast()  
                    }
				}  
            }  
        }  
  
        while(deque.isNotEmpty()) {  
            if(leftToRight) {  
                result.add(deque.removeFirst())  
            }  
            else {  
                result.add(deque.removeLast())  
            }  
        }  
  
  
        return result.toIntArray().contentToString()  
    }  
}
```

