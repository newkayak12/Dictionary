# 핵심 아이디어
- 해시를 이용한 문자열 패턴 매칭
	- BruteForce: `O(mn)` -> Rabin-Karp: `O(m + n)`
	- 롤링 해시로 효율적인 해시 계산

# 기본 개념
1. 문제 상황
	1. 문자열에서 패턴을 찾는 문제:
		1. 텍스트: "AABAACAADAABAABA"
		2. 패턴: "AABA"
		3. 찾기: 패턴이 나타나는 모든 위치
2. 기존 방법
	1. BruteForce로 하나씩 비교
3. 라빈-카프
	1. 해시를 이용
		1. 문자열을 숫자로 변환
		2. 해시 값이 같으면 -> 실제 문자열 비교
		3. 해시 값이 다르면 -> 패스

# 상세 개념
1. 해시 함수
	1. 문자열을 숫자로 바꾸는 방법
	   `"AABA" -> A*31³ + A*31² + B*31¹ + A*31⁰`
	2. 롤링 해시 
	   다음 위치로 넘어갈 때 재계산 하지 않고 O(1)에 계산
	   `"AABA" -> "ABAC"`
	   새로운 해시 = (기존 해시 - 첫 글자 * 31³) * 31 + 새 글자
2. 해시 충돌 처리
   : 해시 값이 같아도 실제 문자열이 다를 수 있다. -> 실제 비교가 필요하다.
3. MOD
   : 큰 숫자 방지를 위해서 모든 계산에 `% MOD` 적용


# 예시 구현
```kotlin
class RabinKarp {  
    /**  
     * 🎯 라빈-카프 기본 문제: "문자열 찾기"  
     * 주어진 텍스트에서 패턴 문자열이 나타나는 첫 번째 위치를 찾아라.  
     * (못 찾으면 -1 반환)  
     * 입력:  
     * kotlintext = "ABABCABABA"    
     * pattern = "ABAB"     
     * 출력: 0 (첫 번째 "ABAB"가 인덱스 0에서 시작)  
     */  
    @Test  
    fun solution() {  
        val kotlinText = "ABABCABABA"  
        val pattern = "ABAB"  
        val expected = 0  
  
        assertEquals(expected, rabinKarp(kotlinText, pattern))  
    }  
  
    private fun calculateHash(string: String): Long {  
        val base = 31  
        var hash = 0L  
        val charA = 'A'  
        val mod = 1000000007  
  
        for (char in string) {  
            hash = (hash * base + (char - charA + 1))  
        }  
  
        return hash % mod  
  
    }  
  
    private fun rabinKarp(kotlinText: String, pattern: String): Int {  
        val patternHash = calculateHash(pattern)  
        var windowHash = calculateHash(kotlinText.substring(0, pattern.length))  
        val base = 31  
        val charA = 'A'  
        val mod = 1000000007  
  
        for (i in 0..kotlinText.length - pattern.length) {  
            val substring = kotlinText.substring(i, i + pattern.length)  
            if (patternHash == windowHash && pattern == substring) {  
                return i  
            }  
  
            if (i < kotlinText.length - pattern.length) {  
                val power = base.toDouble().pow(pattern.length - 1).toLong()  
                val oldChar = (kotlinText[i] - charA + 1).toLong()  
                val newChar = (kotlinText[i + pattern.length] - charA + 1)  
                windowHash = ((windowHash - oldChar * power) * base + newChar) % mod  
            }  
        }  
  
  
        return -1  
    }  
}

```
### 호너의 방법
```kotlin
// 초기값
hash = 0

// 1단계: A 처리
hash = (0 * 31 + 1) = 1
// 현재 hash = 1

// 2단계: B 처리  
hash = (1 * 31 + 2) = 33
// 현재 hash = 1*31 + 2 = 33

// 3단계: C 처리
hash = (33 * 31 + 3) = 1026
// 현재 hash = (1*31 + 2)*31 + 3 = 1*31² + 2*31 + 3

// 4단계: D 처리
hash = (1026 * 31 + 4) = 31810  
// 현재 hash = ((1*31 + 2)*31 + 3)*31 + 4
//           = 1*31³ + 2*31² + 3*31 + 4
```


# 예시
## 중복 문자열 찾기
```kotlin
  
class FindDuplicatedWord {  
    /**  
     * 🎯 라빈-카프 기본 문제 2번: "중복 문자열 찾기"  
     * 주어진 문자열에서 길이가 K인 부분 문자열 중에 2번 이상 나타나는 문자열을 모두 찾아라.  
     * 입력:  
     * kotlintext = "ABCABCABC"     
     * k = 3    
     * 출력: ["ABC", "BCA", "CAB"] (길이 3인 부분문자열 중 중복되는 것)  
     *     
     * 다른 예:  
     * kotlintext = "AABAABA"  
     * k = 3   
     * 출력: ["AAB", "ABA"]  
     */  
    
    @Test  
    fun solution1() {  
        val kotlinText = "ABCABCABC"  
        val k = 3  
        val expected = arrayOf("ABC", "BCA", "CAB")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
  
    @Test  
    fun solution2() {  
        val kotlinText = "AABAABA"  
        val k = 3  
        val expected = arrayOf("AAB", "ABA")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
    @Test  
    fun solution3() {  
        val kotlinText = "AABAACAAB"  
        val k = 3  
        val expected = arrayOf("AAB")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
  
    private fun rabinKarp(kotlinText: String, patternSize: Int): Array<String> {  
        val patternSet = mutableMapOf<Long, MutableList<String>>()  
        var hash = calculateHash(kotlinText.substring(0, patternSize))  
        patternSet.getOrPut(hash) { mutableListOf() }.add(kotlinText.substring(0, patternSize))  
  
        for (i in 1..kotlinText.length - patternSize) {  
            hash = rollHash(hash, kotlinText[i - 1], kotlinText[i + patternSize - 1], patternSize)  
            val substring = kotlinText.substring(i, i + patternSize)  
            patternSet.getOrPut(hash) { mutableListOf() }.add(substring)  
        }  
  
        return patternSet.values.filter { it.size > 1 }.flatten().distinct().toTypedArray()  
    }  
  
  
    private fun rollHash(hash: Long, oldChar: Char, newChar: Char, patternSize: Int): Long {  
        val charA = 'A'  
        var mod = 1000000007  
        val base = 31  
        val oldCharHash = (oldChar - charA + 1).toLong()  
        val newCharHash = (newChar - charA + 1).toLong()  
  
        val power = base.toDouble().pow(patternSize - 1).toLong()  
  
        return ((hash - oldCharHash * power) * base + newCharHash) % mod  
    }

	private fun calculateHash(word: String): Long {  
	    var hash = 0L  
	    val base = 31  
	    var mod = 1000000007  
	    val charA = 'A'  
	  
	    for (char in word) {  
	        hash = (hash * base + (char - charA + 1))  
	    }  
	  
	  
	    return hash % mod  
	}
}
```