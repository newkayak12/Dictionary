# í•µì‹¬ ì•„ì´ë””ì–´
- í•´ì‹œë¥¼ ì´ìš©í•œ ë¬¸ìì—´ íŒ¨í„´ ë§¤ì¹­
	- BruteForce: `O(mn)` -> Rabin-Karp: `O(m + n)`
	- ë¡¤ë§ í•´ì‹œë¡œ íš¨ìœ¨ì ì¸ í•´ì‹œ ê³„ì‚°

# ê¸°ë³¸ ê°œë…
1. ë¬¸ì œ ìƒí™©
	1. ë¬¸ìì—´ì—ì„œ íŒ¨í„´ì„ ì°¾ëŠ” ë¬¸ì œ:
		1. í…ìŠ¤íŠ¸: "AABAACAADAABAABA"
		2. íŒ¨í„´: "AABA"
		3. ì°¾ê¸°: íŒ¨í„´ì´ ë‚˜íƒ€ë‚˜ëŠ” ëª¨ë“  ìœ„ì¹˜
2. ê¸°ì¡´ ë°©ë²•
	1. BruteForceë¡œ í•˜ë‚˜ì”© ë¹„êµ
3. ë¼ë¹ˆ-ì¹´í”„
	1. í•´ì‹œë¥¼ ì´ìš©
		1. ë¬¸ìì—´ì„ ìˆ«ìë¡œ ë³€í™˜
		2. í•´ì‹œ ê°’ì´ ê°™ìœ¼ë©´ -> ì‹¤ì œ ë¬¸ìì—´ ë¹„êµ
		3. í•´ì‹œ ê°’ì´ ë‹¤ë¥´ë©´ -> íŒ¨ìŠ¤

# ìƒì„¸ ê°œë…
1. í•´ì‹œ í•¨ìˆ˜
	1. ë¬¸ìì—´ì„ ìˆ«ìë¡œ ë°”ê¾¸ëŠ” ë°©ë²•
	   `"AABA" -> A*31Â³ + A*31Â² + B*31Â¹ + A*31â°`
	2. ë¡¤ë§ í•´ì‹œ 
	   ë‹¤ìŒ ìœ„ì¹˜ë¡œ ë„˜ì–´ê°ˆ ë•Œ ì¬ê³„ì‚° í•˜ì§€ ì•Šê³  O(1)ì— ê³„ì‚°
	   `"AABA" -> "ABAC"`
	   ìƒˆë¡œìš´ í•´ì‹œ = (ê¸°ì¡´ í•´ì‹œ - ì²« ê¸€ì * 31Â³) * 31 + ìƒˆ ê¸€ì
2. í•´ì‹œ ì¶©ëŒ ì²˜ë¦¬
   : í•´ì‹œ ê°’ì´ ê°™ì•„ë„ ì‹¤ì œ ë¬¸ìì—´ì´ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤. -> ì‹¤ì œ ë¹„êµê°€ í•„ìš”í•˜ë‹¤.
3. MOD
   : í° ìˆ«ì ë°©ì§€ë¥¼ ìœ„í•´ì„œ ëª¨ë“  ê³„ì‚°ì— `% MOD` ì ìš©


# ì˜ˆì‹œ êµ¬í˜„
```kotlin
class RabinKarp {  
    /**  
     * ğŸ¯ ë¼ë¹ˆ-ì¹´í”„ ê¸°ë³¸ ë¬¸ì œ: "ë¬¸ìì—´ ì°¾ê¸°"  
     * ì£¼ì–´ì§„ í…ìŠ¤íŠ¸ì—ì„œ íŒ¨í„´ ë¬¸ìì—´ì´ ë‚˜íƒ€ë‚˜ëŠ” ì²« ë²ˆì§¸ ìœ„ì¹˜ë¥¼ ì°¾ì•„ë¼.  
     * (ëª» ì°¾ìœ¼ë©´ -1 ë°˜í™˜)  
     * ì…ë ¥:  
     * kotlintext = "ABABCABABA"    
     * pattern = "ABAB"     
     * ì¶œë ¥: 0 (ì²« ë²ˆì§¸ "ABAB"ê°€ ì¸ë±ìŠ¤ 0ì—ì„œ ì‹œì‘)  
     */  
    @Test  
    fun solution() {  
        val kotlinText = "ABABCABABA"  
        val pattern = "ABAB"  
        val expected = 0  
  
        assertEquals(expected, rabinKarp(kotlinText, pattern))  
    }  
  
    private fun calculateHash(string: String): Long {  
        val base = 31  
        var hash = 0L  
        val charA = 'A'  
        val mod = 1000000007  
  
        for (char in string) {  
            hash = (hash * base + (char - charA + 1))  
        }  
  
        return hash % mod  
  
    }  
  
    private fun rabinKarp(kotlinText: String, pattern: String): Int {  
        val patternHash = calculateHash(pattern)  
        var windowHash = calculateHash(kotlinText.substring(0, pattern.length))  
        val base = 31  
        val charA = 'A'  
        val mod = 1000000007  
  
        for (i in 0..kotlinText.length - pattern.length) {  
            val substring = kotlinText.substring(i, i + pattern.length)  
            if (patternHash == windowHash && pattern == substring) {  
                return i  
            }  
  
            if (i < kotlinText.length - pattern.length) {  
                val power = base.toDouble().pow(pattern.length - 1).toLong()  
                val oldChar = (kotlinText[i] - charA + 1).toLong()  
                val newChar = (kotlinText[i + pattern.length] - charA + 1)  
                windowHash = ((windowHash - oldChar * power) * base + newChar) % mod  
            }  
        }  
  
  
        return -1  
    }  
}

```
### í˜¸ë„ˆì˜ ë°©ë²•
```kotlin
// ì´ˆê¸°ê°’
hash = 0

// 1ë‹¨ê³„: A ì²˜ë¦¬
hash = (0 * 31 + 1) = 1
// í˜„ì¬ hash = 1

// 2ë‹¨ê³„: B ì²˜ë¦¬  
hash = (1 * 31 + 2) = 33
// í˜„ì¬ hash = 1*31 + 2 = 33

// 3ë‹¨ê³„: C ì²˜ë¦¬
hash = (33 * 31 + 3) = 1026
// í˜„ì¬ hash = (1*31 + 2)*31 + 3 = 1*31Â² + 2*31 + 3

// 4ë‹¨ê³„: D ì²˜ë¦¬
hash = (1026 * 31 + 4) = 31810  
// í˜„ì¬ hash = ((1*31 + 2)*31 + 3)*31 + 4
//           = 1*31Â³ + 2*31Â² + 3*31 + 4
```


# ì˜ˆì‹œ
## ì¤‘ë³µ ë¬¸ìì—´ ì°¾ê¸°
```kotlin
  
class FindDuplicatedWord {  
    /**  
     * ğŸ¯ ë¼ë¹ˆ-ì¹´í”„ ê¸°ë³¸ ë¬¸ì œ 2ë²ˆ: "ì¤‘ë³µ ë¬¸ìì—´ ì°¾ê¸°"  
     * ì£¼ì–´ì§„ ë¬¸ìì—´ì—ì„œ ê¸¸ì´ê°€ Kì¸ ë¶€ë¶„ ë¬¸ìì—´ ì¤‘ì— 2ë²ˆ ì´ìƒ ë‚˜íƒ€ë‚˜ëŠ” ë¬¸ìì—´ì„ ëª¨ë‘ ì°¾ì•„ë¼.  
     * ì…ë ¥:  
     * kotlintext = "ABCABCABC"     
     * k = 3    
     * ì¶œë ¥: ["ABC", "BCA", "CAB"] (ê¸¸ì´ 3ì¸ ë¶€ë¶„ë¬¸ìì—´ ì¤‘ ì¤‘ë³µë˜ëŠ” ê²ƒ)  
     *     
     * ë‹¤ë¥¸ ì˜ˆ:  
     * kotlintext = "AABAABA"  
     * k = 3   
     * ì¶œë ¥: ["AAB", "ABA"]  
     */  
    
    @Test  
    fun solution1() {  
        val kotlinText = "ABCABCABC"  
        val k = 3  
        val expected = arrayOf("ABC", "BCA", "CAB")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
  
    @Test  
    fun solution2() {  
        val kotlinText = "AABAABA"  
        val k = 3  
        val expected = arrayOf("AAB", "ABA")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
    @Test  
    fun solution3() {  
        val kotlinText = "AABAACAAB"  
        val k = 3  
        val expected = arrayOf("AAB")  
        assertArrayEquals(expected, rabinKarp(kotlinText, k))  
    }  
  
  
    private fun rabinKarp(kotlinText: String, patternSize: Int): Array<String> {  
        val patternSet = mutableMapOf<Long, MutableList<String>>()  
        var hash = calculateHash(kotlinText.substring(0, patternSize))  
        patternSet.getOrPut(hash) { mutableListOf() }.add(kotlinText.substring(0, patternSize))  
  
        for (i in 1..kotlinText.length - patternSize) {  
            hash = rollHash(hash, kotlinText[i - 1], kotlinText[i + patternSize - 1], patternSize)  
            val substring = kotlinText.substring(i, i + patternSize)  
            patternSet.getOrPut(hash) { mutableListOf() }.add(substring)  
        }  
  
        return patternSet.values.filter { it.size > 1 }.flatten().distinct().toTypedArray()  
    }  
  
  
    private fun rollHash(hash: Long, oldChar: Char, newChar: Char, patternSize: Int): Long {  
        val charA = 'A'  
        var mod = 1000000007  
        val base = 31  
        val oldCharHash = (oldChar - charA + 1).toLong()  
        val newCharHash = (newChar - charA + 1).toLong()  
  
        val power = base.toDouble().pow(patternSize - 1).toLong()  
  
        return ((hash - oldCharHash * power) * base + newCharHash) % mod  
    }

	private fun calculateHash(word: String): Long {  
	    var hash = 0L  
	    val base = 31  
	    var mod = 1000000007  
	    val charA = 'A'  
	  
	    for (char in word) {  
	        hash = (hash * base + (char - charA + 1))  
	    }  
	  
	  
	    return hash % mod  
	}
}
```