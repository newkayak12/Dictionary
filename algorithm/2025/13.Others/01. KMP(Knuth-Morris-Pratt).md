# 정의
- 문자열 패턴 매칭을 위한 효율적인 알고리즘
- 전처리를 통한 검색 최적화 방식

# 핵심 특징
- **시간 복잡도**: O(n+m) - (n: 텍스트 길이, m: 패턴 길이)
- **공간 복잡도**: O(m) - 패턴 크기만큼 전처리 배열 필요
- 전처리 + 검색 -> 2단계 구조
# BruteForce vs. KMP
- BruteForce: O(nm)
- KMP: O(n+m)

# 언제 사용하나?
- 긴 텍스트에서 패턴 검색
- 텍스트 에디터의 검색 기능
- DNA 서열 분석
- 로그 파일 분석

# 핵심 구성 요소

## 1. 접두사 배열
### 정의
- 문자열에서 접두사와 접미사가 일치하는 최대 길이를 저장하는 배열
- **KMP 알고리즘**의 핵심 기반
- **실패 테이블(Failure Table)** 이라고도 한다.
### 핵심 아이디어

문자열 `"abcabcab"`에서:

- 인덱스 5: `"abcab"` → 접두사 `"ab"`와 접미사 `"ab"` 일치 (길이 2)
- 인덱스 6: `"abcabc"` → 접두사 `"abc"`와 접미사 `"abc"` 일치 (길이 3)
### 용도

- **패턴 검색 최적화**
- **문자열 반복 구조 분석**
- **부분 문자열 관계 파악**

### 예시
```text
문자열: "ababa"

prefix[0] = 0  (단일 문자는 항상 0)
prefix[1] = 0  ("ab" → 접두사"a" vs 접미사"b" → 불일치)
prefix[2] = 1  ("aba" → 접두사"a" vs 접미사"a" → 일치, 길이 1)
prefix[3] = 2  ("abab" → 접두사"ab" vs 접미사"ab" → 일치, 길이 2)
prefix[4] = 3  ("ababa" → 접두사"aba" vs 접미사"aba" → 일치, 길이 3)

결과: [0, 0, 1, 2, 3]
```

# 구현
```kotlin
  
class KMP {  
  
    fun computePrefix(pattern: String): IntArray {  
        val n = pattern.length  
        val prefix = IntArray(n)  
        var j = 0 //현재까지 일치한 접두사 길이  
  
        for(i in 1 until n) { // 접미사 끝 위치  
  
            //불일치 시 이전 일치점으로 되돌아가기  
            while(j > 0 && pattern[i] != pattern[j]) {  
                j = prefix[j - 1] //되돌아갈 위치  
            }  
  
            //현재 문자가 일치하면 길이 증가  
            if(pattern[i] == pattern[j]) {  
                j ++ //길이 일치 ++            }  
  
            prefix[i] = j // i번째까지의 부분문자열에서 최대 일치 길이  
        }  
  
        return prefix  
    }  
///////
// a b a b a b c a b
// 0 0 1 2 3 4 0 1 2
// -> 돌아갈 지점
    fun kmp(text: String, pattern: String): List<Int> {  
        val prefix = computePrefix(pattern)  
        val result = mutableListOf<Int>()  
  
        var j = 0 //  패턴 포인터  
  
        for( i in text.indices) {//텍스트 포인터  
            //불일치 시 패턴 포인터 조정  
            while(j > 0 && text[i] != pattern[j]) {  
                j = prefix[j - 1]  
            }  
  
            // 일치하면 패턴 포인터 증가  
            if(text[i]== pattern[j]) {  
                j ++  
            }  
            // 패턴 완전 매칭 시  
            if (j == pattern.length) {  
                result.add(i - pattern.length + 1)  // 시작 위치 저장  
                j = prefix[j - 1]  // 다음 패턴 찾기 위해 조정  
            }  
        }  
  
        return result  
    }  
}
```