# ì •ì˜
- ë¬¸ìì—´ ì§‘í•©ì„ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ì €ì¥í•˜ëŠ” ìë£Œêµ¬ì¡°
- reTRIEvalì—ì„œ ìœ ë˜

# í•µì‹¬ ì•„ì´ë””ì–´
- ê³µí†µ ì ‘ë‘ì‚¬ë¥¼ ê°€ì§„ ë¬¸ìì—´ë“¤ì´ ê²½ë¡œë¥¼ ê³µìœ 
- ê° ë…¸ë“œëŠ” í•˜ë‚˜ì˜ ë¬¸ìë¥¼ ë‚˜íƒ€ëƒ„
- ë£¨íŠ¸ì—ì„œ ë¦¬í”„ê¹Œì§€ì˜ ê²½ë¡œ = í•˜ë‚˜ì˜ ë¬¸ìì—´

# ê¸°ë³¸ êµ¬ì¡°
```text
ë¬¸ìì—´ ì§‘í•©: ["CAR", "CARD", "CARE", "CAT"]

        ROOT
         |
         C
         |
         A
        / \
       R   T
      /|\   \
     D E $   $
     | |
     $ $
```

# ì„±ì§ˆ
1. ì ‘ë‘ì‚¬ ê³µìœ 
2. ë©”ëª¨ë¦¬ ì ˆì•½
3. ì ‘ë‘ì‚¬ ê²€ìƒ‰

# ê¸°ë³¸ êµ¬í˜„
```kotlin

  
class TrieNode {  
    val children = mutableMapOf<Char, TrieNode>()  
    var isEndOfWord = false  
}  
  
class Trie {  
    private val root = TrieNode()  
  
    fun insert(word: String) {  
        var current = root  
        for (char in word) {  
            if (!current.children.containsKey(char)) {  
                current.children.getOrPut(char) { TrieNode() }  
            }  
            current = current.children[char]!!  
        }  
        current.isEndOfWord = true  
    }  
  
    fun search(word: String): Boolean {  
        var current = root  
        for (char in word) {  
            if (!current.children.containsKey(char)) {  
                return false  
            }  
            current = current.children[char]!!  
        }  
        return current.isEndOfWord  
    }  
  
    fun startsWith(prefix: String): Boolean {  
        var current = root  
        for (char in prefix) {  
            if (!current.children.containsKey(char)) {  
                return false  
            }  
            current = current.children[char]!!  
        }  
        return true  
    }  
  
    fun delete(word: String) {  
        deleteHelper(root, word, 0)  
    }  
  
    //ì‚­ì œê°€ ë³µì¡í•œ ì´ìœ ëŠ”?  
    /**  
     * CARD ì €ì¥  
     * CAR ì‚­ì œ -> ì´ ê²½ìš° CARë¥¼ ê·¸ëƒ¥ ì§€ìš¸ ìˆ˜ ì—†ìŒ  
     */  
    private fun deleteHelper(node: TrieNode, word: String, index: Int): Boolean {  
  
        if (index == word.length) {  
            if (!node.isEndOfWord) return false  
            node.isEndOfWord = false  
            return node.children.isEmpty()  
        }  
  
        val char = word[index]  
        val childNode = node.children[char] ?: return false  
        val shouldDeleteChild = deleteHelper(childNode, word, index + 1)  
  
        if (shouldDeleteChild) {  
            node.children.remove(char)  
            return !node.isEndOfWord && node.children.isEmpty()  
        }  
  
        return false  
    }  
  
    fun findWordsWithPrefix(prefix: String): List<String> { //ìë™ì™„ì„±?  
        val result = mutableListOf<String>()  
        var current = root  
  
        for(char in prefix) {  
            if(!current.children.containsKey(char)) {  
                return emptyList()  
            }  
            current = current.children[char]!!  
        }  
        dfs(current, prefix, result)  
        return result  
    }  
  
  
    private fun dfs(node: TrieNode, currentWord: String, result: MutableList<String>) {  
        if(node.isEndOfWord){  
            result.add(currentWord)  
        }  
        for ((char, childNode) in node.children) {  
            dfs(childNode, currentWord + char, result)  
        }  
    }  
}
```


# ì˜ˆì‹œ ë¬¸ì œ
## ìë™ì™„ì„±

```kotlin
class AutoComplete {  
    /**  
     * ğŸŒ³ íŠ¸ë¼ì´ ê¸°ë³¸ ë¬¸ì œ 1ë²ˆ: "ìë™ì™„ì„±"  
     * ë¬¸ì œ:  
     * í¬í„¸ ë‹¤ìŒì—ì„œ ê²€ìƒ‰ì–´ ìë™ì™„ì„± ê¸°ëŠ¥ì„ ë§Œë“ ë‹¤ê³  ê°€ì •í•´ë´…ì‹œë‹¤.  
     * ì‚¬ìš©ìê°€ typingí•œ ë¬¸ìì—´ì— ëŒ€í•´ì„œ, ì›ë˜ ì…ë ¥í•˜ë ¤ë˜ ë‹¨ì–´ê¹Œì§€ ì´ ëª‡ ë²ˆì˜ ë¬¸ìë¥¼ ì…ë ¥í•´ì•¼ í•˜ëŠ”ì§€ ê³„ì‚°í•´ì£¼ì„¸ìš”.  
     * ì¡°ê±´:  
     *     
     * í•™ìŠµëœ ë‹¨ì–´ë“¤ê³¼ ê²€ìƒ‰ì–´ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤  
     * ë‹¨ì–´ëŠ” 2ê¸€ì ì´ìƒ 100ê¸€ì ì´í•˜ì…ë‹ˆë‹¤  
     * ì‚¬ìš©ìëŠ” ìë™ì™„ì„±ë˜ëŠ” ë¶€ë¶„ì—ì„œ ë°”ë¡œ ì—”í„°ë¥¼ ì¹©ë‹ˆë‹¤  
     * ë‹¤ë¥¸ ë‹¨ì–´ì˜ ì ‘ë‘ì‚¬ì¸ ê²½ìš°ì—ë„ í•´ë‹¹ ì‹œì ì—ì„œ ìë™ì™„ì„±ì„ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤  
     *  
     * ì…ì¶œë ¥ ì˜ˆ:  
     * kotlinwords = arrayOf("go", "gone", "guild")    
     * queries = arrayOf("go", "gon", "gui")    
     * // ê²°ê³¼: [2, 3, 2]  
     * ì„¤ëª…:  
     *   
     * "go": 'g'ë§Œ ì³ë„ 'o' ì…ë ¥ ì „ì— ì´ë¯¸ ìë™ì™„ì„±ìœ¼ë¡œ "go"ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŒ â†’ 1ë²ˆ  
     * "gon": 'g'ë§Œ ì³ë„ ìë™ì™„ì„±ìœ¼ë¡œ "gone"ë¥¼ ì„ íƒí•  ìˆ˜ ìˆìŒ â†’ 1ë²ˆ  
     * "gui": "go", "gone"ê³¼ êµ¬ë¶„ë˜ë ¤ë©´ "gui"ê¹Œì§€ ëª¨ë‘ ì…ë ¥í•´ì•¼ í•¨ â†’ 3ë²ˆ  
     */  
  
    @Test  
    fun solution() {  
        val kotlinWords = arrayOf("go", "gone", "guild")  
        val queries = arrayOf("go", "gon", "gui")  
        val result = arrayOf(2, 3, 2)  
  
        assertArrayEquals(result, useTrie(kotlinWords, queries))  
    }  
  
    private fun useTrie(kotlinWords: Array<String>, queries: Array<String>): Array<Int> {  
        val trie = Trie()  
        val array = Array(queries.size){-1}  
        for(element in kotlinWords){  
            trie.insert(element)  
        }  
  
  
        for((index, value) in queries.withIndex()) {  
            var word = ""  
  
            for((charIndex, charValue) in value.withIndex()) {  
                word += charValue  
  
                val list = trie.findWordsWithPrefix(word)  
  
                if( list.size ==  1 || (list.contains(word) && word == value)) {  
                    array[index] = charIndex + 1  
                    break  
                }  
            }  
        }  
  
  
        return array  
    }  
  
    private inner class TrieNode {  
        val children = mutableMapOf<Char, TrieNode>()  
        var isEndOfWord = false  
    }  
  
    private inner class Trie {  
        val root = TrieNode()  
  
        fun insert(word: String) {  
            var current = root  
            for (char in word) {  
                if (!current.children.containsKey(char)) {  
                    current.children.getOrPut(char) { TrieNode() }  
                }  
  
                current = current.children[char]!!  
            }  
  
            current.isEndOfWord = true  
        }  
  
        fun search(word: String): Boolean {  
            var current = root  
            for (char in word) {  
                if (!current.children.containsKey(char)) {  
                    return false  
                }  
  
                current = current.children[char]!!  
            }  
  
            return current.isEndOfWord  
        }  
  
        fun startWith(prefix: String): Boolean {  
            var current = root  
            for (char in prefix) {  
                if (!current.children.containsKey(char)) {  
                    return false  
                }  
  
                current = current.children[char]!!  
            }  
  
            return true  
        }  
  
        fun delete(word: String) {  
            deleteHelper(root, word, 0)  
        }  
  
        private fun deleteHelper(node: TrieNode, word: String, index: Int): Boolean {  
            if (index == word.length) {  
                if (!node.isEndOfWord) return false  
                node.isEndOfWord = false  
                return node.children.isEmpty()  
            }  
  
            val char = word[index]  
            val childNode = node.children[char] ?: return false  
            val shouldDeleteChild = deleteHelper(childNode, word, index + 1)  
  
            if (shouldDeleteChild) {  
                node.children.remove(char)  
                return !node.isEndOfWord && childNode.children.isEmpty()  
            }  
  
            return false  
        }  
  
        fun findWordsWithPrefix(prefix: String): List<String> {  
            val result = mutableListOf<String>()  
            var current = root  
  
            for (char in prefix) {  
                if (!current.children.containsKey(char)) {  
                    return emptyList()  
                }  
  
                current = current.children[char]!!  
            }  
            dfs(current, prefix, result)  
  
            return result  
        }  
  
        private fun dfs(node: TrieNode, currentWord: String, result: MutableList<String>) {  
            if (node.isEndOfWord) {  
                result.add(currentWord)  
            }  
  
            for ((char, childNode) in node.children) {  
                dfs(childNode, currentWord + char, result)  
            }  
        }  
    }  

class TrieNode {
    val children = mutableMapOf<Char, TrieNode>()
    var isEndOfWord = false

}
```