> ## ì¡°í•©
> - ì •ì˜ : ì„œë¡œ ë‹¤ë¥¸ nê°œ ì¤‘ì—ì„œ rê°œë¥¼ ê³¨ë¼ ìˆœì„œ ì—†ì´ ê³ ë¥´ëŠ” ê²½ìš°ì˜ ìˆ˜
> - ì˜ˆì‹œ : A,B,C ì¤‘ 2ê°œ ë½‘ëŠ”ë‹¤. -> AB, AC, BC
> - ê³µì‹ : n! /r!(n - r)!
> - ì¦ëª… : 
> 	- ìˆœì—´ì€ ìˆœì„œë¥¼ ê³ ë ¤í•œ ê²½ìš°ì˜ ìˆ˜
> 	- ì¡°í•©ì€ ê°™ì€ ì¡°í•©ì˜ ì„œë¡œ ë‹¤ë¥¸ ìˆœì„œë“¤ì„ 1ë¡œ ë³¸ë‹¤.
> 	- ìˆœì—´ì—ì„œ ì¤‘ë³µë˜ëŠ” ìˆœì„œë¥¼ ë‚˜ëˆ„ë©´ ëœë‹¤.
>   

- ì •ì˜: ì„œë¡œ ë‹¤ë¥¸ n ê°œ ì¤‘ì—ì„œ **ì¤‘ë³µì„ í—ˆìš©í•´ì„œ** rê°œë¥¼ ìˆœì„œ ìƒê´€ ì—†ì´ ë½‘ëŠ” ê²½ìš°ì˜ ìˆ˜
- ê³µì‹: (n + r - 1) / r = (n + r - 1)! / r!(n - 1)!
- ì¦ëª…: 
	- Stars and Bars ì›ë¦¬
	- rì˜ ì‚¬íƒ•ì„ ë‚˜ëˆ ë‹´ëŠ”ë‹¤ê³  í•  ë•Œ
	- êµ¬ë¶„ë˜ì§€ ì•Šì€ rê°œì˜ ë³„ê³¼ êµ¬ë¶„í•˜ëŠ” n - 1 ë§‰ëŒ€ ë°°ì¹˜
	- ì´ (r + n - 1) ì¤‘ ë³„ì˜ ìœ„ì¹˜ë¥¼ ì„ íƒ
	- (r + n - 1) / r


| **ìœ í˜•**    | **ì¤‘ë³µ í—ˆìš©** | **ìˆœì„œ ê³ ë ¤** | **ê³µì‹**                                  |
| --------- | --------- | --------- | --------------------------------------- |
| ìˆœì—´        | X         | O         | <sub>n</sub>P<sub>r</sub> = n!/(n - r)! |
| **ì¤‘ë³µ ìˆœì—´** | **O**     | O         | n<sup>r</sup>                           |
| ì¡°í•©        | X         | X         | <sub>n</sub>C<sub>r</sub> = n!/r(n-r)!  |
| **ì¤‘ë³µ ì¡°í•©** | **O**     | X         | (n + r - 1)! / r!(n - 1)!               |

### 1. ì˜ˆì‹œ ë¬¸ì œ
1) ì¤‘ë³µ ì¡°í•© êµ¬í•˜ê¸°

```java
class CombinationWithRepetition {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: ì¤‘ë³µ ì¡°í•© êµ¬í•˜ê¸°  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     * ì„œë¡œ ë‹¤ë¥¸ nê°œì˜ ì¢…ë¥˜ì˜ ì‚¬íƒ•ì´ ìˆë‹¤.  
     * ì´ ì¤‘ì—ì„œ ì¤‘ë³µì„ í—ˆìš©í•˜ì—¬ rê°œë¥¼ ê³ ë¥´ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     *    
     *  â€¢  ì…ë ¥: n = 2, r = 3  
     *  â€¢  ì¶œë ¥: 4  
     *    
     * */ 
 

	@Test  
    fun solution(){  
        val n = 2  
        val r = 3  
        val expected = 4  
  
        assertEquals(expected, combinationWithRepetition(n, r))  
    }  
  
    private fun combinationWithRepetition(n: Int, r: Int): Int{  
        return factorial(n + r - 1) /  factorial(r) * factorial(n - 1)  
    }  
  
    private fun factorial(n: Int): Int {  
        if( n == 0 || n == 1) return 1  
  
  
        return (2 .. n).reduce{ acc, i -> acc * i}  
    }  
  
}
```

2) ì¡°í•© êµ¬í•˜ê¸°
```kotlin
class Combination {  
    /**  
     * âœ… ë¬¸ì œ: nê°œì˜ ì›ì†Œ ì¤‘ì—ì„œ rê°œë¥¼ ê³ ë¥´ëŠ” ì¡°í•©ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     *  â€¢  ì›ì†ŒëŠ” ì„œë¡œ ë‹¤ë¥¸ ì •ìˆ˜ì´ë©°, ê°™ì€ ì›ì†Œë¥¼ ë‘ ë²ˆ ì´ìƒ ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  
     *  â€¢  ì¶œë ¥ì€ 1,000,000,007ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ì…ë‹ˆë‹¤.  
     *     * â¸»  
     *  
     * â›³ ì…ë ¥ í˜•ì‹  
     * n r  
     *  â€¢  1 â‰¤ r â‰¤ n â‰¤ 1,000  
     *   
     * â¸»  
     *  
     * â›³ ì¶œë ¥ í˜•ì‹  
     *  â€¢  (n / r) mod 1,000,000,007  
     *   
     *     
     *  ì˜ˆì œ ì…ë ¥ 1    
     *  5 2    
     *  ì˜ˆì œ ì¶œë ¥ 1    
     *  10    
     *    
     *  ì˜ˆì œ ì…ë ¥ 2    
     *  10 3    
     *  ì˜ˆì œ ì¶œë ¥ 2   
     *  120   
     *
     */  
  
    @Test  
    fun solution1() {  
        val n = 5  
        val r = 2  
        val expected = 10  
  
        assertEquals(expected, combination(n, r))  
    }  
  
  
    @Test  
    fun solution2() {  
        val n = 10  
        val r = 3  
        val expected = 120  
  
        assertEquals(expected, combination(n, r))  
    }  
  
    private fun combination(n: Int, r: Int): Int {  
  
        return (factorial(n) / (factorial(r) * factorial(n - r)) ) % 1_000_000_007  
    }  
  
    private fun factorial(n: Int): Int {  
        if(n <= 1) return 1  
  
        return (2..n).reduce{acc, i -> i * acc }  
    }  
}
```