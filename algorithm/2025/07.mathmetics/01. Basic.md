## ë¹„íŠ¸ ì—°ì‚°
- ë¹„íŠ¸ ì—°ì‚°ì€ ì´ì§„ìˆ˜ í˜•íƒœì˜ ê°’ì„ ì§ì ‘ ì¡°ì‘í•˜ëŠ” ì—°ì‚°ì´ë‹¤.
- ì •ìˆ˜í˜• ë³€ìˆ˜ì— ëŒ€í•´ì„œ ë¹„íŠ¸ë¥¼ ì¡°ì‘í•¨ìœ¼ë¡œì¨ ë§¤ìš° ë¹ ë¥¸ ê³„ì‚°ì´ ê°€ëŠ¥í•˜ë‹¤.

## ì—°ì‚°ì ìš”ì•½

| **ì—°ì‚°**      | **ê¸°í˜¸**       | **ì˜ë¯¸**                | **ì˜ˆì‹œ (a=6, b=3)** |
| ----------- | ------------ | --------------------- | ----------------- |
| AND         | &            | ë‘˜ ë‹¤ 1ì¼ ë•Œë§Œ 1           | 6 & 3 = 2         |
| OR          | \|           | ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ 1ì´ë©´ 1        | 6 \| 3 = 7        |
| XOR         | ^            | ë‹¤ë¥´ë©´ 1 (ê°™ìœ¼ë©´ 0)         | 6 ^ 3 = 5         |
| NOT         | inv ë˜ëŠ” inv() | 0ì€ 1ë¡œ, 1ì€ 0ìœ¼ë¡œ (ë¹„íŠ¸ ë°˜ì „) | inv(6) = -7       |
| Left Shift  | <<           | ì™¼ìª½ìœ¼ë¡œ në¹„íŠ¸ ì´ë™ (ê³±ì…ˆ)      | 3 << 1 = 6        |
| Right Shift | >>           | ì˜¤ë¥¸ìª½ìœ¼ë¡œ në¹„íŠ¸ ì´ë™ (ë‚˜ëˆ—ì…ˆ)    | 6 >> 1 = 3        |

## ì˜ˆì‹œ ë¬¸ì œ
1) ê³µí†µ ë¹„íŠ¸
```kotlin
class CommonBit {  
  
    /**  
     * â¸»  
     *  
     * ğŸ§ª ì˜ˆì œ ë¬¸ì œ: ë¹„íŠ¸ ì—°ì‚° ì‹¤ìŠµ 1 â€“ ë‘ ìˆ˜ì˜ ê³µí†µ ë¹„íŠ¸ í™•ì¸  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ aì™€ bê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * ë‘˜ ì‚¬ì´ì— ê³µí†µìœ¼ë¡œ 1ì¸ ë¹„íŠ¸ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.  
     *  â€¢  ê³µí†µ ë¹„íŠ¸ê°€ ìˆë‹¤ë©´ "YES",   
     *  â€¢  ì—†ë‹¤ë©´ "NO"ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     *    
     * ì…ë ¥ ì˜ˆì‹œ1  
     * a = 12   
     * b = 10    
     *     
     * ì¶œë ¥ ì˜ˆì‹œ1  
     * YES  
	 *    
	 * ì…ë ¥ ì˜ˆì‹œ2  
     * a = 8   
     * b = 4  
     * ì¶œë ¥ ì˜ˆì‹œ  
     * NO  
     */  
    @Test  
    fun solution1(){  
        val a = 12  
        val b = 10  
        val expected = "YES"  
        assertEquals(expected, commonBit(a, b))  
    }  
  
    @Test  
    fun solution2(){  
        val a = 8  
        val b = 4  
        val expected = "NO"  
        assertEquals(expected, commonBit(a, b))  
    }  
  
    private fun commonBit(a: Int, b: Int): String {  
        return if(a and b > 0) "YES" else "NO"  
    }  
  
}
```
2) íŠ¹ì • ë¹„íŠ¸ ì¼œì ¸ìˆëŠ”ì§€ í™•ì¸
```kotlin
class IsBitOn {  
    /**  
     * ğŸ§ª ì˜ˆì œ ë¬¸ì œ 2 â€“ íŠ¹ì • ë¹„íŠ¸ê°€ ì¼œì ¸ ìˆëŠ”ì§€ í™•ì¸  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ aì™€ ë¹„íŠ¸ ìœ„ì¹˜ kê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * aì˜ kë²ˆì§¸ ë¹„íŠ¸ê°€ 1ì¸ì§€ 0ì¸ì§€ í™•ì¸í•˜ì—¬ ì¶œë ¥í•˜ì„¸ìš”.  
     *     
     * ë¹„íŠ¸ëŠ” ì˜¤ë¥¸ìª½ì—ì„œ 0ë²ˆë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.  
     * ì˜ˆ: a = 13 (1101)  
     *   
     *  â€¢  0ë²ˆì§¸ ë¹„íŠ¸ = 1   
     *  â€¢  1ë²ˆì§¸ ë¹„íŠ¸ = 0   
     *  â€¢  2ë²ˆì§¸ ë¹„íŠ¸ = 1    
     *  â€¢  3ë²ˆì§¸ ë¹„íŠ¸ = 1    
     *    
     * â¸»  
     *  
     * âœ… ì…ë ¥ ì˜ˆì‹œ 1   
     * a = 13     
     * k = 2     
     * ì¶œë ¥: 1  
     *    
     * âœ… ì…ë ¥ ì˜ˆì‹œ 2    
     * a = 13  
     * k = 1   
     * ì¶œë ¥: 0  
     */  
 
    @Test  
    fun solution1() {  
        val a = 13  
        val k = 2  
        val expected = 1  
  
        assertEquals(expected, bitIsOn(a, k))  
    }  
  
    @Test  
    fun solution2() {  
        val a = 13  
        val k = 1  
        val expected = 0  
  
        assertEquals(expected, bitIsOn(a, k))  
    }  
  
    private fun bitIsOn(a: Int, k: Int): Int {  
        return if (a and ( 1 shl k) != 0) 1 else 0  
    }  
}
```
3) ë¹„íŠ¸ì— ëŒ€í•œ ì—¬ëŸ¬ ì—°ì‚°
```kotlin
class ToggleBits {  
    /**  
     *   
     * â¸»  
     *  
     * ğŸ§ª ì˜ˆì œ ë¬¸ì œ 3 â€“ ë¹„íŠ¸ë¥¼ ì¼œê¸° / ë„ê¸° / í† ê¸€í•˜ê¸°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ aì™€ ë¹„íŠ¸ ìœ„ì¹˜ kê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     *  â€¢  setBit(a, k) â†’ kë²ˆì§¸ ë¹„íŠ¸ë¥¼ 1ë¡œ ì¼œê¸°  
     *  â€¢  clearBit(a, k) â†’ kë²ˆì§¸ ë¹„íŠ¸ë¥¼ 0ìœ¼ë¡œ ë„ê¸°  
     *  â€¢  toggleBit(a, k) â†’ kë²ˆì§¸ ë¹„íŠ¸ë¥¼ ë°˜ì „ì‹œí‚¤ê¸° (1 â†’ 0, 0 â†’ 1) 
     *     
     * ì´ 3ê°œì˜ ë™ì‘ì„ ê°ê° í•¨ìˆ˜ë¡œ êµ¬í˜„í•˜ì„¸ìš”.  
     *     
     * â¸»  
     *  
     * âœ… ì˜ˆì‹œ  
     * a = 9 (1001)  
     *    
     * setBit(a, 1)    â†’ 1011 (11)    
     * clearBit(a, 0)  â†’ 1000 (8)   
     * toggleBit(a, 3) â†’ 0001 (1)    
     * */ 

    @Test  
    fun solution() {  
        val a = 9  
        val setBitK = 1  
        val clearBitK = 0  
        val toggleBitK = 3  
  
        val expectedSetBit = 11  
        val expectedClearBit = 8  
        val expectedToggleBit = 1  
  
        assertEquals(expectedSetBit, setBit(a, setBitK))  
        assertEquals(expectedClearBit, clearBit(a, clearBitK))  
        assertEquals(expectedToggleBit, toggleBit(a, toggleBitK))  
    }  
  
    private fun setBit(a: Int, k: Int): Int {  
        return a or (1 shl k)  
    }  
  
    private fun clearBit(a: Int, k: Int): Int {  
        return a and (1 shl k).inv()  
    }  
  
    private fun toggleBit(a: Int, k: Int): Int {  
        return a xor (1 shl k)  
    }  
}
```
4) ë¶€ë¶„ ì§‘í•© ë§Œë“¤ê¸° 
```kotlin
class BitMaskWithSubset {  
    /**  
     * ğŸ§ª ì˜ˆì œ ë¬¸ì œ 4 â€“ ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ ë¶€ë¶„ ì§‘í•© ë§Œë“¤ê¸°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * ì´ ë°°ì—´ì˜ ëª¨ë“  ë¶€ë¶„ ì§‘í•©ì„ ë¹„íŠ¸ë§ˆìŠ¤í¬ë¥¼ ì´ìš©í•˜ì—¬ ìƒì„±í•˜ì„¸ìš”.  
     *   
     * ê° ì¸ë±ìŠ¤ë¥¼ í•˜ë‚˜ì˜ ë¹„íŠ¸ë¡œ ë³´ê³ ,  
     * ë¹„íŠ¸ê°€ 1ì´ë©´ í¬í•¨, 0ì´ë©´ ë¯¸í¬í•¨ìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤.  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì‹œ  
     * arr = [1, 2, 3]  
     *    
     * ì¶œë ¥  
     * []  
     * [1]   
     * [2]  
     * [1, 2] 
     * [3]   
     * [1, 3]  
     * [2, 3]  
     * [1, 2, 3]  
     * */  


    @Test  
    fun solution() {  
        val arr = listOf(1, 2, 3)  
        val expectedSubSets = """  
            []            [1]            [2]            [1, 2]            [3]            [1, 3]            [2, 3]            [1, 2, 3]        """.trimIndent()  
  
        assertEquals(expectedSubSets, subset(arr))  
    }  
  
    private fun subset(arr: List<Int>): String {  
        val builder = StringBuilder();  
        for (i in 0 until 2.0.pow(arr.size).toInt()) {  
            val subSet = mutableListOf<Int>()  
  
            for (num in arr.indices) {  
                if (i and (1 shl num) > 0) {  
                    subSet.add(arr[num])  
                }  
            }  
  
  
            builder.append(subSet)  
            builder.append("\n")  
        }  
  
  
        return builder.toString().trimIndent()  
    }  
}
```
5) ìµœì†Œ ë¶€ë¶„ì§‘í•© í•© êµ¬í•˜ê¸°
```kotlin
class BitMaskWithSumOfSubset {  
    /**  
     * ğŸ§ª ì˜ˆì œ ë¬¸ì œ 5 â€“ ë¹„íŠ¸ë§ˆìŠ¤í¬ë¡œ ìµœì†Œ ë¶€ë¶„ì§‘í•© í•© êµ¬í•˜ê¸°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ arrì™€ ì •ìˆ˜ targetì´ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * í•©ì´ target ì´ìƒì´ ë˜ëŠ” ë¶€ë¶„ì§‘í•© ì¤‘ ê°€ì¥ ì‘ì€ í•©ì„ êµ¬í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * âœ… ì…ë ¥ ì˜ˆì‹œ  
     * arr = [5, 1, 3, 4]  
     * target = 8  
     * âœ… ì¶œë ¥ ì˜ˆì‹œ  
     * 8  
     */ 
     
	private fun bitMask(arr: List<Int>, target: Int): Int {  
        var number = Int.MAX_VALUE  
  
        for (i in 0 until (1 shl arr.size)) {  
            var sum = 0  
  
            for (j in arr.indices) {  
                if (i and (1 shl j) > 0) {  
                    sum += arr[j]  
                }  
            }  
  
  
            if (sum >= target) {  
                number = minOf(number, sum)  
            }  
        }  
  
        return number  
    }  
    
    @Test  
    fun solution() {  
        val arr = listOf(5, 1, 3, 4)  
        val target = 8  
        val expected = 8  
  
        assertEquals(expected, bitMask(arr, target))  
    }  
  
  
}
```
6) ìµœì†Œ í¬ê¸° ë¶€ë¶„ì§‘í•©
```kotlin
class BitMaskWithMinimumSizeSubset {  
    /**  
     * ğŸ§ª ì‹¤ìŠµ ë¬¸ì œ 6 â€“ ìµœì†Œ í¬ê¸° ë¶€ë¶„ì§‘í•© (ë¹„íŠ¸ë§ˆìŠ¤í¬ + ì¡°ê±´ í•„í„°)  
     *   
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ arrì™€ ì •ìˆ˜ targetì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * í•©ì´ target ì´ìƒì¸ ë¶€ë¶„ì§‘í•© ì¤‘ì—ì„œ ì›ì†Œ ê°œìˆ˜ê°€ ê°€ì¥ ì‘ì€ ê²½ìš°ì˜ í¬ê¸°ë¥¼ ì¶œë ¥í•˜ì„¸ìš”.  
     *    
     * â¸»  
     *  
     * âœ… ì…ë ¥ ì˜ˆì‹œ  
     * arr = [5, 1, 3, 4]  
     * target = 8 
     *   
	 * âœ… ì¶œë ¥ ì˜ˆì‹œ  
     * 2  
     */ 
      
    @Test  
    fun solution() {  
        val arr = listOf(5,1,3,4)  
        val target = 8  
        val expected = 2  
  
        assertEquals(expected, bitMask(arr, target))  
    }  
  
    private fun bitMask(arr: List<Int>, target: Int): Int {  
        var minimum = Int.MAX_VALUE  
  
        for( i in 0 until  (1 shl arr.size)) {  
            var count = 0  
            var sum = 0  
            for(j in arr.indices) {  
                if(i and (1 shl j) > 0) {  
                    count ++  
                    sum += arr[j]  
                }  
            }  
  
            if(sum >= target) {  
                minimum = minOf(minimum, count)  
            }  
        }  
  
        return minimum  
    }  
}
```
7) ê³µì§‘í•© ì œì™¸í•œ í•©
```kotlin
class BitMaskWithSumOfSubsetExceptEmpty {  
    /**  
     * ğŸ§ª ì‹¤ìŠµ ë¬¸ì œ 7 â€“ ê³µì§‘í•© ì œì™¸í•œ ë¶€ë¶„ì§‘í•©ì˜ ì´í•© êµ¬í•˜ê¸°  
     *  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ ë°°ì—´ arrê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * ê³µì§‘í•©ì„ ì œì™¸í•œ ëª¨ë“  ë¶€ë¶„ì§‘í•©ì˜ ì›ì†Œ í•©ì˜ ì´í•©ì„ êµ¬í•˜ì„¸ìš”.  
     *   
     * â¸»  
     *  
     * âœ… ì…ë ¥ ì˜ˆì‹œ  
     * arr = [1, 2, 3]  
     * âœ… ì¶œë ¥ ì˜ˆì‹œ  
     * 24  
     */  
    @Test  
    fun solution(){  
        val arr = listOf(1,2,3)  
        val expected = 24  
  
        assertEquals(expected, bitmask(arr))  
    }  
  
    private fun bitmask(array: List<Int>): Int {  
        var result = 0  
  
        for( i in 0 until (1 shl array.size)) {  
            var subsetResult = 0  
  
            for( j in array.indices) {  
                if(i and (1 shl j) > 0) {  
                    subsetResult += array[j]  
                }  
            }  
  
            result += subsetResult  
        }  
  
  
        return result  
    }  
}
```