
## 1. ì¬ê·€ í•¨ìˆ˜(Recursive)
- ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
- ì¼ë°˜ì ìœ¼ë¡œ ë¬¸ì œë¥¼ ì‘ì€ ë¶€ë¶„ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•  ë•Œ ì‚¬ìš©í•œë‹¤.
- ë¬¸ì œì˜ í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©° ê³„ì‚°ì„ ë°˜ë³µí•˜ëŠ” ë°©ì‹
- ì¬ê·€ í•¨ìˆ˜ëŠ” ë°˜ë³µë¬¸ì„ ëŒ€ì‹ í•  ìˆ˜ ìˆë‹¤. 
- íŠ¹íˆ ì í™”ì‹ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ìˆëŠ” ê²½ìš°ì— ìœ ìš©í•˜ë‹¤.
- ì˜ˆì‹œ1) íŒ©í† ë¦¬ì–¼ ê³„ì‚°
```kotlin
class Factorial {  
  
    @Test  
    fun calculate() {  
  
        val expected = 120  
        val result = recursive(5)  
  
        assertEquals(expected, result)  
    }  
  
    private fun recursive(number: Int): Int {  
        if( number <= 0) return 1;  
        return number * recursive(number - 1)  
    }  
}
```
- ì˜ˆì‹œ2) í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´
```kotlin
class Fibonacci {  
    @Test  
    fun calculate() {  
        val limit = 6  
        val expected = 8;  
        val result = fibonacci(limit)  
  
        assertEquals(expected, result)  
    }  
    private fun fibonacci (index: Int): Int {  
        return when(index) {  
            0 -> 0  
            1 -> 1  
            else -> recursive(0,1,2, index)  
        }  
    }  
// ê¼¬ë¦¬ ì¬ê·€ ë²„ì „
    private fun recursive (first: Int, second: Int, count: Int, targetIndex: Int): Int {  
        if(targetIndex < count) return second  
        return recursive(second, first + second, count + 1, targetIndex)  
    }  
//ì¼ë°˜ ë²„ì „

    private fun recursive(n: Int): Int {  
	    return if(n - 1 <= 0) n  
	    else recursive(n - 2) + recursive(n - 1)  
	}
}
```

## 2. ë¶„í•  ì •ë³µ(Divide and Conquer)
- ë¬¸ì œë¥¼ ì—¬ëŸ¬ í•˜ìœ„ ë¬¸ì œë¡œ ë¶„í• í•˜ì—¬ ê°ê°ì„ í•´ê²°í•œ í›„, ê·¸ í•´ê²° ê²°ê³¼ë¥¼ í•©ì³ì„œ ì›ë˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²•
- ë¶„í• , ì •ë³µ, ê²°í•©ì˜ ë‹¨ê³„ë¥¼ ê°€ì§„ë‹¤.
- ë…ë¦½ì ì´ê³  ì‘ì€ ë‹¨ìœ„ë¡œ í•´ê²°í•  ìˆ˜ ìˆê²Œ í•´ì£¼ë©°, ì´ë¥¼ í° ë¬¸ì œë¥¼ í‘¸ëŠ” ë° í•„ìš”í•œ ì‹œê°„ê³¼ ê³µê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ”ë° ìœ ë¦¬
- ì˜ˆì‹œ 1) ë³‘í•© ì •ë ¬
```kotlin
class MergeSort {  
  
    @Test  
    fun mergeSort() {  
        val array = intArrayOf(38, 27, 43, 3, 9, 82, 10)  
        val expected = intArrayOf(3, 9, 10, 27, 38, 43, 82)  
  
        divide(array, 0, array.size - 1)  
        assertArrayEquals(expected, array)  
    }  
  
    private fun divide(array: IntArray, start: Int, end: Int) {  
        if (start < end) {  
            val mid = (start + end) / 2  
            divide(array, start, mid)  
            divide(array, mid + 1, end)  
            conquer(array, start, mid, end)  
        }  
    }  
  
    private fun conquer(array: IntArray, start: Int, mid: Int, end: Int) {  
        val mutableArray = mutableListOf<Int>()  
        var i = start  
        var j = mid + 1  
  
        while (i <= mid && j <= end) {  
            if (array[i] <= array[j]) mutableArray.add(array[i++])  
            else mutableArray.add(array[j++])  
        }  
        while (i <= mid) mutableArray.add(array[i++])  
        while (j <= end) mutableArray.add(array[j++])  
  
        for ( index in mutableArray.indices) {  
            array[start + index] = mutableArray[index]  
        }  
    }  
  
}
```
- ì˜ˆì‹œ 2) í€µì •ë ¬
```kotlin
class QuickSort {
	data class Container ( val left: Int, val right: Int, ){}

	@Test
	fun sort() {
		val list = giveMeArray()
		val expected = list.sorted().toIntArray()
		val array = list.toIntArray()

		quickSort(array, 0, array.size - 1)
		assertArrayEquals(expected, array)
	}

	private fun quickSort(array: IntArray, left: Int, right: Int) {
		var leftPoint = left
		var rightPoint = right
		var pivotValue = array[(left + right) / 2]

		do {
			while(array[leftPoint] < pivotValue) leftPoint += 1
			while(array[rightPoint] > pivotValue) rightPoint -= 1
	
			if(leftPoint <= rightPoint) {
				array[leftPoint] = array[rightPoint].also {
					array[rightPoint] = array[leftPoint]
				}
	
				leftPoint += 1
				rightPoint -= 1
			}
		} while(leftPoint <= rightPoint)

		if(left < rightPoint) quickSort(array, left, rightPoint)
		if(right > leftPoint) quickSort(array, leftPoint, right)
		
	}
}
```

## 3. ì¬ê·€ì  ë°±íŠ¸ë˜í‚¹(Backtracking)

> ê²°ì • ë¬¸ì œë‚˜ ìµœì í™” ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ ê°€ëŠ¥í•œ ëª¨ë“  í•´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•˜ë©°, 
> ë¶ˆê°€ëŠ¥í•˜ê±°ë‚˜ í•„ìš” ì—†ëŠ” ê²½ìš° ê°€ì§€ì¹˜í‚¤ë¥¼ í†µí•´ íƒìƒ‰ì„ ì¤‘ë‹¨í•˜ëŠ” ë°©ì‹

#### 3.1 ë¬´ì—‡ì¸ê°€?
- í•´ê²°ì±…ì„ ì°¾ê¸° ìœ„í•´ ì—¬ëŸ¬ ì„ íƒì§€ë¥¼ í•˜ë‚˜ì”© ì‹œë„í•˜ê³ , ì˜ëª»ëœ ê²½ë¡œë¥¼ ë”°ë¼ê°€ë©´ ì´ì „ ìƒíƒœë¡œ ëŒì•„ê°€ì„œ ê²½ë¡œë¥¼ ë‹¤ì‹œ ì‹œë„
- ì£¼ë¡œ **íƒìƒ‰ ë¬¸ì œ**ì—ì„œ ì‚¬ìš©
- ê°€ì§€ì¹˜ê¸°ë¥¼ í†µí•´ ë¶ˆí•„ìš”í•œ ê²½ë¡œë¥¼ ì œê±°í•˜ì—¬ íš¨ìœ¨ì„±ì„ ë†’ì¸ë‹¤.
- ë¶„ê¸° íƒìƒ‰ ë°©ì‹ìœ¼ë¡œ, í•´ê²°ì±…ì„ ì°¾ê¸° ìœ„í•œ íƒìƒ‰ íŠ¸ë¦¬ë¥¼ ë”°ë¼ê°€ë©´ì„œ, ê° ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ ì„ íƒì„ íƒìƒ‰í•˜ê³ , ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë˜ëŒì•„ ê°„ë‹¤.

#### 3.2 í•„ìš” ì´ìœ ?
- ì™„ì „ íƒìƒ‰ì„ í•˜ë©´ ê³„ì‚°ëŸ‰ì´ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ í­ì¦
- ì¬ê·€ í˜¸ì¶œë¡œ íƒìƒ‰ì„ ê´€ë¦¬í•˜ê³ 
- ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•ŠëŠ” ê²½ë¡œëŠ” ë°”ë¡œ í¬ê¸°(Pruning)
- ì˜ˆì‹œ 1) N Queen - ì°¸ê³ : [[ã…£ ê²©ì ê¸°í•˜í•™(lattice geometry)]]
```kotlin
class NQueen {  
  
    /**  
     * ğŸ“Œ ë¬¸ì œ ì„¤ëª…  
     *  
     * N Ã— N í¬ê¸°ì˜ ì²´ìŠ¤íŒ ìœ„ì— Nê°œì˜ í€¸ì„ ì„œë¡œ ê³µê²©í•˜ì§€ ì•Šê²Œ ë†“ìœ¼ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ì—¬ê¸°ì„œ í€¸ì€ ê°™ì€ í–‰, ì—´, ëŒ€ê°ì„  ìƒì— ìˆìœ¼ë©´ ì„œë¡œ ê³µê²©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ëª©í‘œ:  
     * Nê°œì˜ í€¸ì„ ì˜¬ë°”ë¥´ê²Œ ë†“ì„ ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     * í•˜ë‚˜ì˜ ì •ìˆ˜ N (4 â‰¤ N â‰¤ 15)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     * ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í€¸ ë°°ì¹˜ì˜ ì´ ê²½ìš°ì˜ ìˆ˜ (ì •ìˆ˜)  
     *     *     *  1. ê° í–‰ì— QëŠ” í•˜ë‚˜  
     *  2. ê° ì—´ì— QëŠ” ì•„ë‚˜  
     *  3. ëŒ€ê°ì„ ìœ¼ë¡œë„ QëŠ” í•˜ë‚˜  
     *  4. ëª¨ë“  ê²½ìš°ì˜ ìˆ˜  
     *  
     *  {  
     *     
     *      ë§Œì•½ í˜„ì¬ row, colì´ ì¡°ê±´ì— ë¶€í•©í•˜ì§€ ì•Šìœ¼ë©´ ì¢…ë£Œ  
     *      ë§Œì•½ í˜„ì¬ rowê°€ nì´ë©´ ê°€ëŠ¥í•˜ë‹¤ê³  ì²´í¬  
     *  
     *     
     *      for(i 0 until n)     
     *          row, iì— ë‘”ë‹¤.  
     *          ì¬ê·€ í˜¸ì¶œ(row + 1)  
     *          row, iì— ë‘” ê²ƒì„ ì œê±°í•œë‹¤.  
     *  }     
     *     
     *     
     *  ë¬¸ì œì   
     *  â€¢  â€œì–´ë–»ê²Œ 2ì°¨ì›ì ì¸ ëŒ€ê°ì„  ê´€ê³„ë¥¼ 1ì°¨ì› ë°°ì—´ë¡œ ì¶”ìƒí™”í•˜ì§€?â€ â†’ ì—¬ê¸°ì„œ ë§‰í˜.  
     *    â€¢  row + col
     *    â€¢  row - col + (n - 1)
     *  â€¢  â€œë°°ì—´ í¬ê¸°ëŠ” ë˜ ì–¼ë§ˆë‚˜ í•„ìš”í•˜ì§€?â€ â†’ ê³„ì‚°ì‹ ì •ë¦¬ê°€ ì•ˆ ë˜ë©´ ëª» ì”€.  -> 2*n - 1  
     */ 
     
  
    fun useBacktracking( bottom: BooleanArray, leftBottom: BooleanArray, rightBottom: BooleanArray, row: Int, n: Int): Int {  
  
        if(row == n) return  1  
  
        var success = 0;  
        for(col in 0 until n) {  
  
            val leftBottomIndex = row + col  
            val rightBottomIndex = row - col + n - 1  
            if(bottom[col] or leftBottom[leftBottomIndex] or rightBottom[rightBottomIndex]) continue  
  
            bottom[col] = true  
            leftBottom[leftBottomIndex] = true  
            rightBottom[rightBottomIndex] = true  
  
            success += useBacktracking(bottom, leftBottom, rightBottom, row + 1, n)  
  
            bottom[col] = false  
            leftBottom[leftBottomIndex] = false  
            rightBottom[rightBottomIndex] = false  
        }  
  
        return success;  
}  
  
  
    @Test  
    fun backtracking4() {  
        val n = 4  
        val expected = 2  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking5() {  
        val n = 5  
        val expected = 10  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking8() {  
        val n = 8  
        val expected = 92  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
}
```
- ì˜ˆì‹œ 2) ë¶€ë¶„ ì§‘í•©ì˜ í•©(SubsetSum)
```kotlin
class SubsetSum {  
    /**  
     * âœ… ë¬¸ì œ ì„¤ëª…  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ numsì™€ ëª©í‘œ ê°’ targetì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  numsì˜ ì¼ë¶€ ì›ì†Œë¥¼ ì„ íƒí•˜ì—¬ í•©ì´ targetì´ ë˜ë„ë¡ í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.  
     * â¸»  
     * âœ… ì…ë ¥  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ nums (ì˜ˆ: [3, 34, 4, 12, 5, 2])  
     *  â€¢  ì •ìˆ˜ target (ì˜ˆ: 9)  
     * â¸»  
     * âœ… ì¶œë ¥  
     *  â€¢  í•©ì´ targetì¸ ë¶€ë¶„ì§‘í•©ì´ ì¡´ì¬í•˜ë©´ True, ì•„ë‹ˆë©´ False 
     * 
     */
       
    @Test  
    fun solution() {  
        val array = intArrayOf(3, 34, 4, 12, 5, 2)  
        val target = 9  
  
        val result = useBackTracking(array, BooleanArray(array.size), target, 0)  
        assertTrue(result)  
    }

	
    fun useBackTracking(array: IntArray, table: BooleanArray, target: Int, number: Int): Boolean {  
  
        var result = false  
        if (target == number) return true  
  
        for (i in 0 until array.size) {  
            if (table[i]) continue  
  
            table[i] = true  
            result = result || useBackTracking(array, table, target, number + array[i])  
            table[i] = false  
        }  
        return result  
  
    }  
  
}
```

- ì˜ˆì‹œ 3) ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ ìƒì„± (ì§€ê¸ˆê¹Œì§€ì™€ ì½”ë“œ íŒ¨í„´ì´ ë‹¤ë¥´ë‹¤.)
```kotlin
  
class GenerateParentheses {  
    /**  
     *      ë¬¸ì œ ì´ë¦„  
     *      ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ ìƒì„± (Generate Parentheses)   
     *      â¸»  
     *      ë¬¸ì œ ì„¤ëª…  
     *      nìŒì˜ ê´„í˜¸ ()ë¥¼ ì‚¬ìš©í•´ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ëª¨ë“  ì˜¬ë°”ë¥¸ ê´„í˜¸ ë¬¸ìì—´ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *      ì˜¬ë°”ë¥¸ ê´„í˜¸ë€, ì—¬ëŠ” ê´„í˜¸ (ê°€ ë‹«ëŠ” ê´„í˜¸ )ë³´ë‹¤ ë¨¼ì € ë‚˜ì˜¤ê³ , ì§ì´ ë§ëŠ” êµ¬ì¡°ì…ë‹ˆë‹¤.  
     *      â¸»  
     *      ì…ë ¥  
     *          â€¢  ì •ìˆ˜ n (1 â‰¤ n â‰¤ 10)  
     *      â¸»  
     *      ì¶œë ¥  
     *          â€¢  ê°€ëŠ¥í•œ ëª¨ë“  ê´„í˜¸ ë¬¸ìì—´ì„ ì‚¬ì „ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ì¶œë ¥  
     *  
     *      í•­ëª©             ì œí•œ  
     *      ìµœëŒ€ ê´„í˜¸ ìŒ ìˆ˜  |  10    
     *      ì¶œë ¥ ê°œìˆ˜       |ì¹´íƒˆë€ ìˆ˜ (C_n), n=3ì´ë©´ 5ê°œ  
     *      ì œì•½           | ì—¬ëŠ” ê´„í˜¸ ìˆ˜ â‰¤ ë‹«ëŠ” ê´„í˜¸ ìˆ˜  
     *  
     *    
     *      ì˜ˆì‹œ  
     *      ì…ë ¥: n = 3  
     *      ì¶œë ¥:  
     *      ((()))     
     *      (()())     
     *      (())()     
     *      ()(())     
     *      ()()()     
     * 
     */ 
     
    @Test  
    fun solution() {  
        val number = 3  
        val expected = listOf("((()))", "(()())", "(())()", "()(())", "()()()")  
        val list = mutableListOf<String>();  
        useBacktracking("", 0, 0, number, list)  
        println(list)  
        assertEquals(expected, list.sorted())  
    }  
  
  
    private fun useBacktracking(current: String, openCount: Int, closeCount: Int, n: Int, result: MutableList<String>) {  
        if (2 * n == (openCount + closeCount)) {  
            result.add(current)  
            return  
        }  
  
  
        /**  
         * ë°±íŠ¸ë˜í‚¹ ê°œë…ì´ ì—¬ê¸°ì„œ ì‚¬ìš©ëœë‹¤.  
         * ì¶”ê°€ë¡œ ì—´ê¸° ì „ì— ë‹«ì„ ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì´ (closeCount < openCount) ì´ë¯¸ ì¡°ê±´ì— ëª…ì‹œë˜ì–´ )ê°€ ë¨¼ì €ë‚˜ì˜¤ëŠ” ìƒí™©ì€ ì—†ìŒ  
         */  
        if (openCount < n) {  
            useBacktracking("$current(", openCount + 1, closeCount, n, result)  
        }  
  
        if (closeCount < openCount) {  
            useBacktracking("$current)", openCount, closeCount + 1, n, result)  
        }  
    }  
}
```

- ì˜ˆì‹œ 4) ìˆ«ì ì¡°í•©ìœ¼ë¡œ ëª©í‘œ ìˆ«ì ë§Œë“¤ê¸°
```kotlin
class CombinationSum {  
    /**  
     * ğŸŒŸ ë¬¸ì œ ì´ë¦„  
     *  
     * ìˆ«ì ì¡°í•©ìœ¼ë¡œ ëª©í‘œê°’ ë§Œë“¤ê¸° (Combination Sum)     
     * â¸»  
     * âœ… ë¬¸ì œ ì„¤ëª…  
     * ì •ìˆ˜ ë°°ì—´ candidatesì™€ ëª©í‘œ ì •ìˆ˜ targetì´ ì£¼ì–´ì§ˆ ë•Œ,  
     * candidatesì˜ ìˆ«ìë“¤ì„ ì¤‘ë³µí•´ì„œ ê³¨ë¼ í•©ì´ targetì´ ë˜ë„ë¡ í•˜ëŠ” ëª¨ë“  ì¡°í•©ì„ êµ¬í•˜ì‹œì˜¤.  
     *     
     * ë‹¨, ê° ìˆ«ìëŠ” ë¬´í•œíˆ ì‚¬ìš© ê°€ëŠ¥í•˜ë©°, ìˆœì„œë§Œ ë‹¤ë¥´ê³  ë‚´ìš©ì´ ê°™ì€ ì¡°í•©ì€ ì¤‘ë³µìœ¼ë¡œ ë³´ì§€ ì•ŠìŠµë‹ˆë‹¤.  
     * â¸»  
     * âœ… ì…ë ¥  
     *  â€¢  ì •ìˆ˜ ë°°ì—´ candidates (ex: [2, 3, 6, 7])     
     *  â€¢  ì •ìˆ˜ target (ex: 7)    
     * â¸»  
     * âœ… ì¶œë ¥  
     *  â€¢  í•©ì´ targetì´ ë˜ëŠ” ì¡°í•©ë“¤ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ëª¨ë‘ ì¶œë ¥  
     * â¸»  
     *  
     * âœ… ì¡°ê±´ ìš”ì•½  
     * í•­ëª©         | ì œí•œ  
     * ë°°ì—´ ê¸¸ì´     | 1 â‰¤ nums.length â‰¤ 30     
     * ì›ì†Œ ë²”ìœ„     | 1 â‰¤ nums[i] â‰¤ 200    
     * target ë²”ìœ„  | 1 â‰¤ target â‰¤ 500    
     * ì¤‘ë³µ ì œê±° ë°©ì‹ | ìˆ«ì ì¡°í•©ì€ ì •ë ¬ëœ ìƒíƒœ, ìˆœì—´ë¡œ ì¹˜ì§€ ì•ŠìŒ  
     *  
     * â¸»  
     *  
     * âœ… ì˜ˆì œ  
     * ì…ë ¥  
     * candidates = [2,3,6,7]  
     * target = 7     
     *     
     * ì¶œë ¥  
     * [ [2,2,3], [7] ]  
     */  
     
    @Test  
    fun solution() {  
        val candidates = intArrayOf(2,3,6,7)  
        val target = 7  
        val expected = setOf(listOf(2,2,3), listOf(7))  
        val result = mutableSetOf<List<Int>>()  
  
        useBacktracking(candidates, target, 0, 0, mutableListOf(), result)  
  
  
        assertEquals(expected, result)  
    }  
  
    fun useBacktracking(  
        candidates: IntArray,  
        target: Int, sum: Int,  
        startIndex: Int,  
        index: MutableList<Int>,  
        result: MutableSet<List<Int>>  
    ) {  
  
        if(target < sum) return  
  
        if( target == sum) {  
            result.add(index.map { candidates[it] }.sorted())  
            return  
        }  
        //listë¡œ í•œë‹¤ëŠ” ì ì—ì„œ ì•½ê°„ ë‹¤ë¥´ë‹¤. ê°œë…ì€ ê°™ë‹¤.
        for(i in startIndex until candidates.size) {  
            index.add(i)  
            useBacktracking(candidates, target, sum + candidates[i], i, index, result )  
            index.removeLast()  
        }  
    }  
}
```
- ì˜ˆì‹œ 5) ìˆ«ì íŒ¨ë“œ ë¬¸ì ì¡°í•©
```kotlin
  
class LetterCombinationOfAPhoneNumber {  
  
  
    /**  
     * ```     
     * â¸»  
     * 
     * âœ… ë¬¸ì œ ì´ë¦„  
     * ìˆ«ì íŒ¨ë“œ ë¬¸ì ì¡°í•© (Letter Combinations of a Phone Number)    
     * â¸»  
     * 
     * âœ… ë¬¸ì œ ì„¤ëª…  
     * ì „í™”ê¸° ìˆ«ì íŒ¨ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë¬¸ìì— ë§¤í•‘ë©ë‹ˆë‹¤:  
     * 2 â†’ "abc"     
     * 3 â†’ "def"     
     * 4 â†’ "ghi"    
     * 5 â†’ "jkl"     
     * 6 â†’ "mno"     
     * 7 â†’ "pqrs"     
     * 8 â†’ "tuv"     
     * 9 â†’ "wxyz"     
     * 
     * ìˆ«ì ë¬¸ìì—´ digitsê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * í•´ë‹¹ ìˆ«ìì— ë§¤í•‘ëœ ë¬¸ìë“¤ì„ ì´ìš©í•´ ë§Œë“¤ ìˆ˜ ìˆëŠ” ëª¨ë“  ë¬¸ì ì¡°í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     * â¸»  
     * 
     * âœ… ì…ë ¥  
     *  â€¢  ìˆ«ì ë¬¸ìì—´ digits (ì˜ˆ: â€œ23â€)  
     *  â€¢  ê¸¸ì´: 1 â‰¤ digits.length â‰¤ 4  
     *  â€¢  ê° ë¬¸ìëŠ” â€˜2â€™~â€˜9â€™ ì‚¬ì´  
     * â¸»  
     * 
     * âœ… ì¶œë ¥  
     *  â€¢  ê°€ëŠ¥í•œ ë¬¸ì ì¡°í•© ë¦¬ìŠ¤íŠ¸ (ì˜ˆ: [â€œadâ€, â€œaeâ€, â€œafâ€, â€œbdâ€, â€¦])  
     *     
     *  ì…ë ¥  
     *  digits = "23"  
     *     
     *  ì¶œë ¥  
     *  ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]  
     *     
     *  ```  
     */    @Test  
    fun solution(){  
        val inputNumber = 23  
        val result = mutableListOf<String>()  
        val expected =  listOf("ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf")  
  
        val map: Map<String, String>  = mapOf(  
            Pair("2", "abc"),  
            Pair("3", "def"),  
            Pair("4", "ghi"),  
            Pair("5", "jkl"),  
            Pair("6", "mno"),  
            Pair("7", "pqrs"),  
            Pair("8", "tuv"),  
            Pair("9", "wxyz"),  
        )  
        useBacktracking(inputNumber.toString(), 0,"", result, map)  
  
        assertEquals(expected, result.sorted())  
    }  
  
    private fun useBacktracking(
	    target: String,
	    index: Int,
	    combination: String,
	    list: MutableList<String>,
	    map: Map<String, String>
    ){  
  
  
        if(target.length <= index){  
            list.add(combination)  
            return  
        }  
  
        val targetNumber: String = target[index].toString()  
        val stringNumber: String = map[targetNumber]!!;  
        for( j in 0 until stringNumber.length){  
            val result = stringNumber[j]  
            useBacktracking(target, index + 1, combination + result, list, map)  
        }  
    }  
}
```
- ì˜ˆì‹œ 6) ë‹¨ì–´ ì‚¬ë‹¤ë¦¬ ì°¾ê¸°
```kotlin
class WordSearch {  
    /**  
     * âœ… ë¬¸ì œ ì„¤ëª…  
     * 2D ë¬¸ì ê²©ì(board)ì™€ í•˜ë‚˜ì˜ ë‹¨ì–´(word)ê°€ ì£¼ì–´ì§ˆ ë•Œ,  
     * ê²©ì ë‚´ ì¸ì ‘í•œ ì…€ì„ ë”°ë¼ í•´ë‹¹ ë‹¨ì–´ê°€ ì¡´ì¬í•˜ëŠ”ì§€ íŒë³„í•˜ì‹œì˜¤.  
     *  â€¢  ì¸ì ‘: ìƒí•˜ì¢Œìš°  
     *  â€¢  ê°™ì€ ì…€ì„ ë‘ ë²ˆ ì´ìƒ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ  
     *  
     *     * âœ… ì…ë ¥ ì˜ˆ  
     *  board = [  
     *     ['A','B','C','E'],  
     *     ['S','F','C','S'],   
     *     ['A','D','E','E']     
     * ]    
     *    
     * word = "ABCCED"     
     *     
     * âœ… ì¶œë ¥  
     * true  
     *     
     * âœ… ì¡°ê±´ ìš”ì•½  
     * í•­ëª©          |ì œí•œ  
     * board í¬ê¸°    | 1 â‰¤ m, n â‰¤ 6   
     * word ê¸¸ì´     | 1 â‰¤ word.length â‰¤ 15    
     * ì¤‘ë³µ ë°©ë¬¸ ê¸ˆì§€  |ë™ì¼ ì¢Œí‘œ ë‘ ë²ˆ ì‚¬ìš© ë¶ˆê°€  
     *  
     */ 


    @Test  
    fun solution() {  
        val board = arrayOf(  
            arrayOf("A", "B", "C", "E"),  
            arrayOf("S", "F", "C", "S"),  
            arrayOf("A", "D", "E", "E")  
        )  
        val visit = Array<BooleanArray>(board.size) {  
            BooleanArray(4)  
        }  
  
        val word = "ABCCED"  
        val expected = true  
        val result = StringBuilder()  
        useBacktrackingV2(board, visit, 0, word, result, 0, 0)  
  
        print(result)  
        assertEquals(expected, result.toString()==word)  
    }  
  
    fun useBacktrackingV1(  
        board: Array<Array<String>>, visit: Array<BooleanArray>, count: Int,  
        find: String, word: StringBuilder,  
        row: Int, col: Int,  
    ) {  
  
        if(board[row][col] != "${find[count]}") return  
  
        word.append(board[row][col])  
        if (count == find.length - 1) {  
            return  
        }  
  
  
        if(row - 1 >= 0 && !visit[row - 1][col]) {  
            visit[row - 1][col] = true  
            useBacktrackingV1(board, visit, count + 1, find, word, row - 1, col)  
            visit[row - 1][col] = false  
        }  
  
        if(col - 1 >= 0 && !visit[row][col - 1]) {  
            visit[row][col -1] = true  
            useBacktrackingV1(board, visit, count + 1, find, word, row, col-1)  
            visit[row][col -1] = false  
        }  
  
        if(row + 1 < board.size && !visit[row + 1][col]) {  
            visit[row + 1][col] = true  
            useBacktrackingV1(board, visit, count + 1, find, word, row + 1, col)  
            visit[row + 1][col] = false  
        }  
  
        if(col + 1 < board[0].size && !visit[row][col + 1]) {  
            visit[row][col + 1] = true  
            useBacktrackingV1(board, visit, count + 1, find, word, row, col+1)  
            visit[row][col + 1] = false  
        }  
    }  
  
  
    fun useBacktrackingV2(  
        board: Array<Array<String>>, visit: Array<BooleanArray>, count: Int,  
        find: String, word: StringBuilder,  
        row: Int, col: Int,  
    ) {  
  
        if(board[row][col] != "${find[count]}") return  
        word.append(board[row][col])  
        visit[row][col] = true  
        if (count == find.length - 1) {  
            return  
        }  
  
        val direction = listOf(  
            Pair(-1, 0), Pair(1, 0),  
            Pair(0, -1), Pair(0, 1)  
        )  
  
        for((dr, dc) in direction) {  
            val nr = row + dr  
            val nc = col + dc  
  
            if (  
                nr in board.indices &&  
                nc in board[0].indices &&  
                !visit[nr][nc]  
            ) {  
                useBacktrackingV2(board, visit, count + 1, find, word, nr, nc)  
            }  
        }  
  
        visit[row][col] = false  
    }  
}
```