
## 1. ì¬ê·€ í•¨ìˆ˜(Recursive)
- ìê¸° ìì‹ ì„ í˜¸ì¶œí•˜ëŠ” í•¨ìˆ˜
- ì¼ë°˜ì ìœ¼ë¡œ ë¬¸ì œë¥¼ ì‘ì€ ë¶€ë¶„ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í•´ê²°í•  ë•Œ ì‚¬ìš©í•œë‹¤.
- ë¬¸ì œì˜ í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©° ê³„ì‚°ì„ ë°˜ë³µí•˜ëŠ” ë°©ì‹
- ì¬ê·€ í•¨ìˆ˜ëŠ” ë°˜ë³µë¬¸ì„ ëŒ€ì‹ í•  ìˆ˜ ìˆë‹¤. 
- íŠ¹íˆ ì í™”ì‹ìœ¼ë¡œ ì •ì˜í•  ìˆ˜ ìˆëŠ” ê²½ìš°ì— ìœ ìš©í•˜ë‹¤.
- ì˜ˆì‹œ1) íŒ©í† ë¦¬ì–¼ ê³„ì‚°
```kotlin
class Factorial {  
  
    @Test  
    fun calculate() {  
  
        val expected = 120  
        val result = recursive(5)  
  
        assertEquals(expected, result)  
    }  
  
    private fun recursive(number: Int): Int {  
        if( number <= 0) return 1;  
        return number * recursive(number - 1)  
    }  
}
```
- ì˜ˆì‹œ2) í”¼ë³´ë‚˜ì¹˜ ìˆ˜ì—´
```kotlin
class Fibonacci {  
    @Test  
    fun calculate() {  
        val limit = 6  
        val expected = 8;  
        val result = fibonacci(limit)  
  
        assertEquals(expected, result)  
    }  
    private fun fibonacci (index: Int): Int {  
        return when(index) {  
            0 -> 0  
            1 -> 1  
            else -> recursive(0,1,2, index)  
        }  
    }  
    private fun recursive (first: Int, second: Int, count: Int, targetIndex: Int): Int {  
        if(targetIndex < count) return second  
        return recursive(second, first + second, count + 1, targetIndex)  
    }  
}
```

## 2. ë¶„í•  ì •ë³µ(Divide and Conquer)
- ë¬¸ì œë¥¼ ì—¬ëŸ¬ í•˜ìœ„ ë¬¸ì œë¡œ ë¶„í• í•˜ì—¬ ê°ê°ì„ í•´ê²°í•œ í›„, ê·¸ í•´ê²° ê²°ê³¼ë¥¼ í•©ì³ì„œ ì›ë˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì„¤ê³„ ê¸°ë²•
- ë¶„í• , ì •ë³µ, ê²°í•©ì˜ ë‹¨ê³„ë¥¼ ê°€ì§„ë‹¤.
- ë…ë¦½ì ì´ê³  ì‘ì€ ë‹¨ìœ„ë¡œ í•´ê²°í•  ìˆ˜ ìˆê²Œ í•´ì£¼ë©°, ì´ë¥¼ í° ë¬¸ì œë¥¼ í‘¸ëŠ” ë° í•„ìš”í•œ ì‹œê°„ê³¼ ê³µê°„ì„ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•˜ëŠ”ë° ìœ ë¦¬
- ì˜ˆì‹œ 1) ë³‘í•© ì •ë ¬
```kotlin
class MergeSort {  
  
    @Test  
    fun mergeSort() {  
        val array = intArrayOf(38, 27, 43, 3, 9, 82, 10)  
        val expected = intArrayOf(3, 9, 10, 27, 38, 43, 82)  
  
        divide(array, 0, array.size - 1)  
        assertArrayEquals(expected, array)  
    }  
  
    private fun divide(array: IntArray, start: Int, end: Int) {  
        if (start < end) {  
            val mid = (start + end) / 2  
            divide(array, start, mid)  
            divide(array, mid + 1, end)  
            conquer(array, start, mid, end)  
        }  
    }  
  
    private fun conquer(array: IntArray, start: Int, mid: Int, end: Int) {  
        val mutableArray = mutableListOf<Int>()  
        var i = start  
        var j = mid + 1  
  
        while (i <= mid && j <= end) {  
            if (array[i] <= array[j]) mutableArray.add(array[i++])  
            else mutableArray.add(array[j++])  
        }  
        while (i <= mid) mutableArray.add(array[i++])  
        while (j <= end) mutableArray.add(array[j++])  
  
        for ( index in mutableArray.indices) {  
            array[start + index] = mutableArray[index]  
        }  
    }  
  
}
```
- ì˜ˆì‹œ 2) í€µì •ë ¬
```kotlin
class QuickSort {
	data class Container ( val left: Int, val right: Int, ){}

	@Test
	fun sort() {
		val list = giveMeArray()
		val expected = list.sorted().toIntArray()
		val array = list.toIntArray()

		quickSort(array, 0, array.size - 1)
		assertArrayEquals(expected, array)
	}

	private fun quickSort(array: IntArray, left: Int, right: Int) {
		var leftPoint = left
		var rightPoint = right
		var pivotValue = array[(left + right) / 2]

		do {
			while(array[leftPoint] < pivotValue) leftPoint += 1
			while(array[rightPoint] > pivotValue) rightPoint -= 1
	
			if(leftPoint <= rightPoint) {
				array[leftPoint] = array[rightPoint].also {
					array[rightPoint] = array[leftPoint]
				}
	
				leftPoint += 1
				rightPoint -= 1
			}
		} while(leftPoint <= rightPoint)

		if(left < rightPoint) quickSort(array, left, rightPoint)
		if(right > leftPoint) quickSort(array, leftPoint, right)
		
	}
}
```

## 3. ì¬ê·€ì  ë°±íŠ¸ë˜í‚¹(Backtracking)

> ê²°ì • ë¬¸ì œë‚˜ ìµœì í™” ë¬¸ì œë¥¼ í•´ê²°í•  ë•Œ ê°€ëŠ¥í•œ ëª¨ë“  í•´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ íƒìƒ‰í•˜ë©°, 
> ë¶ˆê°€ëŠ¥í•˜ê±°ë‚˜ í•„ìš” ì—†ëŠ” ê²½ìš° ê°€ì§€ì¹˜í‚¤ë¥¼ í†µí•´ íƒìƒ‰ì„ ì¤‘ë‹¨í•˜ëŠ” ë°©ì‹

#### 3.1 ë¬´ì—‡ì¸ê°€?
- í•´ê²°ì±…ì„ ì°¾ê¸° ìœ„í•´ ì—¬ëŸ¬ ì„ íƒì§€ë¥¼ í•˜ë‚˜ì”© ì‹œë„í•˜ê³ , ì˜ëª»ëœ ê²½ë¡œë¥¼ ë”°ë¼ê°€ë©´ ì´ì „ ìƒíƒœë¡œ ëŒì•„ê°€ì„œ ê²½ë¡œë¥¼ ë‹¤ì‹œ ì‹œë„
- ì£¼ë¡œ **íƒìƒ‰ ë¬¸ì œ**ì—ì„œ ì‚¬ìš©
- ê°€ì§€ì¹˜ê¸°ë¥¼ í†µí•´ ë¶ˆí•„ìš”í•œ ê²½ë¡œë¥¼ ì œê±°í•˜ì—¬ íš¨ìœ¨ì„±ì„ ë†’ì¸ë‹¤.
- ë¶„ê¸° íƒìƒ‰ ë°©ì‹ìœ¼ë¡œ, í•´ê²°ì±…ì„ ì°¾ê¸° ìœ„í•œ íƒìƒ‰ íŠ¸ë¦¬ë¥¼ ë”°ë¼ê°€ë©´ì„œ, ê° ë‹¨ê³„ì—ì„œ ê°€ëŠ¥í•œ ì„ íƒì„ íƒìƒ‰í•˜ê³ , ë” ì´ìƒ ì§„í–‰í•  ìˆ˜ ì—†ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë˜ëŒì•„ ê°„ë‹¤.

#### 3.2 í•„ìš” ì´ìœ ?
- ì™„ì „ íƒìƒ‰ì„ í•˜ë©´ ê³„ì‚°ëŸ‰ì´ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ í­ì¦
- ì¬ê·€ í˜¸ì¶œë¡œ íƒìƒ‰ì„ ê´€ë¦¬í•˜ê³ 
- ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•ŠëŠ” ê²½ë¡œëŠ” ë°”ë¡œ í¬ê¸°(Pruning)
- ì˜ˆì‹œ 1) N Queen - ì°¸ê³ : [[ê²©ì ê¸°í•˜í•™(lattice geometry)]]
```kotlin
class NQueen {  
  
    /**  
     * ğŸ“Œ ë¬¸ì œ ì„¤ëª…  
     *  
     * N Ã— N í¬ê¸°ì˜ ì²´ìŠ¤íŒ ìœ„ì— Nê°œì˜ í€¸ì„ ì„œë¡œ ê³µê²©í•˜ì§€ ì•Šê²Œ ë†“ìœ¼ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ì—¬ê¸°ì„œ í€¸ì€ ê°™ì€ í–‰, ì—´, ëŒ€ê°ì„  ìƒì— ìˆìœ¼ë©´ ì„œë¡œ ê³µê²©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ëª©í‘œ:  
     * Nê°œì˜ í€¸ì„ ì˜¬ë°”ë¥´ê²Œ ë†“ì„ ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     * í•˜ë‚˜ì˜ ì •ìˆ˜ N (4 â‰¤ N â‰¤ 15)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     * ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í€¸ ë°°ì¹˜ì˜ ì´ ê²½ìš°ì˜ ìˆ˜ (ì •ìˆ˜)  
     *     *     *  1. ê° í–‰ì— QëŠ” í•˜ë‚˜  
     *  2. ê° ì—´ì— QëŠ” ì•„ë‚˜  
     *  3. ëŒ€ê°ì„ ìœ¼ë¡œë„ QëŠ” í•˜ë‚˜  
     *  4. ëª¨ë“  ê²½ìš°ì˜ ìˆ˜  
     *  
     *  {  
     *     
     *      ë§Œì•½ í˜„ì¬ row, colì´ ì¡°ê±´ì— ë¶€í•©í•˜ì§€ ì•Šìœ¼ë©´ ì¢…ë£Œ  
     *      ë§Œì•½ í˜„ì¬ rowê°€ nì´ë©´ ê°€ëŠ¥í•˜ë‹¤ê³  ì²´í¬  
     *  
     *     
     *      for(i 0 until n)     
     *          row, iì— ë‘”ë‹¤.  
     *          ì¬ê·€ í˜¸ì¶œ(row + 1)  
     *          row, iì— ë‘” ê²ƒì„ ì œê±°í•œë‹¤.  
     *  }     
     *     
     *     
     *  ë¬¸ì œì   
     *  â€¢  â€œì–´ë–»ê²Œ 2ì°¨ì›ì ì¸ ëŒ€ê°ì„  ê´€ê³„ë¥¼ 1ì°¨ì› ë°°ì—´ë¡œ ì¶”ìƒí™”í•˜ì§€?â€ â†’ ì—¬ê¸°ì„œ ë§‰í˜.  
     *    â€¢  row + col
     *    â€¢  row - col + (n - 1)
     *  â€¢  â€œë°°ì—´ í¬ê¸°ëŠ” ë˜ ì–¼ë§ˆë‚˜ í•„ìš”í•˜ì§€?â€ â†’ ê³„ì‚°ì‹ ì •ë¦¬ê°€ ì•ˆ ë˜ë©´ ëª» ì”€.  -> 2*n - 1  
     */ 
     
  
    fun useBacktracking( bottom: BooleanArray, leftBottom: BooleanArray, rightBottom: BooleanArray, row: Int, n: Int): Int {  
  
        if(row == n) return  1  
  
        var success = 0;  
        for(col in 0 until n) {  
  
            val leftBottomIndex = row + col  
            val rightBottomIndex = row - col + n - 1  
            if(bottom[col] or leftBottom[leftBottomIndex] or rightBottom[rightBottomIndex]) continue  
  
            bottom[col] = true  
            leftBottom[leftBottomIndex] = true  
            rightBottom[rightBottomIndex] = true  
  
            success += useBacktracking(bottom, leftBottom, rightBottom, row + 1, n)  
  
            bottom[col] = false  
            leftBottom[leftBottomIndex] = false  
            rightBottom[rightBottomIndex] = false  
        }  
  
        return success;  
}  
  
  
    @Test  
    fun backtracking4() {  
        val n = 4  
        val expected = 2  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking5() {  
        val n = 5  
        val expected = 10  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking8() {  
        val n = 8  
        val expected = 92  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
}
```
