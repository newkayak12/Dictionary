
## 1. 재귀 함수(Recursive)
- 자기 자신을 호출하는 함수
- 일반적으로 문제를 작은 부분 문제로 나누어 해결할 때 사용한다.
- 문제의 크기를 줄여가며 계산을 반복하는 방식
- 재귀 함수는 반복문을 대신할 수 있다. 
- 특히 점화식으로 정의할 수 있는 경우에 유용하다.
- 예시1) 팩토리얼 계산
```kotlin
class Factorial {  
  
    @Test  
    fun calculate() {  
  
        val expected = 120  
        val result = recursive(5)  
  
        assertEquals(expected, result)  
    }  
  
    private fun recursive(number: Int): Int {  
        if( number <= 0) return 1;  
        return number * recursive(number - 1)  
    }  
}
```
- 예시2) 피보나치 수열
```kotlin
class Fibonacci {  
    @Test  
    fun calculate() {  
        val limit = 6  
        val expected = 8;  
        val result = fibonacci(limit)  
  
        assertEquals(expected, result)  
    }  
    private fun fibonacci (index: Int): Int {  
        return when(index) {  
            0 -> 0  
            1 -> 1  
            else -> recursive(0,1,2, index)  
        }  
    }  
    private fun recursive (first: Int, second: Int, count: Int, targetIndex: Int): Int {  
        if(targetIndex < count) return second  
        return recursive(second, first + second, count + 1, targetIndex)  
    }  
}
```

## 2. 분할 정복(Divide and Conquer)
- 문제를 여러 하위 문제로 분할하여 각각을 해결한 후, 그 해결 결과를 합쳐서 원래 문제를 해결하는 알고리즘 설계 기법
- 분할, 정복, 결합의 단계를 가진다.
- 독립적이고 작은 단위로 해결할 수 있게 해주며, 이를 큰 문제를 푸는 데 필요한 시간과 공간을 효율적으로 관리하는데 유리

## 3. 재귀적 백트래킹(Backtracking)
- 해결책을 찾기 위해 여러 선택지를 하나씩 시도하고, 잘못된 경로를 따라가면 이전 상태로 돌아가서 경로를 다시 시도
- 주로 **탐색 문제**에서 사용
- 가지치기를 통해 불필요한 경로를 제거하여 효율성을 높인다.
- 분기 탐색 방식으로, 해결책을 찾기 위한 탐색 트리를 따라가면서, 각 단계에서 가능한 선택을 탐색하고, 더 이상 진행할 수 없거나 유효하지 않으면 되돌아 간다.