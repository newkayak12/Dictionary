
## 1. 재귀 함수(Recursive)
- 자기 자신을 호출하는 함수
- 일반적으로 문제를 작은 부분 문제로 나누어 해결할 때 사용한다.
- 문제의 크기를 줄여가며 계산을 반복하는 방식
- 재귀 함수는 반복문을 대신할 수 있다. 
- 특히 점화식으로 정의할 수 있는 경우에 유용하다.
- 예시1) 팩토리얼 계산
```kotlin
class Factorial {  
  
    @Test  
    fun calculate() {  
  
        val expected = 120  
        val result = recursive(5)  
  
        assertEquals(expected, result)  
    }  
  
    private fun recursive(number: Int): Int {  
        if( number <= 0) return 1;  
        return number * recursive(number - 1)  
    }  
}
```
- 예시2) 피보나치 수열
```kotlin
class Fibonacci {  
    @Test  
    fun calculate() {  
        val limit = 6  
        val expected = 8;  
        val result = fibonacci(limit)  
  
        assertEquals(expected, result)  
    }  
    private fun fibonacci (index: Int): Int {  
        return when(index) {  
            0 -> 0  
            1 -> 1  
            else -> recursive(0,1,2, index)  
        }  
    }  
    private fun recursive (first: Int, second: Int, count: Int, targetIndex: Int): Int {  
        if(targetIndex < count) return second  
        return recursive(second, first + second, count + 1, targetIndex)  
    }  
}
```

## 2. 분할 정복(Divide and Conquer)
- 문제를 여러 하위 문제로 분할하여 각각을 해결한 후, 그 해결 결과를 합쳐서 원래 문제를 해결하는 알고리즘 설계 기법
- 분할, 정복, 결합의 단계를 가진다.
- 독립적이고 작은 단위로 해결할 수 있게 해주며, 이를 큰 문제를 푸는 데 필요한 시간과 공간을 효율적으로 관리하는데 유리
- 예시 1) 병합 정렬
```kotlin
class MergeSort {  
  
    @Test  
    fun mergeSort() {  
        val array = intArrayOf(38, 27, 43, 3, 9, 82, 10)  
        val expected = intArrayOf(3, 9, 10, 27, 38, 43, 82)  
  
        divide(array, 0, array.size - 1)  
        assertArrayEquals(expected, array)  
    }  
  
    private fun divide(array: IntArray, start: Int, end: Int) {  
        if (start < end) {  
            val mid = (start + end) / 2  
            divide(array, start, mid)  
            divide(array, mid + 1, end)  
            conquer(array, start, mid, end)  
        }  
    }  
  
    private fun conquer(array: IntArray, start: Int, mid: Int, end: Int) {  
        val mutableArray = mutableListOf<Int>()  
        var i = start  
        var j = mid + 1  
  
        while (i <= mid && j <= end) {  
            if (array[i] <= array[j]) mutableArray.add(array[i++])  
            else mutableArray.add(array[j++])  
        }  
        while (i <= mid) mutableArray.add(array[i++])  
        while (j <= end) mutableArray.add(array[j++])  
  
        for ( index in mutableArray.indices) {  
            array[start + index] = mutableArray[index]  
        }  
    }  
  
}
```
- 예시 2) 퀵정렬
```kotlin
class QuickSort {
	data class Container ( val left: Int, val right: Int, ){}

	@Test
	fun sort() {
		val list = giveMeArray()
		val expected = list.sorted().toIntArray()
		val array = list.toIntArray()

		quickSort(array, 0, array.size - 1)
		assertArrayEquals(expected, array)
	}

	private fun quickSort(array: IntArray, left: Int, right: Int) {
		var leftPoint = left
		var rightPoint = right
		var pivotValue = array[(left + right) / 2]

		do {
			while(array[leftPoint] < pivotValue) leftPoint += 1
			while(array[rightPoint] > pivotValue) rightPoint -= 1
	
			if(leftPoint <= rightPoint) {
				array[leftPoint] = array[rightPoint].also {
					array[rightPoint] = array[leftPoint]
				}
	
				leftPoint += 1
				rightPoint -= 1
			}
		} while(leftPoint <= rightPoint)

		if(left < rightPoint) quickSort(array, left, rightPoint)
		if(right > leftPoint) quickSort(array, leftPoint, right)
		
	}
}
```

## 3. 재귀적 백트래킹(Backtracking)

> 결정 문제나 최적화 문제를 해결할 때 가능한 모든 해를 재귀적으로 탐색하며, 
> 불가능하거나 필요 없는 경우 가지치키를 통해 탐색을 중단하는 방식

#### 3.1 무엇인가?
- 해결책을 찾기 위해 여러 선택지를 하나씩 시도하고, 잘못된 경로를 따라가면 이전 상태로 돌아가서 경로를 다시 시도
- 주로 **탐색 문제**에서 사용
- 가지치기를 통해 불필요한 경로를 제거하여 효율성을 높인다.
- 분기 탐색 방식으로, 해결책을 찾기 위한 탐색 트리를 따라가면서, 각 단계에서 가능한 선택을 탐색하고, 더 이상 진행할 수 없거나 유효하지 않으면 되돌아 간다.

#### 3.2 필요 이유?
- 완전 탐색을 하면 계산량이 기하급수적으로 폭증
- 재귀 호출로 탐색을 관리하고
- 조건을 만족하지 않는 경로는 바로 포기(Pruning)
- 예시 1) N Queen - 참고: [[격자 기하학(lattice geometry)]]
```kotlin
class NQueen {  
  
    /**  
     * 📌 문제 설명  
     *  
     * N × N 크기의 체스판 위에 N개의 퀸을 서로 공격하지 않게 놓으려고 합니다.  
     * 여기서 퀸은 같은 행, 열, 대각선 상에 있으면 서로 공격할 수 있습니다.  
     * 목표:  
     * N개의 퀸을 올바르게 놓을 수 있는 모든 경우의 수를 구하세요.  
     * ⸻  
     * 📥 입력  
     * 하나의 정수 N (4 ≤ N ≤ 15)     * ⸻  
     * 📤 출력  
     * 조건을 만족하는 퀸 배치의 총 경우의 수 (정수)  
     *     *     *  1. 각 행에 Q는 하나  
     *  2. 각 열에 Q는 아나  
     *  3. 대각선으로도 Q는 하나  
     *  4. 모든 경우의 수  
     *  
     *  {  
     *     
     *      만약 현재 row, col이 조건에 부합하지 않으면 종료  
     *      만약 현재 row가 n이면 가능하다고 체크  
     *  
     *     
     *      for(i 0 until n)     
     *          row, i에 둔다.  
     *          재귀 호출(row + 1)  
     *          row, i에 둔 것을 제거한다.  
     *  }     
     *     
     *     
     *  문제점  
     *  •  “어떻게 2차원적인 대각선 관계를 1차원 배열로 추상화하지?” → 여기서 막힘.  
     *    •  row + col
     *    •  row - col + (n - 1)
     *  •  “배열 크기는 또 얼마나 필요하지?” → 계산식 정리가 안 되면 못 씀.  -> 2*n - 1  
     */ 
     
  
    fun useBacktracking( bottom: BooleanArray, leftBottom: BooleanArray, rightBottom: BooleanArray, row: Int, n: Int): Int {  
  
        if(row == n) return  1  
  
        var success = 0;  
        for(col in 0 until n) {  
  
            val leftBottomIndex = row + col  
            val rightBottomIndex = row - col + n - 1  
            if(bottom[col] or leftBottom[leftBottomIndex] or rightBottom[rightBottomIndex]) continue  
  
            bottom[col] = true  
            leftBottom[leftBottomIndex] = true  
            rightBottom[rightBottomIndex] = true  
  
            success += useBacktracking(bottom, leftBottom, rightBottom, row + 1, n)  
  
            bottom[col] = false  
            leftBottom[leftBottomIndex] = false  
            rightBottom[rightBottomIndex] = false  
        }  
  
        return success;  
}  
  
  
    @Test  
    fun backtracking4() {  
        val n = 4  
        val expected = 2  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking5() {  
        val n = 5  
        val expected = 10  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
  
    @Test  
    fun backtracking8() {  
        val n = 8  
        val expected = 92  
        val bottom = BooleanArray(n)  
        val leftBottom = BooleanArray(2 * n - 1)  
        val rightBottom = BooleanArray(2 * n - 1)  
        val result = useBacktracking(bottom , leftBottom, rightBottom, 0, n)  
  
        assertEquals(expected, result)  
    }  
}
```
