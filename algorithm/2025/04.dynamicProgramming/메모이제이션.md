### 메모이제이션?
1. 한 번 계산한 값을 저장해두고, 같은 계산이 다시 필요할 때 꺼내 쓰는 기법
2. 보통 재귀에 적용, 계산 결과를 배열, 딕셔너리에 저장

### 굳이?
- 중복되는 부분 문제를 반복 계산하는 것을 피하기 위해서
- 중복 계산을 줄이면 시간 복잡도를 줄일 수 있다.
- 재귀에서 주로 많이 생긴다. 재귀 자체가 작은 문제를 계속 호출하는 구조이기 때문에 같은 서브 문제를 여러 번 호출하게 된다.

### 구현!?
- 탑 다운 방식
- 함수 호출 전 해당 입력이 있는지 찾고 있으면 반환, 없으면 계산한다.

### 메모이제이션과 DP?
- DP 구현 방식 중 하나
- 바텀 업이 반복문 기반이라면 메모이제이션은 재귀 기반 탑다운 

### 기초 예시
```
🔹 문제 상황
 n번째 피보나치 수를 구하라.
 
  -> **🔍 이걸 재귀로 풀면?**
  
f(5)
├── f(4)
│   ├── f(3)
│   │   ├── f(2)
│   │   │   ├── f(1)
│   │   │   └── f(0)
│   │   └── f(1)
│   └── f(2)
│       ├── f(1)
│       └── f(0)
└── f(3)
    ├── f(2)
    │   ├── f(1)
    │   └── f(0)
    └── f(1)

이제 메모이제이션을 도입해보면?

- 한 번 f(3)을 계산했으면 → 저장해둠
- 다음에 또 f(3)이 필요하면 → **저장된 값을 바로 반환**
```

**즉, 작은 문제를 여러 번 다시 부르게 된다면 -> 메모이제이션이 필요하다**
- PseudoCode
```
function fib(n):
    if n == 0: return 0
    if n == 1: return 1

    if memo[n] is not empty:
        return memo[n]

    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

- 예시 1)
```kotlin
class FibonacciWithMemoization {  
    /**  
     * 🧪 문제 이름  
     *  
     * 기억하는 피보나치  
     * ⸻  
     * 📄 문제 설명  
     *  
     * 정수 n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하세요.  
     *     
     * 단, 함수 fib(n)은 다음과 같이 정의됩니다:  
     *  •  fib(0) = 0     
     *  •  fib(1) = 1     
     *  •  fib(n) = fib(n-1) + fib(n-2) (n ≥ 2)     
     *     
     * 단, 이 계산은 반드시 “메모이제이션”을 사용한 방식으로 수행되어야 합니다.  
     * (중복 호출을 허용하지 않으며, 이미 계산한 fib(k)는 다시 계산하지 않아야 합니다)  
     * ⸻  
     * 📥 입력  
     *  •  정수 n (0 ≤ n ≤ 100)     * ⸻  
     * 📤 출력  
     *  •  n번째 피보나치 수  
     */  
  
    @Nested  
    inner class Solution {  
  
        @Test  
        fun fibonacci5() {  
            val expected = 5  
            val result = fibonacci(mutableMapOf<Int, Int>(), 5)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci10() {  
            val expected = 55  
            val result = fibonacci(mutableMapOf<Int, Int>(), 10)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci20() {  
            val expected = 6765  
            val result = fibonacci(mutableMapOf<Int, Int>(), 20)  
  
            assertEquals(expected, result)  
        }  
    }  
  
	private fun fibonacci(memoization: MutableMap<Int, Int>, number: Int): Int  {  
	    return when (number) {  
	        0 -> 0  
	        1 -> 1  
	        else -> memoization[number] ?: run {  
	            val result = fibonacci(memoization, number - 2) + fibonacci(memoization, number - 1)  
	            memoization[number] = result  
	            return result  
	        }  
	    }  
	} 
}
```
