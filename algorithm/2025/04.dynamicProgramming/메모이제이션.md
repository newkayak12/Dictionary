### ë©”ëª¨ì´ì œì´ì…˜?
1. í•œ ë²ˆ ê³„ì‚°í•œ ê°’ì„ ì €ì¥í•´ë‘ê³ , ê°™ì€ ê³„ì‚°ì´ ë‹¤ì‹œ í•„ìš”í•  ë•Œ êº¼ë‚´ ì“°ëŠ” ê¸°ë²•
2. ë³´í†µ ì¬ê·€ì— ì ìš©, ê³„ì‚° ê²°ê³¼ë¥¼ ë°°ì—´, ë”•ì…”ë„ˆë¦¬ì— ì €ì¥

### êµ³ì´?
- ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ì œë¥¼ ë°˜ë³µ ê³„ì‚°í•˜ëŠ” ê²ƒì„ í”¼í•˜ê¸° ìœ„í•´ì„œ
- ì¤‘ë³µ ê³„ì‚°ì„ ì¤„ì´ë©´ ì‹œê°„ ë³µì¡ë„ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
- ì¬ê·€ì—ì„œ ì£¼ë¡œ ë§ì´ ìƒê¸´ë‹¤. ì¬ê·€ ìì²´ê°€ ì‘ì€ ë¬¸ì œë¥¼ ê³„ì† í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°ì´ê¸° ë•Œë¬¸ì— ê°™ì€ ì„œë¸Œ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•˜ê²Œ ëœë‹¤.

### êµ¬í˜„!?
- íƒ‘ ë‹¤ìš´ ë°©ì‹
- í•¨ìˆ˜ í˜¸ì¶œ ì „ í•´ë‹¹ ì…ë ¥ì´ ìˆëŠ”ì§€ ì°¾ê³  ìˆìœ¼ë©´ ë°˜í™˜, ì—†ìœ¼ë©´ ê³„ì‚°í•œë‹¤.

### ë©”ëª¨ì´ì œì´ì…˜ê³¼ DP?
- DP êµ¬í˜„ ë°©ì‹ ì¤‘ í•˜ë‚˜
- ë°”í…€ ì—…ì´ ë°˜ë³µë¬¸ ê¸°ë°˜ì´ë¼ë©´ ë©”ëª¨ì´ì œì´ì…˜ì€ ì¬ê·€ ê¸°ë°˜ íƒ‘ë‹¤ìš´ 

### ê¸°ì´ˆ ì˜ˆì‹œ
```
ğŸ”¹ ë¬¸ì œ ìƒí™©
 në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ë¼.
 
  -> **ğŸ” ì´ê±¸ ì¬ê·€ë¡œ í’€ë©´?**
  
f(5)
â”œâ”€â”€ f(4)
â”‚ Â  â”œâ”€â”€ f(3)
â”‚ Â  â”‚ Â  â”œâ”€â”€ f(2)
â”‚ Â  â”‚ Â  â”‚ Â  â”œâ”€â”€ f(1)
â”‚ Â  â”‚ Â  â”‚ Â  â””â”€â”€ f(0)
â”‚ Â  â”‚ Â  â””â”€â”€ f(1)
â”‚ Â  â””â”€â”€ f(2)
â”‚ Â  Â  Â  â”œâ”€â”€ f(1)
â”‚ Â  Â  Â  â””â”€â”€ f(0)
â””â”€â”€ f(3)
Â  Â  â”œâ”€â”€ f(2)
Â  Â  â”‚ Â  â”œâ”€â”€ f(1)
Â  Â  â”‚ Â  â””â”€â”€ f(0)
Â  Â  â””â”€â”€ f(1)

ì´ì œ ë©”ëª¨ì´ì œì´ì…˜ì„ ë„ì…í•´ë³´ë©´?

- í•œ ë²ˆ f(3)ì„ ê³„ì‚°í–ˆìœ¼ë©´ â†’ ì €ì¥í•´ë‘ 
- ë‹¤ìŒì— ë˜ f(3)ì´ í•„ìš”í•˜ë©´ â†’ **ì €ì¥ëœ ê°’ì„ ë°”ë¡œ ë°˜í™˜**
```

**ì¦‰, ì‘ì€ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ë²ˆ ë‹¤ì‹œ ë¶€ë¥´ê²Œ ëœë‹¤ë©´ -> ë©”ëª¨ì´ì œì´ì…˜ì´ í•„ìš”í•˜ë‹¤**
- PseudoCode
```
function fib(n):
    if n == 0: return 0
    if n == 1: return 1

    if memo[n] is not empty:
        return memo[n]

    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

- ì˜ˆì‹œ 1)
```kotlin
class FibonacciWithMemoization {  
    /**  
     * ğŸ§ª ë¬¸ì œ ì´ë¦„  
     *  
     * ê¸°ì–µí•˜ëŠ” í”¼ë³´ë‚˜ì¹˜  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì„¸ìš”.  
     *     
     * ë‹¨, í•¨ìˆ˜ fib(n)ì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë©ë‹ˆë‹¤:  
     *  â€¢  fib(0) = 0     
     *  â€¢  fib(1) = 1     
     *  â€¢  fib(n) = fib(n-1) + fib(n-2) (n â‰¥ 2)     
     *     
     * ë‹¨, ì´ ê³„ì‚°ì€ ë°˜ë“œì‹œ â€œë©”ëª¨ì´ì œì´ì…˜â€ì„ ì‚¬ìš©í•œ ë°©ì‹ìœ¼ë¡œ ìˆ˜í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.  
     * (ì¤‘ë³µ í˜¸ì¶œì„ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©°, ì´ë¯¸ ê³„ì‚°í•œ fib(k)ëŠ” ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤)  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (0 â‰¤ n â‰¤ 100)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜  
     */  
  
    @Nested  
    inner class Solution {  
  
        @Test  
        fun fibonacci5() {  
            val expected = 5  
            val result = fibonacci(mutableMapOf<Int, Int>(), 5)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci10() {  
            val expected = 55  
            val result = fibonacci(mutableMapOf<Int, Int>(), 10)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci20() {  
            val expected = 6765  
            val result = fibonacci(mutableMapOf<Int, Int>(), 20)  
  
            assertEquals(expected, result)  
        }  
    }  
  
	private fun fibonacci(memoization: MutableMap<Int, Int>, number: Int): Int  {  
	    return when (number) {  
	        0 -> 0  
	        1 -> 1  
	        else -> memoization[number] ?: run {  
	            val result = fibonacci(memoization, number - 2) + fibonacci(memoization, number - 1)  
	            memoization[number] = result  
	            return result  
	        }  
	    }  
	} 
}
```
