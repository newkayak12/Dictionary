### 메모이제이션?
1. 한 번 계산한 값을 저장해두고, 같은 계산이 다시 필요할 때 꺼내 쓰는 기법
2. 보통 재귀에 적용, 계산 결과를 배열, 딕셔너리에 저장

### 굳이?
- 중복되는 부분 문제를 반복 계산하는 것을 피하기 위해서
- 중복 계산을 줄이면 시간 복잡도를 줄일 수 있다.
- 재귀에서 주로 많이 생긴다. 재귀 자체가 작은 문제를 계속 호출하는 구조이기 때문에 같은 서브 문제를 여러 번 호출하게 된다.

### 구현!?
- 탑 다운 방식
- 함수 호출 전 해당 입력이 있는지 찾고 있으면 반환, 없으면 계산한다.

### 메모이제이션과 DP?
- DP 구현 방식 중 하나
- 바텀 업이 반복문 기반이라면 메모이제이션은 재귀 기반 탑다운 

### 기초 예시
```
🔹 문제 상황
 n번째 피보나치 수를 구하라.
 
  -> **🔍 이걸 재귀로 풀면?**
  
f(5)
├── f(4)
│   ├── f(3)
│   │   ├── f(2)
│   │   │   ├── f(1)
│   │   │   └── f(0)
│   │   └── f(1)
│   └── f(2)
│       ├── f(1)
│       └── f(0)
└── f(3)
    ├── f(2)
    │   ├── f(1)
    │   └── f(0)
    └── f(1)

이제 메모이제이션을 도입해보면?

- 한 번 f(3)을 계산했으면 → 저장해둠
- 다음에 또 f(3)이 필요하면 → **저장된 값을 바로 반환**
```

**즉, 작은 문제를 여러 번 다시 부르게 된다면 -> 메모이제이션이 필요하다**
- PseudoCode
```
function fib(n):
    if n == 0: return 0
    if n == 1: return 1

    if memo[n] is not empty:
        return memo[n]

    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```