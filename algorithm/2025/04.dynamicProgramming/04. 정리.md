## **🟩** 

## **동적 계획법(DP) – 전체 정리**

---

### **1️⃣** 

### **정의**

  

동적 계획법(Dynamic Programming)은

**하나의 큰 문제를 여러 개의 작은 문제로 나누고**,

그 작은 문제의 **중복되는 계산 결과를 저장/재사용**해서

효율적으로 전체 문제를 해결하는 기법입니다.

---

### **2️⃣** 

### **적용 조건 (핵심 원리)**

  

🔹 **최적 부분 구조 (Optimal Substructure)**

큰 문제의 최적해가 **작은 문제의 최적해로 구성**될 수 있는 경우.

예) 피보나치, 배낭 문제, LCS

  

🔹 **중복 부분 문제 (Overlapping Subproblems)**

같은 작은 문제를 **여러 번 반복해서 풀어야** 하는 경우.

예) 피보나치에서 f(n-1), f(n-2)가 계속 겹침

---

### **3️⃣** 

### **핵심 방식**

  

✅ **탑다운 (Top-Down)** – 재귀 + 메모이제이션

- 재귀로 큰 문제부터 쪼개면서 계산
    
- 이미 계산한 결과는 배열/해시맵에 저장
    
- 중복 호출 방지
    

  

✅ **바텀업 (Bottom-Up)** – 반복문으로 작은 문제부터 쌓음

- 작은 문제를 먼저 계산해서 배열로 저장
    
- 작은 문제의 해를 이용해 점점 큰 문제로 확장

### **4️⃣** 

### **점화식 설계 (패턴)**

- 각 문제의 **현재 상태**를 정의: dp[i], dp[i][j] 등
    
- **어떤 선택(결정)**을 할 때 이전 상태와 연결되는지 찾음
    
- 작은 문제의 최적해를 조합 → **점화식**으로 표현
    

  

예)

- **피보나치**: dp[i] = dp[i-1] + dp[i-2]
    
- **0/1 배낭**: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight]+value)
    
- **LCS**:
    
        if 같으면 dp[i][j] = dp[i-1][j-1] + 1
    
        else dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    

---

### **5️⃣** 

### **문제 예시 – 실제 적용**

- **피보나치 수열**: 가장 기본적인 DP
    
- **0/1 배낭 문제**: 선택/비선택의 최적화
    
- **LCS(최장 공통 부분 수열)**: 문자열에서 공통 부분 찾기
    
- **편집 거리 (Edit Distance)**: 최소 편집 횟수
    
- **최장 증가 부분 수열 (LIS)**: 수열 중 오름차순 부분 찾기
    
- **공통 부분 문자열 (LCSubstring)**: 연속된 일치 부분 찾기
    

---

### **6️⃣** 

### **최종 정리 – 핵심 3단계**

  

✅ **① dp 배열/테이블 의미를 정확히 정의**

- ex) dp[i][j] = A의 i번째, B의 j번째까지의 최적 상태
    

  

✅ **② 점화식/관계식 유도**

- ex) 같은가? 다르면? → 이전 상태로부터 어떻게 이어짐?
    

  

✅ **③ 메모이제이션 or 바텀업 구현**

- 재귀(Top-Down)로 구현할지, 반복문(Bottom-Up)으로 구현할지 결정