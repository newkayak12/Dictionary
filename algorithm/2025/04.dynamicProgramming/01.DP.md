> ìµœì í™” ë¬¸ì œ í•´ê²° ê¸°ë²•
> - "ì´ ìƒíƒœì— ë„ë‹¬í•˜ëŠ” ìµœì„ ì˜ ë°©ë²•"ì— ì¤‘ì 
> - ë°°ì—´/ í…Œì´ë¸”ë¡œ ì´ì „ ê²°ê³¼ë¥¼ ì¬í™œìš©í•œë‹¤.

> ì ‘ê·¼ ê°€ëŠ¥ ë¬¸ì œ
> - ìµœì  ë¶€ë¶„ êµ¬ì¡°
> - ì¤‘ë³µ ë¶€ë¶„ ë¬¸ì œ 

### ë©”ëª¨ì´ì œì´ì…˜?
1. í•œ ë²ˆ ê³„ì‚°í•œ ê°’ì„ ì €ì¥í•´ë‘ê³ , ê°™ì€ ê³„ì‚°ì´ ë‹¤ì‹œ í•„ìš”í•  ë•Œ êº¼ë‚´ ì“°ëŠ” ê¸°ë²•
2. ë³´í†µ ì¬ê·€ì— ì ìš©, ê³„ì‚° ê²°ê³¼ë¥¼ ë°°ì—´, ë”•ì…”ë„ˆë¦¬ì— ì €ì¥

### êµ³ì´?
- ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ ë¬¸ì œë¥¼ ë°˜ë³µ ê³„ì‚°í•˜ëŠ” ê²ƒì„ í”¼í•˜ê¸° ìœ„í•´ì„œ
- ì¤‘ë³µ ê³„ì‚°ì„ ì¤„ì´ë©´ ì‹œê°„ ë³µì¡ë„ë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
- ì¬ê·€ì—ì„œ ì£¼ë¡œ ë§ì´ ìƒê¸´ë‹¤. ì¬ê·€ ìì²´ê°€ ì‘ì€ ë¬¸ì œë¥¼ ê³„ì† í˜¸ì¶œí•˜ëŠ” êµ¬ì¡°ì´ê¸° ë•Œë¬¸ì— ê°™ì€ ì„œë¸Œ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•˜ê²Œ ëœë‹¤.

### êµ¬í˜„!?
- íƒ‘ ë‹¤ìš´ ë°©ì‹
- í•¨ìˆ˜ í˜¸ì¶œ ì „ í•´ë‹¹ ì…ë ¥ì´ ìˆëŠ”ì§€ ì°¾ê³  ìˆìœ¼ë©´ ë°˜í™˜, ì—†ìœ¼ë©´ ê³„ì‚°í•œë‹¤.

### ë©”ëª¨ì´ì œì´ì…˜ê³¼ ì í™”ì‹?
- DP êµ¬í˜„ ë°©ì‹ ì¤‘ í•˜ë‚˜
- ì í™”ì‹(bottom-up)ì´ ë°˜ë³µë¬¸ ê¸°ë°˜(ì í™”ì‹)ì´ë¼ë©´ ë©”ëª¨ì´ì œì´ì…˜(top-down)ì€ ì¬ê·€ ê¸°ë°˜ íƒ‘ë‹¤ìš´ 

### ê¸°ì´ˆ ì˜ˆì‹œ
```
ğŸ”¹ ë¬¸ì œ ìƒí™©
 në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ë¼.
 
  -> **ğŸ” ì´ê±¸ ì¬ê·€ë¡œ í’€ë©´?**
  
f(5)
â”œâ”€â”€ f(4)
â”‚ Â  â”œâ”€â”€ f(3)
â”‚ Â  â”‚ Â  â”œâ”€â”€ f(2)
â”‚ Â  â”‚ Â  â”‚ Â  â”œâ”€â”€ f(1)
â”‚ Â  â”‚ Â  â”‚ Â  â””â”€â”€ f(0)
â”‚ Â  â”‚ Â  â””â”€â”€ f(1)
â”‚ Â  â””â”€â”€ f(2)
â”‚ Â  Â  Â  â”œâ”€â”€ f(1)
â”‚ Â  Â  Â  â””â”€â”€ f(0)
â””â”€â”€ f(3)
Â  Â  â”œâ”€â”€ f(2)
Â  Â  â”‚ Â  â”œâ”€â”€ f(1)
Â  Â  â”‚ Â  â””â”€â”€ f(0)
Â  Â  â””â”€â”€ f(1)

ì´ì œ ë©”ëª¨ì´ì œì´ì…˜ì„ ë„ì…í•´ë³´ë©´?

- í•œ ë²ˆ f(3)ì„ ê³„ì‚°í–ˆìœ¼ë©´ â†’ ì €ì¥í•´ë‘ 
- ë‹¤ìŒì— ë˜ f(3)ì´ í•„ìš”í•˜ë©´ â†’ **ì €ì¥ëœ ê°’ì„ ë°”ë¡œ ë°˜í™˜**
```

**ì¦‰, ì‘ì€ ë¬¸ì œë¥¼ ì—¬ëŸ¬ ë²ˆ ë‹¤ì‹œ ë¶€ë¥´ê²Œ ëœë‹¤ë©´ -> ë©”ëª¨ì´ì œì´ì…˜ì´ í•„ìš”í•˜ë‹¤**
- PseudoCode
```
function fib(n):
    if n == 0: return 0
    if n == 1: return 1

    if memo[n] is not empty:
        return memo[n]

    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]
```

- ì˜ˆì‹œ 1)
```kotlin
class FibonacciWithMemoization {  
    /**  
     * ğŸ§ª ë¬¸ì œ ì´ë¦„  
     *  
     * ê¸°ì–µí•˜ëŠ” í”¼ë³´ë‚˜ì¹˜  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì„¸ìš”.  
     *     
     * ë‹¨, í•¨ìˆ˜ fib(n)ì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜ë©ë‹ˆë‹¤:  
     *  â€¢  fib(0) = 0     
     *  â€¢  fib(1) = 1     
     *  â€¢  fib(n) = fib(n-1) + fib(n-2) (n â‰¥ 2)     
     *     
     * ë‹¨, ì´ ê³„ì‚°ì€ ë°˜ë“œì‹œ â€œë©”ëª¨ì´ì œì´ì…˜â€ì„ ì‚¬ìš©í•œ ë°©ì‹ìœ¼ë¡œ ìˆ˜í–‰ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.  
     * (ì¤‘ë³µ í˜¸ì¶œì„ í—ˆìš©í•˜ì§€ ì•Šìœ¼ë©°, ì´ë¯¸ ê³„ì‚°í•œ fib(k)ëŠ” ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•Šì•„ì•¼ í•©ë‹ˆë‹¤)  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (0 â‰¤ n â‰¤ 100)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜  
     */  
  
    @Nested  
    inner class Solution {  
  
        @Test  
        fun fibonacci5() {  
            val expected = 5  
            val result = fibonacci(mutableMapOf<Int, Int>(), 5)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci10() {  
            val expected = 55  
            val result = fibonacci(mutableMapOf<Int, Int>(), 10)  
  
            assertEquals(expected, result)  
        }  
  
        @Test  
        fun fibonacci20() {  
            val expected = 6765  
            val result = fibonacci(mutableMapOf<Int, Int>(), 20)  
  
            assertEquals(expected, result)  
        }  
    }  
  
	private tailrec fun fibonacci(memoization: MutableMap<Int, Int>, number: Int): Int  {  
	    return when (number) {  
	        0 -> 0  
	        1 -> 1  
	        else -> memoization[number] ?: run {  
	            val result = fibonacci(memoization, number - 2) + fibonacci(memoization, number - 1)  
	            memoization[number] = result  
	            return result  
	        }  
	    }  
	} 
}
```
- ì˜ˆì‹œ 2) ê°œêµ¬ë¦¬ ì í”„ - í˜„ì¬ í•´ë‹µì´ ì´ì „ í•´ë‹µì„ ì´ìš©í•´ì„œ ê³„ì‚°í•œë‹¤. -> ì í™”ì‹
```kotlin
class JumpingFrog {  
    /**  
     * ğŸ§ª ë¬¸ì œ ì´ë¦„  
     *  
     * ê°œêµ¬ë¦¬ ì í”„  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * ê¸¸ì´ê°€ nì¸ ì§ì„  ìœ„ì— ê°œêµ¬ë¦¬ê°€ ì„œ ìˆìŠµë‹ˆë‹¤.  
     * ê°œêµ¬ë¦¬ëŠ” 1ì¹¸ í˜¹ì€ 2ì¹¸ì”©ë§Œ ì•ìœ¼ë¡œ ì í”„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ê°œêµ¬ë¦¬ê°€ 0ë²ˆ ìœ„ì¹˜ì—ì„œ ì¶œë°œí•´ì„œ në²ˆ ìœ„ì¹˜ì— ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (1 â‰¤ n â‰¤ 100)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  0ë²ˆ ì¹¸ì—ì„œ ì‹œì‘í•´ì„œ në²ˆ ì¹¸ì— ë„ë‹¬í•˜ëŠ” ì´ ë°©ë²•ì˜ ìˆ˜  
     *  ğŸ§ª ì˜ˆì œ  
     *  ì…ë ¥    ì¶œë ¥      ì„¤ëª…  
     *   1      1      0 â†’ 1  
     *   2      2      0â†’1â†’2, 0â†’2     
     *   3      3      0â†’1â†’2â†’3 0â†’1â†’3 0â†’2â†’3    
     *   4      5      [0â†’1â†’2â†’3â†’4], [0â†’1â†’2â†’4], [0â†’2â†’3â†’4], [0â†’1â†’3â†’4], [0â†’2â†’4]     
	 *
	 */  
	 
    @Test  
    fun solution() {  
        /**  
         * f(1) = 1 
         * f(2) = 2 
         * f(3) = 3 
         * f(4) = 5 
         * 
         * - í˜„ì¬ í•´ë‹µì´ ì´ì „ í•´ë‹µì„ ì´ìš©í•´ì„œ ê³„ì‚°í•˜ëŠ”ê°€? -> ì í™”ì‹ ê°€ëŠ¥  
         * - ê°™ì€ ê³„ì‚°ì´ ë°˜ë³µë˜ëŠ”ê°€? -> ë©”ëª¨ì´ì œì´ì…˜  
         * - í•˜ìœ„ ë¬¸ì œë¥¼ í•´ê²°í•˜ë©´ ìƒìœ„ ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ”ê°€? -> DP  
         * => ì í™”ì‹  
         */  
    }  
  
    private tailrec fun fibonacci(memoization: MutableMap<Int, Int>, number: Int): Int  {  
        return when (number) {  
            0 -> 0  
            1 -> 1  
            else -> memoization[number] ?: run {  
                val result = fibonacci(memoization, number - 2) + fibonacci(memoization, number - 1)  
                memoization[number] = result  
                return result  
            }  
        }  
    }  
}

/**
 * > â€œíŒ¨í„´ì„ ì°¾ëŠ” ê²ƒâ€
 * -> â€œì‘ê²Œ í’€ì–´ë³´ëŠ” ìŠµê´€â€
 * -> â€œë„ë‹¬ ê²½ë¡œë¥¼ ìê¾¸ ì§ˆë¬¸í•˜ëŠ” ë²„ë¦‡â€
 * -> â€œì´ê²Œ ì´ì „ ìƒíƒœë“¤ë¡œ ë§Œë“¤ì–´ì§€ë‚˜?â€ë¼ëŠ” ì˜ì‹¬ì´ í•„ìš”í•˜ë‹¤.
 */ 
    
```
- ì˜ˆì‹œ 3) 1,2,3ìœ¼ë¡œ ëª©í‘œí•œ ìˆ«ì ë§Œë“¤ê¸°

```kotlin
class PlusOneTwoThree {  
    /**  
     * ğŸ§ª ë¬¸ì œ ì´ë¦„  
     *  
     * 1, 2, 3 ë”í•˜ê¸°  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì •ìˆ˜ 1, 2, 3ì„ ì‚¬ìš©í•˜ì—¬ nì„ ë§Œë“œëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * ë‹¨, ìˆ«ìì˜ ìˆœì„œê°€ ë‹¤ë¥´ë©´ ë‹¤ë¥¸ ê²½ìš°ë¡œ ì¹©ë‹ˆë‹¤.  
     * ì˜ˆ:  
     *  â€¢  4 = 1+1+1+1 = 1+1+2 = 1+2+1 = 2+1+1 = 2+2 = 1+3 = 3+1     * â†’ ì´ 7ê°€ì§€  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (1 â‰¤ n â‰¤ 20)     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  nì„ ë§Œë“œëŠ” ì´ ê²½ìš°ì˜ ìˆ˜ (1, 2, 3ì„ ë”í•´ì„œ)  
     * â¸»  
     * ğŸ§ª ì˜ˆì œ  
     * ì…ë ¥ ì¶œë ¥  
     *  3   4  
     *  4   7     
     *  5   13     
     *     
     * 1 -> 1     
     * (1)     
     * 2 -> 2     
     * (1+1), (2)     
     * 3 -> 4     
     * (1+1+1), (1+2), (2+1), (3)     
     * 4 -> 7     
     * (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2), (1+3), (3+1)     
     * 5 -> 13     
     *     
     * p(n) = p(n-3) + p(n-2) + p(n-1)ë¡œ ì í™”ì‹ì„ ì§¤ ìˆ˜ ìˆë‹¤.  
     *     
     *     
     * pseudo -     
     *     
     * fun oneTwoThree number:Int, map: MutableMap    
     *      when number    
     *        1 -> 1     
     *        2 -> 2     
     *        3 -> 4     
     *        else -> map[number] ?: run {     
     *           val result = oneTwoThree(number-3,map) + oneTwoThree(number-2,map) + oneTwoThree(number-1, map)     
     *           map[number] = result     
     *     
     *           return result     
     *        
     *         }     
     * 
     */
 }
 // 2 ~ 3ê°œì—ì„œ íŒ¨í„´ì„ ì°¾ìœ¼ë©´ ì í™”ì‹ì„ ì„¸ìš°ëŠ”ê²Œ ë‚˜ìœ ë°©ë²•ì´ ì•„ë‹ˆë‹¤.
 // ë‹¨, ì´ì „ ê²°ê³¼ì—ì„œ ë‹¤ìŒ ê²°ê³¼ë¥¼ ìœ ì¶”í•  ë•Œ
```

3) ë©€ë¦¬ ë›°ê¸°
```kotlin
class `ë©€ë¦¬ ë›°ê¸°` {  
    //DFS  
    /**  
     * https://school.programmers.co.kr/learn/courses/30/lessons/12914?language=kotlin
     * */  
    @Test  
    fun solution1() {  
        val n = 4  
        val expected = 5L  
  
  
        assertEquals(expected, `top-down`(n))  
        assertEquals(expected, `bottom-up`(n))  
        assertEquals(expected, useStack(n))  
        assertEquals(expected, useRecursive(n))  
    }  
  
    @Test  
    fun solution2() {  
        val n = 3  
        val expected = 3L  
  
        assertEquals(expected, `top-down`(n))  
        assertEquals(expected, `bottom-up`(n))  
        assertEquals(expected, useStack(n))  
        assertEquals(expected, useRecursive(n))  
    }  
  
    private fun `bottom-up`(n: Int): Long {  
        return when (n) {  
            1 -> 1  
            2 -> 2  
            else -> `bottom-upUseRecursive`(1, 2, 2, n)  
        }  
    }  
  
    private fun `bottom-upUseRecursive`(first: Int, second: Int, count: Int, limit: Int): Long {  
        if (count == limit) return second.toLong()  
        return `bottom-upUseRecursive`(second % 1234567, (first + second) % 1234567, count + 1, limit)  
    }  
  
    private fun `top-down`(n: Int): Long {  
        return `top-downUseMemoization`(mutableMapOf<Long, Long>(), n.toLong())  
    }  
  
    private fun `top-downUseMemoization`(memoization: MutableMap<Long, Long>, number: Long): Long {  
        return when (number) {  
            1L -> 1L  
            2L -> 2L  
            else -> memoization[number] ?: run {  
                val result = `top-downUseMemoization`(memoization, number - 1)  % 1234567 +  
                             `top-downUseMemoization`(memoization, number - 2)  % 1234567  
  
                memoization[number] = result  
                result  
            }  
        }  
  
    }  
  
    private fun useStack(n: Int): Long {  
        var count = 0L  
        val stack = ArrayDeque<Long>()  
        stack.add(n.toLong())  
  
        while (stack.isNotEmpty()) {  
            val pop = stack.removeLast()  
            if (pop <= 1) {  
                count++  
                continue  
            }  
  
            stack.addLast(pop - 1)  
            stack.addLast(pop - 2)  
        }  
  
        return count % 1234567  
    }  
  
    private fun useRecursive(n: Int): Long = recursive(n)  
  
    private fun recursive(n: Int): Long {  
        if (n <= 1) return 1  
  
  
        var count = 0L;  
        for (i in 1..2) {  
            count += recursive(n - i)  
        }  
  
        return count % 1234567  
    }  
}
```

### í•µì‹¬ì ìœ¼ë¡œ?

|  í•­ëª©   |       <center>ë‚´ìš©</center>       |
| :---: | :-----------------------------: |
|  í•µì‹¬   | f(n)ì´ ë¬¸ì œì—ì„œ ë¬´ìŠ¨ ì˜ë¯¸ë¥¼ ê°€ì§€ëŠ”ì§€ ì´í•´í•´ì•¼ í•œë‹¤. |
| ìë£Œ êµ¬ì¡° |           Array, Map            |
| í˜¸ì¶œ íë¦„ |   ìºì‹œ í™•ì¸ -> ì—†ìœ¼ë©´ ê³„ì‚° -> ì €ì¥ í›„ ë°˜í™˜    |
| ì´ˆê¸° ì¡°ê±´ |          ì¬ê·€ ì¢…ë£Œ ì¡°ê±´ì„ ëª…í™•íˆ          |
|  ì í™”ì‹  |     ë¬¸ì œì˜ êµ¬ì¡°ê°€ í˜„ì¬ == ê³¼ê±° ì¡°í•©ì¼ ë•Œë§Œ     |
- ê²°ê³¼ì ìœ¼ë¡œ DP, ë©”ëª¨ì´ì œì´ì…˜ì€ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” êµ¬ì¡° ì„¤ê³„ë‹¤.