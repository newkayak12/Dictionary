### Top-down
- ì¬ê·€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ë©´ì„œ ë‚´ë ¤ê°„ë‹¤.
- ì¤‘ë³µë˜ëŠ” ê³„ì‚° ê²°ê³¼ëŠ” ì €ì¥í•´ì„œ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•ŠëŠ”ë‹¤.
> #### ë‚´ë¶€ êµ¬ì¡°
> - f(n) í˜¸ì¶œ -> (f(n-1), f(n-2)) í˜¸ì¶œ -> ê²°ê³¼ë¥¼ ì €ì¥í•˜ë©´ì„œ ëŒì•„ì˜¤ê³  ëˆ„ì 
 

### Bottom-up
- ì‘ì€ ë¬¸ì œì—ì„œ í° ë¬¸ì œê¹Œì§€ ë°˜ë³µì ìœ¼ë¡œ ì˜¬ë¼ê°€ë©°, í•„ìš”í•œ ê°’ì„ í…Œì´ë¸”ì— ì§ì ‘ ì±„ìš°ëŠ” ë°©ì‹
> #### ë‚´ë¶€ êµ¬ì¡°
> - dp[0], dp[1] ì´ˆê¸° ê°’ ì„¤ì •
> - for i in 2 .. n ë°˜ë³µí•´ê°€ë©° dp[i] ê³„ì‚°

|   í•­ëª©    |        Top-down        |     Bottom-up     |
| :-----: | :--------------------: | :---------------: |
|   êµ¬ì¡°    |    ì¬ê·€ + memoization    |     ë°˜ë³µë¬¸ + ë°°ì—´      |
|  ìºì‹± ìœ„ì¹˜  |         í•¨ìˆ˜ ë‚´ë¶€          |      ì™¸ë¶€ í…Œì´ë¸”       |
|  ê³„ì‚° ìˆœì„œ  |     í° ë¬¸ì œ -> ì‘ì€ ë¬¸ì œ      |   ì‘ì€ ë¬¸ì œ -> í° ë¬¸ì œ   |
|  ê³„ì‚° ë²”ìœ„  |        í•„ìš”í•œ ë§Œí¼ë§Œ         |     ëŒ€ë¶€ë¶„ ëª¨ë“  ìƒíƒœ     |
|   ì¥ì     |     ì§ê´€ì , ì¡°ê±´ ë¶„ê¸° ìœ ì—°      |    ë¹ ë¦„, ë©”ëª¨ë¦¬ ì•ˆì •     |
|   ë‹¨ì     |   ìŠ¤íƒ ê¹Šì´ ë¬¸ì œ, ë””ë²„ê¹… ì–´ë ¤ì›€    |    ë¶ˆí•„ìš”í•œ ê³„ì‚° í¬í•¨     |
| ì–¸ì œ ì„ íƒí•˜ë‚˜ | ë¬¸ì œ êµ¬ì¡°ê°€ ë³µì¡í•˜ê³  ì¡°ê±´ ë¶„ê¸°ê°€ ë§ë‹¤. | ì…ë ¥ í¬ê¸°ê°€ í¬ê³  ë°˜ë³µ êµ¬ì¡°ë‹¤. |

- ì˜ˆì‹œ 1) í”¼ë³´ë‚˜ì¹˜ bottom-upìœ¼ë¡œ ì¬êµ¬ì„±
```kotlin
class FibonacciBottomUp {  
  
    /**  
     * ğŸ“„ ë¬¸ì œ ìš”ì•½  
     *  
     * ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * (f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2))     
     */
     

	@Test  
    fun fibonacciBottomUp(){  
        assertEquals(5, bottomUp(5))  
    }  
  
    private fun bottomUp(number: Int): Int {  
        val table = Array(number + 1) { i ->  
            when(i) {  
                0 -> 0  
                1 -> 1  
                else -> 0  
            }  
        }  
  
        for(i in 2 ..  number) {  
            table[i] = table[i - 2] + table[i -1]  
        }  
  
  
        return table[number]  
    }  
}

/***  
 *  ì—¬ê¸°ì„œ í…Œì´ë¸” ì‚¬ì´ì¦ˆë¥¼ number + 1ìœ¼ë¡œ ì¡ì•˜ë‹¤.  
 *  ì™œ nê¹Œì§€ ì“°ëŠ”ë° n + 1ì§œë¦¬ë¥¼ ë§Œë“œëŠ”ê°€?  
 * 
 *  #### DPëŠ” í…Œì´ë¸” ê¸°ë°˜ì˜ "ìƒíƒœ ì „ì´ ì‹œìŠ¤í…œ"  
 *  - dpëŠ” ì•„ë˜ì™€ ê°™ì€ êµ¬ì„± ìš”ì†Œë¡œ ì´ë¤„ì§„ë‹¤.  
 *  1. ìƒíƒœ ì •ì˜(dp(n))  
 *  2. ì í™”ì‹(dp(n) = dp(n-1)+dp(n-2)  
 *  3. ì´ˆê¸° ê°’  
 *  - ì—¬ê¸°ì„œ n ê³„ì‚°ì„ ìœ„í•´ì„œëŠ” n-1, n-2ê°€ í•„ìš” ==> ë¯¸ë¦¬ í…Œì´ë¸”ì— ì¡´ì¬í•´ì•¼ í•œë‹¤.  
 *  - ì´ëŸ° ìƒí™©ì—ì„œ nê°œë¡œ í•˜ë©´ 0~n-1ê°œë¡œ nê°œ ì €ì¥ ë¶ˆê°€  
 */
```

### ë©”ëª¨ë¦¬ ìµœì í™”?(ìƒíƒœ ì••ì¶•)
- Bottom-upì—ì„œ ëª¨ë“  ìƒíƒœë¥¼ ë°°ì—´ì— ì €ì¥í•˜ì§€ ì•Šê³ , í˜„ì¬ ê³„ì‚°ì— í•„ìš”í•œ ìµœì†Œ ìƒíƒœë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ë¥¼ ë²„ë¦¬ëŠ” í˜•ì‹
- dp[n] = dp[n-1] + dp[n-2]ì™€ ê°™ì´ ë”± ëª‡ ê°œì˜ ì´ì „ ê°’ë§Œ ì°¸ì¡°í•  ê²½ìš°
- ì¦‰, í˜„ì¬ ê°’ ê³„ì‚°ì— ì´ì „ ì „ì²´ ê°’ì´ í•„ìš”í•˜ì§€ëŠ” ì•ŠëŠ” ê²½ìš°
- ì´ ê²½ìš° ê¸°í• ë‹¹ëœ ê³µê°„ì„ ì¬í• ë‹¹í•˜ëŠ” ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•  ìˆ˜ ìˆë‹¤.

- ì˜ˆì‹œ 2) ê³„ë‹¨ ì˜¤ë¥´ê¸°
```kotlin
class Step {  
    /**  
     *     
     * â¸»  
     * ğŸ§ª ë¬¸ì œ 1. ê³„ë‹¨ ì˜¤ë¥´ê¸°  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * í•œ ë²ˆì— 1ì¹¸ ë˜ëŠ” 2ì¹¸ì„ ì˜¤ë¥¼ ìˆ˜ ìˆë‹¤.  
     * ì´ nì¹¸ì˜ ê³„ë‹¨ì´ ìˆì„ ë•Œ, ì •í™•íˆ në²ˆì§¸ ì¹¸ì— ë„ë‹¬í•˜ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (1 â‰¤ n â‰¤ 10â¶)     
     * ì¶œë ¥  
     *  â€¢  ë°©ë²•ì˜ ìˆ˜ (mod 1,000,000,007)     
     *     
     * n = 1 (1) 1     
     * n = 2 (1+1) (2) 2     
     * n = 3 (1+1+1) (1+2) (2+1) 3     
     * n = 4 (1+1+1+1) (1+1+2) (1+2+1) (2+1+1) (2+2) 5     
     * n = 5 (1+1+1+1+1) (1+1+1+2) (1+1+2+1) (1+2+1+1) (2+1+1+1) (1+2+2) (2+1+2) (2+2+1)     
     * --> fibonacci     
     */
      
    @Test  
    fun solution(){  
  
        val expected = 8  
        val result = useFibonacci(5) % 1_000_000_007  
  
        assertEquals(expected, result)  
    }  
  
    private fun useFibonacci(number: Int): Int {  
        val table = Array(number + 1){  
            i -> when(i) {  
                0 -> 1  
                1 -> 2  
                else -> 0  
            }  
        }  
  
        for(i in 2 .. number) {  
            table[i] = table[i - 1] + table[i - 2]  
        }  
  
        return table[number - 1]  
    }  
}
```
- ì˜ˆì‹œ 3) ë“±êµ£ê¸¸
```kotlin
  
class OnTheWayToSchool {  
    /**  
     * ğŸ§ª ë¬¸ì œ 2. ë“±êµ£ê¸¸  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * m Ã— n ê²©ìíŒì´ ìˆë‹¤.  
     * ì™¼ìª½ ìœ„ì—ì„œ ì‹œì‘í•´ ì˜¤ë¥¸ìª½ ì•„ë˜ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * ì˜¤ë¥¸ìª½, ì•„ë˜ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆê³ , ë¬¼ì›…ë©ì´ëŠ” í”¼í•´ì•¼ í•œë‹¤.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ m, n (1 â‰¤ m, n â‰¤ 100)   
	 *  â€¢  ë¬¼ì›…ë©ì´ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ [[x1, y1], [x2, y2], ...]  
	 * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ê°€ëŠ¥í•œ ëª¨ë“  ì´ë™ ê²½ë¡œì˜ ìˆ˜  
     * â¸»  
     */  
  
    @Test  
    fun solution(){  
  
        val expected = 70  
        val result = useBottomUp(5,5, Array(0){IntArray(0)})  
  
        assertEquals(expected, result)  
    }  
  
    private fun useBottomUp(m: Int, n:Int, spot: Array<IntArray>): Int {  
        val table = Array(m + 1) { IntArray(n + 1) }  
        table[1][1] = 1  
  
        for(i in 0 until  spot.size) {  
            val (x,y) = spot[i]  
            table[x][y] = -1  
        }  
  
        for(i in 1 .. m) {  
            for(j in 1 .. n) {  
                if ( table[i][j] == -1) {  
                    table[i][j] = 0  
                    continue  
                }  
  
                if(table[i - 1][j] != -1) table[i][j] += table[i - 1][j]  
                if(table[i][j - 1] != -1) table[i][j] += table[i][j - 1]  
            }  
        }  
  
  
        return table[m][n]  
    }  
}
```
- ì˜ˆì‹œ 4)  0/1 ë°°ë‚­ ë¬¸ì œ (ê¸°ì´ˆ)

```kotlin
class BackPack {  
    /**  
     * ğŸ§ª ë¬¸ì œ 3. 0/1 ë°°ë‚­ ë¬¸ì œ (ê¸°ì´ˆ)  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * ë¬´ê²Œ ì œí•œì´ Wì¸ ë°°ë‚­ì´ ìˆê³ ,  
     * ê° ì•„ì´í…œì€ (ë¬´ê²Œ, ê°€ì¹˜) ìŒìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.  
     * ê°€ì¹˜ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ ì•„ì´í…œì„ ê³ ë¥¼ ë•Œ,  
     * ìµœëŒ€ ê°€ì¹˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * (ê° ì•„ì´í…œì€ í•œ ë²ˆë§Œ ì‚¬ìš© ê°€ëŠ¥)  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ N (ì•„ì´í…œ ìˆ˜), ì •ìˆ˜ W (ë°°ë‚­ ìµœëŒ€ ë¬´ê²Œ)  
     *  â€¢  ë‹¤ìŒ Nì¤„ì— ê±¸ì³ ê° ì¤„ë§ˆë‹¤ weight, value ì •ë³´  
     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ë°°ë‚­ì— ë‹´ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜  
     */  
  
    @Test  
    fun solution() {  
        val weight = 7  
        val itemCount = 3  
        val item = arrayOf(  
            intArrayOf(1, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 5),  
        )  
        val expected = 9  
  
        assertEquals(expected, backPack(itemCount, weight, item))  
    }  
  
    /**  
     * dp[i][j] => i ë²ˆì§¸ ë¬¼ê±´ê¹Œì§€ ê³ ë ¤í•´ì„œ, ë°°ë‚­ ë¬´ê²Œ jì¼ ë•Œ ê°€ëŠ¥í•œ ìµœëŒ€ ê°€ì¹˜  
     * i: ë¬¼ê±´ ê°œìˆ˜  
     * j: ë°°ë‚­ ë‚¨ëŠ” ë¬´ê²Œ  
     * dp[i][j]: ê·¸ ìƒíƒœì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜  
     *  
     *     * -> êµ¬í•˜ê³ ì í•˜ëŠ” ê²ƒ : ìµœëŒ€ í•©  
     * -> dp[i][j] ìì²´ì— ëŒ€í•´ì„œ ìƒê°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.  
     *      -> êµ¬í•˜ê³ ì í•˜ëŠ” ê²ƒì—ì„œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¤„ì´ì§€ ëª»í•´ì„œ ì—¬ëŸ¬ ê²½ìš°ì˜ ìˆ˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ í‘œí˜„í•˜ê¸° ìœ„í•´ì„œ ê·¸ë˜í”„ë¥¼ ìƒê°í–ˆìŒ  
     *      -> ê³µê°„ ë‹¹ ìƒíƒœê°€ ì•„ë‹ˆë¼ íŒŒìƒë˜ëŠ” íë¦„ê³¼ ê²½ìš°ì˜ ìˆ˜ë¡œ ìƒê°  
     *  
     * -> DPëŠ” íƒìƒ‰ì´ ì•„ë‹Œ ê¸°ë¡ì´ë‹¤.  
     */  
    fun backPack(itemCount: Int, capacity: Int, items: Array<IntArray>): Int {  
        val table = Array(itemCount + 1) { IntArray(capacity + 1) }  
        for (numberOfItem in 1..itemCount) {  
            val weight = items[numberOfItem - 1][0]  
            val value = items[numberOfItem - 1][1]  
  
            for (currentWeight in 0..capacity) {  
  
                table[numberOfItem][currentWeight] =  
                    if (currentWeight < weight) table[numberOfItem - 1][currentWeight]  
                    else maxOf(  
                        table[numberOfItem - 1][currentWeight],  
                        table[numberOfItem - 1][currentWeight - weight] + value  
                    )  
  
            }        }  
  
        return table[itemCount][capacity]  
    }  
}
```
- ì˜ˆì‹œ 4-1) ì˜ˆì‚° ì•ˆì—ì„œ ìµœëŒ€ ê°€ì¹˜ ì–»ê¸°
```kotlin
class InBudgetMaxValue {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 1. ì˜ˆì‚° ì•ˆì—ì„œ ìµœëŒ€ ê°€ì¹˜ ì–»ê¸°  
     *  
     * ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì€ ì˜ˆì‚° Bë§Œí¼ì„ ê°–ê³  ìˆìŠµë‹ˆë‹¤.  
     * ë¬¼ê±´ Nê°œê°€ ìˆê³ , ê° ë¬¼ê±´ì€ ê°€ê²©ê³¼ ë§Œì¡±ë„ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ì˜ˆì‚°ì„ ë„˜ì§€ ì•Šê²Œ ëª‡ ê°œì˜ ë¬¼ê±´ì„ ì„ íƒí–ˆì„ ë•Œ, ì´ ë§Œì¡±ë„ì˜ ìµœëŒ€ê°’ì€?  
     *     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ì˜ˆì‚°: B = 10  
     *  â€¢  ë¬¼ê±´:  
     *  ```kotlin     
     *      val goods = arrayOf(     
     *          intArrayOf(2, 1),  // ê°€ê²© 2, ë§Œì¡±ë„ 1     
     *          intArrayOf(3, 4),  // ê°€ê²© 3, ë§Œì¡±ë„ 4     
     *          intArrayOf(5, 5)   // ê°€ê²© 5, ë§Œì¡±ë„ 5     
     *      )     
     *  ```    
     */  
     
    @Test  
    fun solution() {  
        val budget = 10  
        val goods = arrayOf(  
            intArrayOf(2, 1),  // ê°€ê²© 2, ë§Œì¡±ë„ 1            intArrayOf(3, 4),  // ê°€ê²© 3, ë§Œì¡±ë„ 4            intArrayOf(5, 5)   // ê°€ê²© 5, ë§Œì¡±ë„ 5        )  
        val expected = 10  
  
        assertEquals(expected, budgetAndMaxValue(budget, goods))  
    }  
  
    private fun budgetAndMaxValue(budget: Int, goods: Array<IntArray>): Int {  
        val table = Array(goods.size + 1) { IntArray(budget+1)}  
  
        for(i in 1 ..  goods.size) {  
            val price = goods[i - 1][0]  
            val satisfaction = goods[i - 1][1]  
  
            for(j in 0 .. budget) {  
                table[i][j] = if(j < price) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - price] + satisfaction)  
            }        }  
  
  
        return table[goods.size][budget]  
    }  
}
```

- ì˜ˆì‹œ 4-2) ì‹œê°„ ë‚´ ìµœëŒ€ ì—…ë¬´ íš¨ìœ¨
```kotlin
class MaxEfficiency {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 2. ì‹œê°„ ë‚´ ìµœëŒ€ ì—…ë¬´ íš¨ìœ¨  
     *  
     * ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì—ê² Tì‹œê°„ì´ ìˆìŠµë‹ˆë‹¤.  
     * ì¼ Nê°œê°€ ìˆê³ , ê° ì¼ì€ ê±¸ë¦¬ëŠ” ì‹œê°„ê³¼ íš¨ìœ¨ ì ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.  
     * ì •í•´ì§„ ì‹œê°„ ë‚´ì— ëª‡ ê°œì˜ ì¼ì„ ê³¨ë¼ì„œ íš¨ìœ¨ì˜ ì´í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ í•˜ì„¸ìš”.  
     * 
     * â¸»  
     *  
     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ì‹œê°„ ì œí•œ: T = 8  
     *  â€¢  ì¼ ëª©ë¡:  
     *  ```kotlin     
     *  val tasks = arrayOf(     
     *     intArrayOf(2, 3),  // ì‹œê°„ 2, ì ìˆ˜ 3    
     *     intArrayOf(4, 5),  // ì‹œê°„ 4, ì ìˆ˜ 5     
     *     intArrayOf(3, 6)   // ì‹œê°„ 3, ì ìˆ˜ 6    
     * )     
     *  ```     
     */  
     
    @Test  
    fun solution(){  
        val time = 8  
        val tasks = arrayOf(  
            intArrayOf(2, 3),  // ì‹œê°„ 2, ì ìˆ˜ 3            intArrayOf(4, 5),  // ì‹œê°„ 4, ì ìˆ˜ 5            intArrayOf(3, 6)   // ì‹œê°„ 3, ì ìˆ˜ 6        )  
        val expected = 11  
  
        assertEquals(expected, maxEfficiency(time, tasks))  
    }  
  
    private fun maxEfficiency(time: Int, tasks: Array<IntArray>): Int {  
        val table = Array(tasks.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. tasks.size){  
            val (spendTime, score) = tasks[i - 1]  
  
            for( j in 0 .. time) {  
                table[i][j] =  
                if(j < spendTime)  table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[tasks.size][time]  
    }  
}
```

- ì˜ˆì‹œ 4-3) ìµœëŒ€ ê³µë¶€ ì ìˆ˜
```kotlin
class MaxStudyTime {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 3. ìµœëŒ€ ê³µë¶€ ì ìˆ˜  
     *  
     * ì„¤ëª…  
     *  
     * í•™ìƒì€ kì‹œê°„ ë™ì•ˆ ê³µë¶€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ê° ê³¼ëª©ë§ˆë‹¤ ê³µë¶€ ì‹œê°„ê³¼ ì ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.  
     * ì–´ë–¤ ê³¼ëª©ì„ ê³µë¶€í• ì§€ ì„ íƒí•´ì„œ, ì´ ì ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ë„ë¡ í•˜ì„¸ìš”.  
     * â¸»  
     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ê³µë¶€ ì‹œê°„ í•œë„: k = 5  
     *  â€¢  ê³¼ëª© ëª©ë¡:  
     *  ```kotlin    
     *  val subjects = arrayOf(    
     *     intArrayOf(1, 2),  // ì‹œê°„ 1, ì ìˆ˜ 2    
     *     intArrayOf(2, 4),  // ì‹œê°„ 2, ì ìˆ˜ 4     
     *     intArrayOf(3, 5)   // ì‹œê°„ 3, ì ìˆ˜ 5     
     * )    
     *  ```    
     */
       
    @Test  
    fun solution() {  
        val maxTime = 5  
        val subjects = arrayOf(  
            intArrayOf(1, 2),  // ì‹œê°„ 1, ì ìˆ˜ 2            intArrayOf(2, 4),  // ì‹œê°„ 2, ì ìˆ˜ 4            intArrayOf(3, 5)   // ì‹œê°„ 3, ì ìˆ˜ 5        )  
  
        val expected = 9  
  
        assertEquals(expected, study(maxTime, subjects))  
    }  
  
    private fun study(time: Int, subject: Array<IntArray>): Int {  
        val table = Array(subject.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. subject.size) {  
            val (spendTime, score) = subject[i]  
            for (j in 0 .. time) {  
                table[i][j] = if(j < spendTime) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[subject.size][time]  
    }  
}
```
