### Top-down
- ì¬ê·€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆ„ë©´ì„œ ë‚´ë ¤ê°„ë‹¤.
- ì¤‘ë³µë˜ëŠ” ê³„ì‚° ê²°ê³¼ëŠ” ì €ì¥í•´ì„œ ë‹¤ì‹œ ê³„ì‚°í•˜ì§€ ì•ŠëŠ”ë‹¤.
> #### ë‚´ë¶€ êµ¬ì¡°
> - f(n) í˜¸ì¶œ -> (f(n-1), f(n-2)) í˜¸ì¶œ -> ê²°ê³¼ë¥¼ ì €ì¥í•˜ë©´ì„œ ëŒì•„ì˜¤ê³  ëˆ„ì 
 

### Bottom-up
- ì‘ì€ ë¬¸ì œì—ì„œ í° ë¬¸ì œê¹Œì§€ ë°˜ë³µì ìœ¼ë¡œ ì˜¬ë¼ê°€ë©°, í•„ìš”í•œ ê°’ì„ í…Œì´ë¸”ì— ì§ì ‘ ì±„ìš°ëŠ” ë°©ì‹
> #### ë‚´ë¶€ êµ¬ì¡°
> - dp[0], dp[1] ì´ˆê¸° ê°’ ì„¤ì •
> - for i in 2 .. n ë°˜ë³µí•´ê°€ë©° dp[i] ê³„ì‚°

|   í•­ëª©    |        Top-down        |     Bottom-up     |
| :-----: | :--------------------: | :---------------: |
|   êµ¬ì¡°    |    ì¬ê·€ + memoization    |     ë°˜ë³µë¬¸ + ë°°ì—´      |
|  ìºì‹± ìœ„ì¹˜  |         í•¨ìˆ˜ ë‚´ë¶€          |      ì™¸ë¶€ í…Œì´ë¸”       |
|  ê³„ì‚° ìˆœì„œ  |     í° ë¬¸ì œ -> ì‘ì€ ë¬¸ì œ      |   ì‘ì€ ë¬¸ì œ -> í° ë¬¸ì œ   |
|  ê³„ì‚° ë²”ìœ„  |        í•„ìš”í•œ ë§Œí¼ë§Œ         |     ëŒ€ë¶€ë¶„ ëª¨ë“  ìƒíƒœ     |
|   ì¥ì     |     ì§ê´€ì , ì¡°ê±´ ë¶„ê¸° ìœ ì—°      |    ë¹ ë¦„, ë©”ëª¨ë¦¬ ì•ˆì •     |
|   ë‹¨ì     |   ìŠ¤íƒ ê¹Šì´ ë¬¸ì œ, ë””ë²„ê¹… ì–´ë ¤ì›€    |    ë¶ˆí•„ìš”í•œ ê³„ì‚° í¬í•¨     |
| ì–¸ì œ ì„ íƒí•˜ë‚˜ | ë¬¸ì œ êµ¬ì¡°ê°€ ë³µì¡í•˜ê³  ì¡°ê±´ ë¶„ê¸°ê°€ ë§ë‹¤. | ì…ë ¥ í¬ê¸°ê°€ í¬ê³  ë°˜ë³µ êµ¬ì¡°ë‹¤. |

- ì˜ˆì‹œ 1) í”¼ë³´ë‚˜ì¹˜ bottom-upìœ¼ë¡œ ì¬êµ¬ì„±
```kotlin
class FibonacciBottomUp {  
  
    /**  
     * ğŸ“„ ë¬¸ì œ ìš”ì•½  
     *  
     * ì •ìˆ˜ nì´ ì£¼ì–´ì¡Œì„ ë•Œ, në²ˆì§¸ í”¼ë³´ë‚˜ì¹˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * (f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2))     
     */
     

	@Test  
    fun fibonacciBottomUp(){  
        assertEquals(5, bottomUp(5))  
    }  
  
    private fun bottomUp(number: Int): Int {  
        val table = Array(number + 1) { i ->  
            when(i) {  
                0 -> 0  
                1 -> 1  
                else -> 0  
            }  
        }  
  
        for(i in 2 ..  number) {  
            table[i] = table[i - 2] + table[i -1]  
        }  
  
  
        return table[number]  
    }  
}

/***  
 *  ì—¬ê¸°ì„œ í…Œì´ë¸” ì‚¬ì´ì¦ˆë¥¼ number + 1ìœ¼ë¡œ ì¡ì•˜ë‹¤.  
 *  ì™œ nê¹Œì§€ ì“°ëŠ”ë° n + 1ì§œë¦¬ë¥¼ ë§Œë“œëŠ”ê°€?  
 * 
 *  #### DPëŠ” í…Œì´ë¸” ê¸°ë°˜ì˜ "ìƒíƒœ ì „ì´ ì‹œìŠ¤í…œ"  
 *  - dpëŠ” ì•„ë˜ì™€ ê°™ì€ êµ¬ì„± ìš”ì†Œë¡œ ì´ë¤„ì§„ë‹¤.  
 *  1. ìƒíƒœ ì •ì˜(dp(n))  
 *  2. ì í™”ì‹(dp(n) = dp(n-1)+dp(n-2)  
 *  3. ì´ˆê¸° ê°’  
 *  - ì—¬ê¸°ì„œ n ê³„ì‚°ì„ ìœ„í•´ì„œëŠ” n-1, n-2ê°€ í•„ìš” ==> ë¯¸ë¦¬ í…Œì´ë¸”ì— ì¡´ì¬í•´ì•¼ í•œë‹¤.  
 *  - ì´ëŸ° ìƒí™©ì—ì„œ nê°œë¡œ í•˜ë©´ 0~n-1ê°œë¡œ nê°œ ì €ì¥ ë¶ˆê°€  
 */
```

### ë©”ëª¨ë¦¬ ìµœì í™”?(ìƒíƒœ ì••ì¶•)
- Bottom-upì—ì„œ ëª¨ë“  ìƒíƒœë¥¼ ë°°ì—´ì— ì €ì¥í•˜ì§€ ì•Šê³ , í˜„ì¬ ê³„ì‚°ì— í•„ìš”í•œ ìµœì†Œ ìƒíƒœë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ë¥¼ ë²„ë¦¬ëŠ” í˜•ì‹
- dp[n] = dp[n-1] + dp[n-2]ì™€ ê°™ì´ ë”± ëª‡ ê°œì˜ ì´ì „ ê°’ë§Œ ì°¸ì¡°í•  ê²½ìš°
- ì¦‰, í˜„ì¬ ê°’ ê³„ì‚°ì— ì´ì „ ì „ì²´ ê°’ì´ í•„ìš”í•˜ì§€ëŠ” ì•ŠëŠ” ê²½ìš°
- ì´ ê²½ìš° ê¸°í• ë‹¹ëœ ê³µê°„ì„ ì¬í• ë‹¹í•˜ëŠ” ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ë¥¼ ì ˆì•½í•  ìˆ˜ ìˆë‹¤.

- ì˜ˆì‹œ 2) ê³„ë‹¨ ì˜¤ë¥´ê¸°
```kotlin
class Step {  
    /**  
     *     
     * â¸»  
     * ğŸ§ª ë¬¸ì œ 1. ê³„ë‹¨ ì˜¤ë¥´ê¸°  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * í•œ ë²ˆì— 1ì¹¸ ë˜ëŠ” 2ì¹¸ì„ ì˜¤ë¥¼ ìˆ˜ ìˆë‹¤.  
     * ì´ nì¹¸ì˜ ê³„ë‹¨ì´ ìˆì„ ë•Œ, ì •í™•íˆ në²ˆì§¸ ì¹¸ì— ë„ë‹¬í•˜ëŠ” ë°©ë²•ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * ì…ë ¥  
     *  â€¢  ì •ìˆ˜ n (1 â‰¤ n â‰¤ 10â¶)     
     * ì¶œë ¥  
     *  â€¢  ë°©ë²•ì˜ ìˆ˜ (mod 1,000,000,007)     
     *     
     * n = 1 (1) 1     
     * n = 2 (1+1) (2) 2     
     * n = 3 (1+1+1) (1+2) (2+1) 3     
     * n = 4 (1+1+1+1) (1+1+2) (1+2+1) (2+1+1) (2+2) 5     
     * n = 5 (1+1+1+1+1) (1+1+1+2) (1+1+2+1) (1+2+1+1) (2+1+1+1) (1+2+2) (2+1+2) (2+2+1)     
     * --> fibonacci     
     */
      
    @Test  
    fun solution(){  
  
        val expected = 8  
        val result = useFibonacci(5) % 1_000_000_007  
  
        assertEquals(expected, result)  
    }  
  
    private fun useFibonacci(number: Int): Int {  
        val table = Array(number + 1){  
            i -> when(i) {  
                0 -> 1  
                1 -> 2  
                else -> 0  
            }  
        }  
  
        for(i in 2 .. number) {  
            table[i] = table[i - 1] + table[i - 2]  
        }  
  
        return table[number - 1]  
    }  
}
```
- ì˜ˆì‹œ 3) ë“±êµ£ê¸¸
```kotlin
  
class OnTheWayToSchool {  
    /**  
     * ğŸ§ª ë¬¸ì œ 2. ë“±êµ£ê¸¸  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * m Ã— n ê²©ìíŒì´ ìˆë‹¤.  
     * ì™¼ìª½ ìœ„ì—ì„œ ì‹œì‘í•´ ì˜¤ë¥¸ìª½ ì•„ë˜ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * ì˜¤ë¥¸ìª½, ì•„ë˜ë¡œë§Œ ì´ë™í•  ìˆ˜ ìˆê³ , ë¬¼ì›…ë©ì´ëŠ” í”¼í•´ì•¼ í•œë‹¤.  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ m, n (1 â‰¤ m, n â‰¤ 100)   
	 *  â€¢  ë¬¼ì›…ë©ì´ ì¢Œí‘œ ë¦¬ìŠ¤íŠ¸ [[x1, y1], [x2, y2], ...]  
	 * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ê°€ëŠ¥í•œ ëª¨ë“  ì´ë™ ê²½ë¡œì˜ ìˆ˜  
     * â¸»  
     */  
  
    @Test  
    fun solution(){  
  
        val expected = 70  
        val result = useBottomUp(5,5, Array(0){IntArray(0)})  
  
        assertEquals(expected, result)  
    }  
  
    private fun useBottomUp(m: Int, n:Int, spot: Array<IntArray>): Int {  
        val table = Array(m + 1) { IntArray(n + 1) }  
        table[1][1] = 1  
  
        for(i in 0 until  spot.size) {  
            val (x,y) = spot[i]  
            table[x][y] = -1  
        }  
  
        for(i in 1 .. m) {  
            for(j in 1 .. n) {  
                if ( table[i][j] == -1) {  
                    table[i][j] = 0  
                    continue  
                }  
  
                if(table[i - 1][j] != -1) table[i][j] += table[i - 1][j]  
                if(table[i][j - 1] != -1) table[i][j] += table[i][j - 1]  
            }  
        }  
  
  
        return table[m][n]  
    }  
}
```
- ì˜ˆì‹œ 4)  0/1 ë°°ë‚­ ë¬¸ì œ (ê¸°ì´ˆ)

```kotlin
class BackPack {  
    /**  
     * ğŸ§ª ë¬¸ì œ 3. 0/1 ë°°ë‚­ ë¬¸ì œ (ê¸°ì´ˆ)  
     * â¸»  
     * ğŸ“„ ë¬¸ì œ ì„¤ëª…  
     * ë¬´ê²Œ ì œí•œì´ Wì¸ ë°°ë‚­ì´ ìˆê³ ,  
     * ê° ì•„ì´í…œì€ (ë¬´ê²Œ, ê°€ì¹˜) ìŒìœ¼ë¡œ ì£¼ì–´ì§„ë‹¤.  
     * ê°€ì¹˜ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ ì•„ì´í…œì„ ê³ ë¥¼ ë•Œ,  
     * ìµœëŒ€ ê°€ì¹˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * (ê° ì•„ì´í…œì€ í•œ ë²ˆë§Œ ì‚¬ìš© ê°€ëŠ¥)  
     * â¸»  
     * ğŸ“¥ ì…ë ¥  
     *  â€¢  ì •ìˆ˜ N (ì•„ì´í…œ ìˆ˜), ì •ìˆ˜ W (ë°°ë‚­ ìµœëŒ€ ë¬´ê²Œ)  
     *  â€¢  ë‹¤ìŒ Nì¤„ì— ê±¸ì³ ê° ì¤„ë§ˆë‹¤ weight, value ì •ë³´  
     * â¸»  
     * ğŸ“¤ ì¶œë ¥  
     *  â€¢  ë°°ë‚­ì— ë‹´ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜  
     */  
  
    @Test  
    fun solution() {  
        val weight = 7  
        val itemCount = 3  
        val item = arrayOf(  
            intArrayOf(1, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 5),  
        )  
        val expected = 9  
  
        assertEquals(expected, backPack(itemCount, weight, item))  
    }  
  
    /**  
     * dp[i][j] => i ë²ˆì§¸ ë¬¼ê±´ê¹Œì§€ ê³ ë ¤í•´ì„œ, ë°°ë‚­ ë¬´ê²Œ jì¼ ë•Œ ê°€ëŠ¥í•œ ìµœëŒ€ ê°€ì¹˜  
     * i: ë¬¼ê±´ ê°œìˆ˜  
     * j: ë°°ë‚­ ë‚¨ëŠ” ë¬´ê²Œ => jë§Œí¼ ìì›ì„ ì‚¬ìš©í–ˆì„ ë•Œ
     * dp[i][j]: ê·¸ ìƒíƒœì—ì„œ ë§Œë“¤ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜  
     *  
     *  
     * -> êµ¬í•˜ê³ ì í•˜ëŠ” ê²ƒ : ìµœëŒ€ í•©  
     * -> dp[i][j] ìì²´ì— ëŒ€í•´ì„œ ìƒê°í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.  
     *      -> êµ¬í•˜ê³ ì í•˜ëŠ” ê²ƒì—ì„œ ê²½ìš°ì˜ ìˆ˜ë¥¼ ì¤„ì´ì§€ ëª»í•´ì„œ ì—¬ëŸ¬ ê²½ìš°ì˜ ìˆ˜ê°€ ë°œìƒí•˜ëŠ” ê²ƒì„ í‘œí˜„í•˜ê¸° ìœ„í•´ì„œ ê·¸ë˜í”„ë¥¼ ìƒê°í–ˆìŒ  
     *      -> ê³µê°„ ë‹¹ ìƒíƒœê°€ ì•„ë‹ˆë¼ íŒŒìƒë˜ëŠ” íë¦„ê³¼ ê²½ìš°ì˜ ìˆ˜ë¡œ ìƒê°  
     *  
     * -> DPëŠ” íƒìƒ‰ì´ ì•„ë‹Œ ê¸°ë¡ì´ë‹¤.  
     */  
    fun backPack(itemCount: Int, capacity: Int, items: Array<IntArray>): Int {  
        val table = Array(itemCount + 1) { IntArray(capacity + 1) }  
        for (numberOfItem in 1..itemCount) {  
            val weight = items[numberOfItem - 1][0]  
            val value = items[numberOfItem - 1][1]  
  
            for (currentWeight in 0..capacity) {  
  
                table[numberOfItem][currentWeight] =  
                    if (currentWeight < weight) table[numberOfItem - 1][currentWeight]  
                    else maxOf(  
                    //ì•ˆ ë‹´ëŠëƒ
                        table[numberOfItem - 1][currentWeight],  
					//ë‹´ëŠëƒ
                        table[numberOfItem - 1][currentWeight - weight] + value  
                        
                    // looping í•˜ë©´ì„œ í˜„ì¬ ë¬´ê²Œë§Œì„ ê³ ë ¤í•œë‹¤.
                    // ê·¸ëŸ¼ ì´ì „ì˜ ë¬´ê²Œê¹Œì§€ ëˆ„ì ëœ ëˆ„ì  ë¬´ê²ŒëŠ”??
                    // currentWeight - weightë¡œ ì´ì „ì˜ ë¬´ê²Œë¥¼ êµ¬í•˜ê³  +value í•˜ëŠ” ë¶€ë¶„ìœ¼ë¡œ
                    // ì´ë¯¸ ëˆ„ì  ë¬´ê²Œë¥¼ ê³ ë ¤í•œ ê²ƒê³¼ ê°™ì€ íš¨ê³¼ë¥¼ ë‚¸ë‹¤.
                    )  
  
            }        }  
  
        return table[itemCount][capacity]  
    }  
}
```
- ì˜ˆì‹œ 4-1) ì˜ˆì‚° ì•ˆì—ì„œ ìµœëŒ€ ê°€ì¹˜ ì–»ê¸°ë‹¤
```kotlin
class InBudgetMaxValue {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 1. ì˜ˆì‚° ì•ˆì—ì„œ ìµœëŒ€ ê°€ì¹˜ ì–»ê¸°  
     *  
     * ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì€ ì˜ˆì‚° Bë§Œí¼ì„ ê°–ê³  ìˆìŠµë‹ˆë‹¤.  
     * ë¬¼ê±´ Nê°œê°€ ìˆê³ , ê° ë¬¼ê±´ì€ ê°€ê²©ê³¼ ë§Œì¡±ë„ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * ì˜ˆì‚°ì„ ë„˜ì§€ ì•Šê²Œ ëª‡ ê°œì˜ ë¬¼ê±´ì„ ì„ íƒí–ˆì„ ë•Œ, ì´ ë§Œì¡±ë„ì˜ ìµœëŒ€ê°’ì€?  
     *     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ì˜ˆì‚°: B = 10  
     *  â€¢  ë¬¼ê±´:  
     *  ```kotlin     
     *      val goods = arrayOf(     
     *          intArrayOf(2, 1),  // ê°€ê²© 2, ë§Œì¡±ë„ 1     
     *          intArrayOf(3, 4),  // ê°€ê²© 3, ë§Œì¡±ë„ 4     
     *          intArrayOf(5, 5)   // ê°€ê²© 5, ë§Œì¡±ë„ 5     
     *      )     
     *  ```    
     */  
     
    @Test  
    fun solution() {  
        val budget = 10  
        val goods = arrayOf(  
            intArrayOf(2, 1),  // ê°€ê²© 2, ë§Œì¡±ë„ 1
			intArrayOf(3, 4),  // ê°€ê²© 3, ë§Œì¡±ë„ 4
			intArrayOf(5, 5)   // ê°€ê²© 5, ë§Œì¡±ë„ 5        )  
        val expected = 10  
  
        assertEquals(expected, budgetAndMaxValue(budget, goods))  
    }  
  
    private fun budgetAndMaxValue(budget: Int, goods: Array<IntArray>): Int {  
        val table = Array(goods.size + 1) { IntArray(budget+1)}  
  
        for(i in 1 ..  goods.size) {  
            val price = goods[i - 1][0]  
            val satisfaction = goods[i - 1][1]  

            for(j in 0 .. budget) {  
                table[i][j] = if(j < price) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - price] + satisfaction)  
            }        }  
  
  
        return table[goods.size][budget]  
    }  
}
```

- ì˜ˆì‹œ 4-2) ì‹œê°„ ë‚´ ìµœëŒ€ ì—…ë¬´ íš¨ìœ¨
```kotlin
class MaxEfficiency {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 2. ì‹œê°„ ë‚´ ìµœëŒ€ ì—…ë¬´ íš¨ìœ¨  
     *  
     * ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì—ê² Tì‹œê°„ì´ ìˆìŠµë‹ˆë‹¤.  
     * ì¼ Nê°œê°€ ìˆê³ , ê° ì¼ì€ ê±¸ë¦¬ëŠ” ì‹œê°„ê³¼ íš¨ìœ¨ ì ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.  
     * ì •í•´ì§„ ì‹œê°„ ë‚´ì— ëª‡ ê°œì˜ ì¼ì„ ê³¨ë¼ì„œ íš¨ìœ¨ì˜ ì´í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ í•˜ì„¸ìš”.  
     * 
     * â¸»  
     *  
     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ì‹œê°„ ì œí•œ: T = 8  
     *  â€¢  ì¼ ëª©ë¡:  
     *  ```kotlin     
     *  val tasks = arrayOf(     
     *     intArrayOf(2, 3),  // ì‹œê°„ 2, ì ìˆ˜ 3    
     *     intArrayOf(4, 5),  // ì‹œê°„ 4, ì ìˆ˜ 5     
     *     intArrayOf(3, 6)   // ì‹œê°„ 3, ì ìˆ˜ 6    
     * )     
     *  ```     
     */  
     
    @Test  
    fun solution(){  
        val time = 8  
        val tasks = arrayOf(  
            intArrayOf(2, 3),  // ì‹œê°„ 2, ì ìˆ˜ 3            intArrayOf(4, 5),  // ì‹œê°„ 4, ì ìˆ˜ 5            intArrayOf(3, 6)   // ì‹œê°„ 3, ì ìˆ˜ 6        )  
        val expected = 11  
  
        assertEquals(expected, maxEfficiency(time, tasks))  
    }  
  
    private fun maxEfficiency(time: Int, tasks: Array<IntArray>): Int {  
        val table = Array(tasks.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. tasks.size){  
            val (spendTime, score) = tasks[i - 1]  
  
            for( j in 0 .. time) {  
                table[i][j] =  
                if(j < spendTime)  table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[tasks.size][time]  
    }  
}
```

- ì˜ˆì‹œ 4-3) ìµœëŒ€ ê³µë¶€ ì ìˆ˜
```kotlin
class MaxStudyTime {  
    /**  
     * ğŸ”¹ ë¬¸ì œ 3. ìµœëŒ€ ê³µë¶€ ì ìˆ˜  
     *  
     * ì„¤ëª…  
     *  
     * í•™ìƒì€ kì‹œê°„ ë™ì•ˆ ê³µë¶€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ê° ê³¼ëª©ë§ˆë‹¤ ê³µë¶€ ì‹œê°„ê³¼ ì ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.  
     * ì–´ë–¤ ê³¼ëª©ì„ ê³µë¶€í• ì§€ ì„ íƒí•´ì„œ, ì´ ì ìˆ˜ê°€ ìµœëŒ€ê°€ ë˜ë„ë¡ í•˜ì„¸ìš”.  
     * â¸»  
     * ì…ë ¥ ì˜ˆì‹œ  
     *  â€¢  ê³µë¶€ ì‹œê°„ í•œë„: k = 5  
     *  â€¢  ê³¼ëª© ëª©ë¡:  
     *  ```kotlin    
     *  val subjects = arrayOf(    
     *     intArrayOf(1, 2),  // ì‹œê°„ 1, ì ìˆ˜ 2    
     *     intArrayOf(2, 4),  // ì‹œê°„ 2, ì ìˆ˜ 4     
     *     intArrayOf(3, 5)   // ì‹œê°„ 3, ì ìˆ˜ 5     
     * )    
     *  ```    
     */
       
    @Test  
    fun solution() {  
        val maxTime = 5  
        val subjects = arrayOf(  
            intArrayOf(1, 2),  // ì‹œê°„ 1, ì ìˆ˜ 2            intArrayOf(2, 4),  // ì‹œê°„ 2, ì ìˆ˜ 4            intArrayOf(3, 5)   // ì‹œê°„ 3, ì ìˆ˜ 5        )  
  
        val expected = 9  
  
        assertEquals(expected, study(maxTime, subjects))  
    }  
  
    private fun study(time: Int, subject: Array<IntArray>): Int {  
        val table = Array(subject.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. subject.size) {  
            val (spendTime, score) = subject[i]  
            for (j in 0 .. time) {  
                table[i][j] = if(j < spendTime) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[subject.size][time]  
    }  
}
```

### 2ì°¨ì› ë°°ì—´ì„ 1ì°¨ì›ìœ¼ë¡œ ì••ì¶•í•˜ê¸°
- í˜„ì¬ê¹Œì§€ íŒ¨í„´ì€ `dp[i][j]`, `dp[i - 1][j]` ë§Œ ì‚¬ìš©í–ˆë‹¤.
- ì´ëŸ¬í•œ íŒ¨í„´ì—ì„œ ë¯¸ë£¨ì–´ ë³´ì•„ `dp[j]` ë¡œ ì••ì¶•í•  ìˆ˜ ìˆì„ ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.
```kotlin
val dp = IntArray(W + 1)

for (i in 0 until N) {
Â  Â  val (weight, value) = items[i]
Â  Â  for (j in W downTo weight) {
Â  Â  Â  Â  dp[j] = maxOf(
Â  Â  Â  Â  Â  Â  dp[j],
Â  Â  Â  Â  Â  Â  dp[j - weight] + value
Â  Â  Â  Â  )
Â  Â  }
}
//ì´ëŸ° êµ¬ì¡°ë¡œ
```
- `í˜„ì¬ ìƒíƒœ = ê³¼ê±°ì˜ ìƒíƒœ + í˜„ì¬ì˜ ì„ íƒ `
- `W downTo weight`ë¥¼ ì‚¬ìš©í•œ ì´ìœ 
	- Wë¶€í„° weightê¹Œì§€ë¼ ìì—°ìŠ¤ëŸ½ê²Œ ë°˜ì˜í•  ìˆ˜ ì—†ëŠ” ìƒíƒœëŠ” ë¬´ì‹œí•˜ê³  ë„˜ì–´ê°„ë‹¤.
	- ì •ë°©í–¥ìœ¼ë¡œ ì§„í–‰í•˜ë©´ ê¸°ì¡´ì˜ ê°’ì„ ì¤‘ë³µ ë°˜ì˜í•˜ëŠ” ê²½ìš°ê°€ ìƒê¸´ë‹¤. ì´ëŸ¬í•œ ì´ìœ ë¡œ ì‹œê°„ ìˆœì„œì™€ ì°¸ì¡° ìˆœì„œë¥¼ ì˜ë„ì ìœ¼ë¡œ ë°˜ëŒ€ë¡œ í•œë‹¤.
```kotlin
val dp = IntArray(6) { 0 }
val weight = 2
val value = 3

for (j in 2..5) {
Â  Â  dp[j] = maxOf(dp[j], dp[j - weight] + value)
}
// dp[2] = dp[0] + 3
// dp[3] = dp[1] + 3
// dp[4] = dp[2] + 3 --> ì¤‘ë³µ ê³„ì‚°!!
```
- ì˜ˆì‹œ ë¬¸ì œ 5) ê°€ë°©ì— ë„£ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜
```kotlin
class BackpackOneDimensional {  
    /**  
     * âœ… ë¬¸ì œ ì´ë¦„: ê°€ë°©ì— ë„£ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜  
     * â¸»  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì€ Nê°œì˜ ë¬¼ê±´ì„ ê°€ì§€ê³  ìˆê³ ,  
     * ê° ë¬¼ê±´ì€ ë¬´ê²Œ(weight)ì™€ ê°€ì¹˜(value)ë¥¼ ê°€ì§‘ë‹ˆë‹¤.  
     * ë‹¹ì‹ ì€ ìµœëŒ€ W ë¬´ê²Œê¹Œì§€ ë‹´ì„ ìˆ˜ ìˆëŠ” ë°°ë‚­ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
     *     * ê° ë¬¼ê±´ì€ í•œ ë²ˆë§Œ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     *     * ìµœëŒ€ ë¬´ê²Œë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šìœ¼ë©´ì„œ ë‹´ì„ ìˆ˜ ìˆëŠ” ë¬¼ê±´ë“¤ì˜ ì¡°í•© ì¤‘,  
     * ì´ ê°€ì¹˜ì˜ í•©ì´ ê°€ì¥ í° ê²½ìš°ë¥¼ êµ¬í•˜ì„¸ìš”.  
     * â¸»  
     * ğŸ§¾ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„ì— ë¬¼ê±´ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 100), ë°°ë‚­ì˜ ìµœëŒ€ ë¬´ê²Œ W (1 â‰¤ W â‰¤ 10000)     
     *  â€¢  ì´í›„ Nê°œì˜ ì¤„ì— ê° ë¬¼ê±´ì˜ weight, value (1 â‰¤ weight, value â‰¤ 1000)
     * â¸»  
     * âœ… ì¶œë ¥  
     *  â€¢  ë°°ë‚­ì— ë‹´ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°€ì¹˜ì˜ í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     * â¸»  
     *  
     */  
    
    @Test  
    fun solution() {  
        val weight = 7  
        val items = arrayOf(  
            intArrayOf(3, 4),  
            intArrayOf(4, 5),  
        )  
        val expected = 9  
  
        assertEquals(expected, oneDimensional(weight, items))  
    }  
  
    private fun oneDimensional(weight: Int, items: Array<IntArray>): Int {  
        val table = IntArray(weight + 1)  
  
        for( i in 1 .. items.size){  
            val (itemWeight, itemValue) = items[i - 1]  
            for( j in weight downTo itemWeight) {  
                table[j] = maxOf(  
                    table[j],  
                    table[j - itemWeight] + itemValue  
                )  
            }  
        }  
  
        return table.maxOrNull() ?: 0
    }  
}
```
### ì¤‘ë³µì„ í¬í•¨í•œ ê²½ìš° (Unbounded)
- í˜„ì¬ê¹Œì§€ êµ¬ì¡°ì ìœ¼ë¡œ i - 1ì—ì„œë§Œ íƒìƒ‰í•˜ì—¬ ì´ì „ ìƒíƒœ + í˜„ì¬ ìƒíƒœë¡œ ì¤‘ë³µì„ í¬í•¨í•˜ì§€ ì•Šì•˜ë‹¤.
- ë§Œì•½ ì¤‘ë³µì„ í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°ë¼ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ? ì´ëŠ” ê³¼ê±° ì„ íƒí•œ ì•„ì´í…œ, í˜„ì¬ ì´ë¯¸ ì„ íƒí•œ ì•„ì´í…œ ëª¨ë‘ë¥¼ ì„ íƒí•  ìˆ˜ ìˆë‹¤.
- ì˜ˆì‹œ 6) ë°°ë‚­ ë¬¸ì œ - ì¤‘ë³µ í—ˆìš©
```kotlin
class UnboundedBackpack {  
    /**  
     * ğŸ§ª ì˜ˆì‹œ ë¬¸ì œ (Unbounded) 
     *   
     * ë‹¹ì‹ ì€ ë¬´ê²Œ ì œí•œ Wê°€ ìˆëŠ” ë°°ë‚­ì„ ê°€ì§€ê³  ìˆê³ ,  
     * Nê°œì˜ ë¬¼ê±´ì„ ê°€ì§€ê³  ìˆë‹¤.  
     * ê° ë¬¼ê±´ì€ ë¬´ê²Œì™€ ê°€ì¹˜ê°€ ìˆê³ , ë¬´ì œí•œìœ¼ë¡œ ë‹´ì„ ìˆ˜ ìˆë‹¤.  
     * ìµœëŒ€ ê°€ì¹˜ë¥¼ êµ¬í•˜ì‹œì˜¤.  
     * ```kotlin    
     * val items = arrayOf(  
     *     intArrayOf(2, 3),
     *     intArrayOf(3, 4),  
     *     intArrayOf(4, 5)  
     * )    
     * val W = 7    
     * ```  
     */  
   
@Test  
    fun solution(){  
        val items = arrayOf(  
            intArrayOf(2, 3),  
            intArrayOf(3, 4),  
            intArrayOf(4, 5)  
        )  
        val W = 7  
        val expected = 10 // -> 2, 2, 3ìœ¼ë¡œ 10
  
        assertSoftly {  
            assertEquals(expected, unboundedTwoDimension(W, items))  
            assertEquals(expected, unboundedOneDimension(W, items))  
        }  
  
    }  
  
    private fun unboundedTwoDimension(W: Int, items: Array<IntArray>): Int {  
        val table = Array(items.size + 1) {IntArray(W + 1)}  
  
        for(i in 1 .. items.size) {  
            val (weight, value) = items[i - 1]  
  
            for (j in 0 .. W) {  
                table[i][j] = if(j < weight)  table[i - 1][j]  
                else {  
                    maxOf(table[i - 1][j], table[i][j - weight] + value)  
                    //ê¸°ì¡´ ëŒ€ë¹„ [i - 1][j - weight]ê°€ ë¹ ì¡Œë‹¤.
                    //í˜„ì¬ ì•„ì´í…œì—ì„œ ì¤‘ë³µì„ ì²´í¬í•œë‹¤.
                    //ì´ëŠ” ì´ì „ ì•„ì´í…œë„ ì´ë¯¸ ì¤‘ë³µëœ ì„ íƒì„ í–ˆìŒì„ ê°ì•ˆí•œ ì í™”ì‹ì´ë‹¤.
                }  
            }  
        }  
  
        return table[items.size][W]  
    }  
  
    private fun unboundedOneDimension(W: Int, items: Array<IntArray>): Int {  
        val table = IntArray(W + 1)  
  
        for(i in 1 .. items.size) {  
            val (weight, value) = items[i - 1]  
            for (j in weight..W) { 
             //ì¤‘ë³µì„ í—ˆìš©í•˜ë„ë¡ W..weightì—ì„œ weight..Wìœ¼ë¡œ ìˆœíšŒ
             //ë°©í–¥ì„ ë³€ê²½í•˜ì˜€ë‹¤.
                table[j] = maxOf(table[j], table[j - weight] + value)  
            }  
        }  
  
        return table.maxOrNull() ?: 0  
    }  
}
```
- ì˜ˆì‹œ 7) ë¬´ì œí•œ ë¬¼ì•½ ì œì¡°
```kotlin
class UnboundMagicalBackpack {  
    /**  
     * âœ… ë¬¸ì œ ì´ë¦„: ë¬´ì œí•œ ë¬¼ì•½ ì œì¡°  
     * â¸»  
     * ğŸ“˜ ë¬¸ì œ ì„¤ëª…  
     * ë‹¹ì‹ ì€ ë‹¤ì–‘í•œ ì¢…ë¥˜ì˜ ë§ˆë²• ì¬ë£Œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
     * ê° ì¬ë£ŒëŠ” ì¼ì •í•œ ë¬´ê²Œì™€ **íš¨ëŠ¥(ê°€ì¹˜)**ì„ ê°€ì§€ë©°,  
     * ê°™ì€ ì¬ë£ŒëŠ” ì—¬ëŸ¬ ë²ˆ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     *     
     * ë‹¹ì‹ ì€ ìµœëŒ€ W ë¬´ê²Œê¹Œì§€ ë‹´ì„ ìˆ˜ ìˆëŠ” ë§ˆë²• ê°€ë°©ì„ ê°€ì§€ê³  ìˆìœ¼ë©°,  
     * ë¬´ê²Œë¥¼ ì´ˆê³¼í•˜ì§€ ì•Šìœ¼ë©´ì„œ íš¨ëŠ¥ì˜ í•©ì´ ìµœëŒ€ê°€ ë˜ë„ë¡ ì¬ë£Œë¥¼ ì„ íƒí•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     * â¸»  
     * ğŸ§¾ ì…ë ¥  
     *  â€¢  ì²«ì§¸ ì¤„ì— ì¬ë£Œì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 100), ê°€ë°©ì˜ ìµœëŒ€ ë¬´ê²Œ W (1 â‰¤ W â‰¤ 10,000)     
     *  â€¢  ì´í›„ Nê°œì˜ ì¤„ì— ê° ì¬ë£Œì˜ ë¬´ê²Œì™€ íš¨ëŠ¥ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * (1 â‰¤ ë¬´ê²Œ, íš¨ëŠ¥ â‰¤ 1000)    
     * â¸»  
     * âœ… ì¶œë ¥  
     *  â€¢  ê°€ë°©ì— ë‹´ì„ ìˆ˜ ìˆëŠ” ìµœëŒ€ íš¨ëŠ¥ì˜ í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     * ğŸ’¡ ì˜ˆì œ ì…ë ¥  
     * 
     * 3(ê°œìˆ˜) 7(ìµœëŒ€ ê°€ë°© ë¬´ê²Œ)  
     *   
     * ë¬´ê²Œ íš¨ëŠ¥  
     *  2  10  
     *  3  15  
     *  5  30   
     * âœ… ì¶œë ¥ ì˜ˆì œ  
     * 40  
     */  
   
	@Test  
    fun solution() {  
        val N = 3  
        val W = 7  
        val items = arrayOf(  
            intArrayOf(2, 10),  
            intArrayOf(3, 15),  
            intArrayOf(5, 30)  
        )  
        val expected = 40  
  
  
        assertEquals(expected, unbounded(N, W, items))  
  
    }  
  
    private fun unbounded(N: Int, W: Int, items: Array<IntArray>): Int {  
        val table = IntArray(W + 1)  
  
        for (i in 1..N) {  
            val (weight, value) = items[i - 1]  
            for (j in weight..W) {  
                table[j] = maxOf(table[j], table[j - weight] + value)  
            }  
        }  
  
        return table.maxOrNull() ?: 0  
    }  
}
```