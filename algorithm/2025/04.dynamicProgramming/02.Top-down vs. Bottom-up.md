### Top-down
- 재귀를 기반으로 큰 문제를 작은 문제로 나누면서 내려간다.
- 중복되는 계산 결과는 저장해서 다시 계산하지 않는다.
> #### 내부 구조
> - f(n) 호출 -> (f(n-1), f(n-2)) 호출 -> 결과를 저장하면서 돌아오고 누적
 

### Bottom-up
- 작은 문제에서 큰 문제까지 반복적으로 올라가며, 필요한 값을 테이블에 직접 채우는 방식
> #### 내부 구조
> - dp[0], dp[1] 초기 값 설정
> - for i in 2 .. n 반복해가며 dp[i] 계산

|   항목    |        Top-down        |     Bottom-up     |
| :-----: | :--------------------: | :---------------: |
|   구조    |    재귀 + memoization    |     반복문 + 배열      |
|  캐싱 위치  |         함수 내부          |      외부 테이블       |
|  계산 순서  |     큰 문제 -> 작은 문제      |   작은 문제 -> 큰 문제   |
|  계산 범위  |        필요한 만큼만         |     대부분 모든 상태     |
|   장점    |     직관적, 조건 분기 유연      |    빠름, 메모리 안정     |
|   단점    |   스택 깊이 문제, 디버깅 어려움    |    불필요한 계산 포함     |
| 언제 선택하나 | 문제 구조가 복잡하고 조건 분기가 많다. | 입력 크기가 크고 반복 구조다. |

- 예시 1) 피보나치 bottom-up으로 재구성
```kotlin
class FibonacciBottomUp {  
  
    /**  
     * 📄 문제 요약  
     *  
     * 정수 n이 주어졌을 때, n번째 피보나치 수를 구하세요.  
     * (f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2))     
     */
     

	@Test  
    fun fibonacciBottomUp(){  
        assertEquals(5, bottomUp(5))  
    }  
  
    private fun bottomUp(number: Int): Int {  
        val table = Array(number + 1) { i ->  
            when(i) {  
                0 -> 0  
                1 -> 1  
                else -> 0  
            }  
        }  
  
        for(i in 2 ..  number) {  
            table[i] = table[i - 2] + table[i -1]  
        }  
  
  
        return table[number]  
    }  
}


```