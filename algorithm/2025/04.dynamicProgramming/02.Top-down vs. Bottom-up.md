### Top-down
- 재귀를 기반으로 큰 문제를 작은 문제로 나누면서 내려간다.
- 중복되는 계산 결과는 저장해서 다시 계산하지 않는다.
> #### 내부 구조
> - f(n) 호출 -> (f(n-1), f(n-2)) 호출 -> 결과를 저장하면서 돌아오고 누적
 

### Bottom-up
- 작은 문제에서 큰 문제까지 반복적으로 올라가며, 필요한 값을 테이블에 직접 채우는 방식
> #### 내부 구조
> - dp[0], dp[1] 초기 값 설정
> - for i in 2 .. n 반복해가며 dp[i] 계산

|   항목    |        Top-down        |     Bottom-up     |
| :-----: | :--------------------: | :---------------: |
|   구조    |    재귀 + memoization    |     반복문 + 배열      |
|  캐싱 위치  |         함수 내부          |      외부 테이블       |
|  계산 순서  |     큰 문제 -> 작은 문제      |   작은 문제 -> 큰 문제   |
|  계산 범위  |        필요한 만큼만         |     대부분 모든 상태     |
|   장점    |     직관적, 조건 분기 유연      |    빠름, 메모리 안정     |
|   단점    |   스택 깊이 문제, 디버깅 어려움    |    불필요한 계산 포함     |
| 언제 선택하나 | 문제 구조가 복잡하고 조건 분기가 많다. | 입력 크기가 크고 반복 구조다. |

- 예시 1) 피보나치 bottom-up으로 재구성
```kotlin
class FibonacciBottomUp {  
  
    /**  
     * 📄 문제 요약  
     *  
     * 정수 n이 주어졌을 때, n번째 피보나치 수를 구하세요.  
     * (f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2))     
     */
     

	@Test  
    fun fibonacciBottomUp(){  
        assertEquals(5, bottomUp(5))  
    }  
  
    private fun bottomUp(number: Int): Int {  
        val table = Array(number + 1) { i ->  
            when(i) {  
                0 -> 0  
                1 -> 1  
                else -> 0  
            }  
        }  
  
        for(i in 2 ..  number) {  
            table[i] = table[i - 2] + table[i -1]  
        }  
  
  
        return table[number]  
    }  
}

/***  
 *  여기서 테이블 사이즈를 number + 1으로 잡았다.  
 *  왜 n까지 쓰는데 n + 1짜리를 만드는가?  
 * 
 *  #### DP는 테이블 기반의 "상태 전이 시스템"  
 *  - dp는 아래와 같은 구성 요소로 이뤄진다.  
 *  1. 상태 정의(dp(n))  
 *  2. 점화식(dp(n) = dp(n-1)+dp(n-2)  
 *  3. 초기 값  
 *  - 여기서 n 계산을 위해서는 n-1, n-2가 필요 ==> 미리 테이블에 존재해야 한다.  
 *  - 이런 상황에서 n개로 하면 0~n-1개로 n개 저장 불가  
 */
```

### 메모리 최적화?(상태 압축)
- Bottom-up에서 모든 상태를 배열에 저장하지 않고, 현재 계산에 필요한 최소 상태만 남기고 나머지를 버리는 형식
- dp[n] = dp[n-1] + dp[n-2]와 같이 딱 몇 개의 이전 값만 참조할 경우
- 즉, 현재 값 계산에 이전 전체 값이 필요하지는 않는 경우
- 이 경우 기할당된 공간을 재할당하는 식으로 메모리를 절약할 수 있다.

- 예시 2) 계단 오르기
```kotlin
class Step {  
    /**  
     *     
     * ⸻  
     * 🧪 문제 1. 계단 오르기  
     * 📄 문제 설명  
     * 한 번에 1칸 또는 2칸을 오를 수 있다.  
     * 총 n칸의 계단이 있을 때, 정확히 n번째 칸에 도달하는 방법의 수를 구하시오.  
     * 입력  
     *  •  정수 n (1 ≤ n ≤ 10⁶)     
     * 출력  
     *  •  방법의 수 (mod 1,000,000,007)     
     *     
     * n = 1 (1) 1     
     * n = 2 (1+1) (2) 2     
     * n = 3 (1+1+1) (1+2) (2+1) 3     
     * n = 4 (1+1+1+1) (1+1+2) (1+2+1) (2+1+1) (2+2) 5     
     * n = 5 (1+1+1+1+1) (1+1+1+2) (1+1+2+1) (1+2+1+1) (2+1+1+1) (1+2+2) (2+1+2) (2+2+1)     
     * --> fibonacci     
     */
      
    @Test  
    fun solution(){  
  
        val expected = 8  
        val result = useFibonacci(5) % 1_000_000_007  
  
        assertEquals(expected, result)  
    }  
  
    private fun useFibonacci(number: Int): Int {  
        val table = Array(number + 1){  
            i -> when(i) {  
                0 -> 1  
                1 -> 2  
                else -> 0  
            }  
        }  
  
        for(i in 2 .. number) {  
            table[i] = table[i - 1] + table[i - 2]  
        }  
  
        return table[number - 1]  
    }  
}
```
- 예시 3) 등굣길
```kotlin
  
class OnTheWayToSchool {  
    /**  
     * 🧪 문제 2. 등굣길  
     * ⸻  
     * 📄 문제 설명  
     * m × n 격자판이 있다.  
     * 왼쪽 위에서 시작해 오른쪽 아래로 이동하는 경우의 수를 구하시오.  
     * 오른쪽, 아래로만 이동할 수 있고, 물웅덩이는 피해야 한다.  
     * ⸻  
     * 📥 입력  
     *  •  정수 m, n (1 ≤ m, n ≤ 100)   
	 *  •  물웅덩이 좌표 리스트 [[x1, y1], [x2, y2], ...]  
	 * ⸻  
     * 📤 출력  
     *  •  가능한 모든 이동 경로의 수  
     * ⸻  
     */  
  
    @Test  
    fun solution(){  
  
        val expected = 70  
        val result = useBottomUp(5,5, Array(0){IntArray(0)})  
  
        assertEquals(expected, result)  
    }  
  
    private fun useBottomUp(m: Int, n:Int, spot: Array<IntArray>): Int {  
        val table = Array(m + 1) { IntArray(n + 1) }  
        table[1][1] = 1  
  
        for(i in 0 until  spot.size) {  
            val (x,y) = spot[i]  
            table[x][y] = -1  
        }  
  
        for(i in 1 .. m) {  
            for(j in 1 .. n) {  
                if ( table[i][j] == -1) {  
                    table[i][j] = 0  
                    continue  
                }  
  
                if(table[i - 1][j] != -1) table[i][j] += table[i - 1][j]  
                if(table[i][j - 1] != -1) table[i][j] += table[i][j - 1]  
            }  
        }  
  
  
        return table[m][n]  
    }  
}
```
- 예시 4)  0/1 배낭 문제 (기초)

```kotlin
class BackPack {  
    /**  
     * 🧪 문제 3. 0/1 배낭 문제 (기초)  
     * ⸻  
     * 📄 문제 설명  
     * 무게 제한이 W인 배낭이 있고,  
     * 각 아이템은 (무게, 가치) 쌍으로 주어진다.  
     * 가치의 합이 최대가 되도록 아이템을 고를 때,  
     * 최대 가치를 구하시오.  
     * (각 아이템은 한 번만 사용 가능)  
     * ⸻  
     * 📥 입력  
     *  •  정수 N (아이템 수), 정수 W (배낭 최대 무게)  
     *  •  다음 N줄에 걸쳐 각 줄마다 weight, value 정보  
     * ⸻  
     * 📤 출력  
     *  •  배낭에 담을 수 있는 최대 가치  
     */  
  
    @Test  
    fun solution() {  
        val weight = 7  
        val itemCount = 3  
        val item = arrayOf(  
            intArrayOf(1, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 5),  
        )  
        val expected = 9  
  
        assertEquals(expected, backPack(itemCount, weight, item))  
    }  
  
    /**  
     * dp[i][j] => i 번째 물건까지 고려해서, 배낭 무게 j일 때 가능한 최대 가치  
     * i: 물건 개수  
     * j: 배낭 남는 무게  
     * dp[i][j]: 그 상태에서 만들 수 있는 최대 가치  
     *  
     *     * -> 구하고자 하는 것 : 최대 합  
     * -> dp[i][j] 자체에 대해서 생각할 수 있어야 한다.  
     *      -> 구하고자 하는 것에서 경우의 수를 줄이지 못해서 여러 경우의 수가 발생하는 것을 표현하기 위해서 그래프를 생각했음  
     *      -> 공간 당 상태가 아니라 파생되는 흐름과 경우의 수로 생각  
     *  
     * -> DP는 탐색이 아닌 기록이다.  
     */  
    fun backPack(itemCount: Int, capacity: Int, items: Array<IntArray>): Int {  
        val table = Array(itemCount + 1) { IntArray(capacity + 1) }  
        for (numberOfItem in 1..itemCount) {  
            val weight = items[numberOfItem - 1][0]  
            val value = items[numberOfItem - 1][1]  
  
            for (currentWeight in 0..capacity) {  
  
                table[numberOfItem][currentWeight] =  
                    if (currentWeight < weight) table[numberOfItem - 1][currentWeight]  
                    else maxOf(  
                        table[numberOfItem - 1][currentWeight],  
                        table[numberOfItem - 1][currentWeight - weight] + value  
                    )  
  
            }        }  
  
        return table[itemCount][capacity]  
    }  
}
```
- 예시 4-1) 예산 안에서 최대 가치 얻기
```kotlin
class InBudgetMaxValue {  
    /**  
     * 🔹 문제 1. 예산 안에서 최대 가치 얻기  
     *  
     * 설명  
     *  
     * 당신은 예산 B만큼을 갖고 있습니다.  
     * 물건 N개가 있고, 각 물건은 가격과 만족도가 주어집니다.  
     * 예산을 넘지 않게 몇 개의 물건을 선택했을 때, 총 만족도의 최대값은?  
     *     * 입력 예시  
     *  •  예산: B = 10  
     *  •  물건:  
     *  ```kotlin     
     *      val goods = arrayOf(     
     *          intArrayOf(2, 1),  // 가격 2, 만족도 1     
     *          intArrayOf(3, 4),  // 가격 3, 만족도 4     
     *          intArrayOf(5, 5)   // 가격 5, 만족도 5     
     *      )     
     *  ```    
     */  
     
    @Test  
    fun solution() {  
        val budget = 10  
        val goods = arrayOf(  
            intArrayOf(2, 1),  // 가격 2, 만족도 1            intArrayOf(3, 4),  // 가격 3, 만족도 4            intArrayOf(5, 5)   // 가격 5, 만족도 5        )  
        val expected = 10  
  
        assertEquals(expected, budgetAndMaxValue(budget, goods))  
    }  
  
    private fun budgetAndMaxValue(budget: Int, goods: Array<IntArray>): Int {  
        val table = Array(goods.size + 1) { IntArray(budget+1)}  
  
        for(i in 1 ..  goods.size) {  
            val price = goods[i - 1][0]  
            val satisfaction = goods[i - 1][1]  
  
            for(j in 0 .. budget) {  
                table[i][j] = if(j < price) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - price] + satisfaction)  
            }        }  
  
  
        return table[goods.size][budget]  
    }  
}
```

- 예시 4-2) 시간 내 최대 업무 효율
```kotlin
class MaxEfficiency {  
    /**  
     * 🔹 문제 2. 시간 내 최대 업무 효율  
     *  
     * 설명  
     *  
     * 당신에겐 T시간이 있습니다.  
     * 일 N개가 있고, 각 일은 걸리는 시간과 효율 점수가 있습니다.  
     * 정해진 시간 내에 몇 개의 일을 골라서 효율의 총합이 최대가 되도록 하세요.  
     * 
     * ⸻  
     *  
     * 입력 예시  
     *  •  시간 제한: T = 8  
     *  •  일 목록:  
     *  ```kotlin     
     *  val tasks = arrayOf(     
     *     intArrayOf(2, 3),  // 시간 2, 점수 3    
     *     intArrayOf(4, 5),  // 시간 4, 점수 5     
     *     intArrayOf(3, 6)   // 시간 3, 점수 6    
     * )     
     *  ```     
     */  
     
    @Test  
    fun solution(){  
        val time = 8  
        val tasks = arrayOf(  
            intArrayOf(2, 3),  // 시간 2, 점수 3            intArrayOf(4, 5),  // 시간 4, 점수 5            intArrayOf(3, 6)   // 시간 3, 점수 6        )  
        val expected = 11  
  
        assertEquals(expected, maxEfficiency(time, tasks))  
    }  
  
    private fun maxEfficiency(time: Int, tasks: Array<IntArray>): Int {  
        val table = Array(tasks.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. tasks.size){  
            val (spendTime, score) = tasks[i - 1]  
  
            for( j in 0 .. time) {  
                table[i][j] =  
                if(j < spendTime)  table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[tasks.size][time]  
    }  
}
```

- 예시 4-3) 최대 공부 점수
```kotlin
class MaxStudyTime {  
    /**  
     * 🔹 문제 3. 최대 공부 점수  
     *  
     * 설명  
     *  
     * 학생은 k시간 동안 공부할 수 있습니다.  
     * 각 과목마다 공부 시간과 점수가 있습니다.  
     * 어떤 과목을 공부할지 선택해서, 총 점수가 최대가 되도록 하세요.  
     * ⸻  
     * 입력 예시  
     *  •  공부 시간 한도: k = 5  
     *  •  과목 목록:  
     *  ```kotlin    
     *  val subjects = arrayOf(    
     *     intArrayOf(1, 2),  // 시간 1, 점수 2    
     *     intArrayOf(2, 4),  // 시간 2, 점수 4     
     *     intArrayOf(3, 5)   // 시간 3, 점수 5     
     * )    
     *  ```    
     */
       
    @Test  
    fun solution() {  
        val maxTime = 5  
        val subjects = arrayOf(  
            intArrayOf(1, 2),  // 시간 1, 점수 2            intArrayOf(2, 4),  // 시간 2, 점수 4            intArrayOf(3, 5)   // 시간 3, 점수 5        )  
  
        val expected = 9  
  
        assertEquals(expected, study(maxTime, subjects))  
    }  
  
    private fun study(time: Int, subject: Array<IntArray>): Int {  
        val table = Array(subject.size + 1) { IntArray(time + 1) }  
  
        for(i in 1 .. subject.size) {  
            val (spendTime, score) = subject[i]  
            for (j in 0 .. time) {  
                table[i][j] = if(j < spendTime) table[i - 1][j]  
                else maxOf(table[i - 1][j], table[i - 1][j - spendTime] + score)  
            }        }  
  
        return table[subject.size][time]  
    }  
}
```
