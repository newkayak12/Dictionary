### Top-down
- 재귀를 기반으로 큰 문제를 작은 문제로 나누면서 내려간다.
- 중복되는 계산 결과는 저장해서 다시 계산하지 않는다.
> #### 내부 구조
> - f(n) 호출 -> (f(n-1), f(n-2)) 호출 -> 결과를 저장하면서 돌아오고 누적
 

### Bottom-up
- 작은 문제에서 큰 문제까지 반복적으로 올라가며, 필요한 값을 테이블에 직접 채우는 방식
> #### 내부 구조
> - dp[0], dp[1] 초기 값 설정
> - for i in 2 .. n 반복해가며 dp[i] 계산

|   항목    |        Top-down        |     Bottom-up     |
| :-----: | :--------------------: | :---------------: |
|   구조    |    재귀 + memoization    |     반복문 + 배열      |
|  캐싱 위치  |         함수 내부          |      외부 테이블       |
|  계산 순서  |     큰 문제 -> 작은 문제      |   작은 문제 -> 큰 문제   |
|  계산 범위  |        필요한 만큼만         |     대부분 모든 상태     |
|   장점    |     직관적, 조건 분기 유연      |    빠름, 메모리 안정     |
|   단점    |   스택 깊이 문제, 디버깅 어려움    |    불필요한 계산 포함     |
| 언제 선택하나 | 문제 구조가 복잡하고 조건 분기가 많다. | 입력 크기가 크고 반복 구조다. |

- 예시 1) 피보나치 bottom-up으로 재구성
```kotlin
class FibonacciBottomUp {  
  
    /**  
     * 📄 문제 요약  
     *  
     * 정수 n이 주어졌을 때, n번째 피보나치 수를 구하세요.  
     * (f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2))     
     */
     

	@Test  
    fun fibonacciBottomUp(){  
        assertEquals(5, bottomUp(5))  
    }  
  
    private fun bottomUp(number: Int): Int {  
        val table = Array(number + 1) { i ->  
            when(i) {  
                0 -> 0  
                1 -> 1  
                else -> 0  
            }  
        }  
  
        for(i in 2 ..  number) {  
            table[i] = table[i - 2] + table[i -1]  
        }  
  
  
        return table[number]  
    }  
}

/***  
 *  여기서 테이블 사이즈를 number + 1으로 잡았다.  
 *  왜 n까지 쓰는데 n + 1짜리를 만드는가?  
 * 
 *  #### DP는 테이블 기반의 "상태 전이 시스템"  
 *  - dp는 아래와 같은 구성 요소로 이뤄진다.  
 *  1. 상태 정의(dp(n))  
 *  2. 점화식(dp(n) = dp(n-1)+dp(n-2)  
 *  3. 초기 값  
 *  - 여기서 n 계산을 위해서는 n-1, n-2가 필요 ==> 미리 테이블에 존재해야 한다.  
 *  - 이런 상황에서 n개로 하면 0~n-1개로 n개 저장 불가  
 */
```

### 메모리 최적화?(상태 압축)
- Bottom-up에서 모든 상태를 배열에 저장하지 않고, 현재 계산에 필요한 최소 상태만 남기고 나머지를 버리는 형식
- dp[n] = dp[n-1] + dp[n-2]와 같이 딱 몇 개의 이전 값만 참조할 경우
- 즉, 현재 값 계산에 이전 전체 값이 필요하지는 않는 경우
- 이 경우 기할당된 공간을 재할당하는 식으로 메모리를 절약할 수 있다.

