## 기본 개념
1. 매 순간마다 가장 최적이라고 생각하는 선택을 하는 방식(당시 상황에서 최적)
2. 과연 각 상황에서의 최적해의 합이 *"전체 최적해"*가 되는가는 증명이 필요하다.

## 핵심 특징
1. 탐욕 선택 조건 (Greedy Choice Property)
   -> 각 단계의 최선의 선택이 전체적으로 최적이 된다.
2. 문제 분할 불가능(DP와의 차이점)
   -> 중복 부분 문제는 없고, 한 번 결정되면 되돌릴 수 없다.
## 그리디인지 파악
#### **🔷** **문제를 보고 “그리디 문제”임을 어떻게 알 수 있는가?**
1.  전형적 패턴:
	- **정렬 후, 단순 규칙으로 반복 처리**
	- 한 번의 “선택”이 이후 선택에 영향을 주지 않는 경우 (국소적으로 최적 선택이 전체 최적)
	예)
	- 동전 거스름돈 문제
	- 활동 선택 문제
	- 최소 스패닝 트리 (크루스칼)
2.  키워드:
	- “최소 개수/최소 횟수”를 구하라는 문제
	- “최소 비용/최대 이익”을 구하라는 문제
	- “순서/위치”를 잘 정리해서 결정해야 하는 문제
3. 반례 체크:
	- “모든 경우를 고려할 필요 없는 문제”
	- “각 단계에서 최적이라고 보이는 것만 고르면 전체도 최적”이라는 암시가 있으면 그리디
> 정렬 -> 규칙 -> 반복
> 1. 정렬 기준 찾기
> 2. 선택 규칙 정의
> 3. 반복 구조 확인
> 4. 반례를 문제 구조로 확인

### 패턴
1. 현재 선택이 최적이다.
	1. 각 단계에서 할 수 있는 최적을 찾는다.
	2. 이를 이어 붙이면 전체 최적해가 된다.
2. 패턴
	1. 정렬 + 선택
		1. 회의실 배정
		2. 보상 카드
		3. 체육복
		4. (보상, 비용) 케이스
	2. 우선 순위 큐
		1. 보상 카드
		2. 허프만
		3. 최소비용 연결
		4. 후보를 한꺼번에 두고 좋은 것을 골리서 쓰는 경우
		5. 각 선택이 한 번만 쓰이고, 그 선택으로 전체 결과가 보장
	3. 단일 경로 탐색
		1. 잔돈 거스름
		2. 배낭
		3. 각 선택이 다른 선택에 영향을 주지 않고, 독립적으로 최적 선택이 되는 경우
	4. 정렬 기반 순서 결정
		1. 활동 서택
		2. 최소 회의실
		3. 일찍 끝나는 순서대로 혹은 시작 조건으로 정렬

## 예시 문제
1) 회의실 배정 문제
```kotlin
class MeetingRoom {  
    /**  
     * 🟩 회의실 배정 문제  
     *  
     * ✅ 문제 설명  
     * 한 개의 회의실이 있습니다.  
     * N개의 회의가 있고, 각 회의마다 시작 시간과 끝나는 시간이 주어집니다.  
     * 각 회의는 한 번에 한 개씩만 진행할 수 있으며,  
     * 회의가 끝나는 시간과 다음 회의의 시작 시간은 같아도 됩니다.  
     *    
     * 👉 회의실을 사용할 수 있는 회의의 최대 개수를 구하세요.  
     *    
     * ⸻  
     *  
     * ✅ 입력  
     *  •  첫째 줄: 회의의 개수 N (1 ≤ N ≤ 100,000)  
     *  •  둘째 줄부터 N개의 줄에: 회의의 시작 시간과 끝나는 시간이 주어집니다.  
     *  •  시작 시간과 끝나는 시간은 0 이상 2^31-1 이하의 정수입니다.  
     *
	 * ✅ 출력  
     *  •  회의실에서 진행할 수 있는 최대 회의 개수를 출력하세요.  
     * 
     * ✅ 예제 입력  
     * 회의 개수: 5  
     * | 시작 | 끝 |  
     * |  1  | 4 |    
     * |  2  | 3 |
     * |  3  | 5 |
     * |  0  | 6 |
     * |  5  | 7 | 
     *    
     * ✅ 예제 출력  
     * 3  
     */


//일단 문제만으로 구체화해서 풀어보면?
	@Test  
    fun solution(){  
        val timetable: Array<IntArray> = arrayOf(  
                intArrayOf(1, 4),  
                intArrayOf(2, 3),  
                intArrayOf(3, 5),  
                intArrayOf(0, 6),  
                intArrayOf(5, 7)  
            )  
        val excepted = 3  
  
        /**  
         * 2-3 -> 3-5 -> 5-7로 총 3개로 예상  
         *  
         * 1. 이전 시간과 겹치는지 확인  
         *  1. 겹치면 시간 체크  
         *      1. running 타임 비교  
         *  2. 안겹치면 추가  
         */  
  
        assertEquals(excepted, useGreedy(timetable))  
        assertEquals(excepted, optimizeUseGreedy(timetable))
    }  
  
    private fun useGreedy(timetable: Array<IntArray>): Int {  
        val deque = ArrayDeque<IntArray>();  
        deque.add(timetable[0])  
  
        for( i in 1 ..< timetable.size) {  
            val before = deque.last()  
  
            if( before[1] <= timetable[i][0]) {  
                deque.add(timetable[i])  
            }  
            else {  
                val beforeRunningTime = before[1] - before[0]  
                val nowRunningTime = timetable[i][1] - timetable[i][0]  
  
                if(  
                    nowRunningTime < beforeRunningTime ||  
                    nowRunningTime == beforeRunningTime && before[1] > timetable[i][1]  
                ){  
                    deque.removeLast()  
                    deque.add(timetable[i])  
                }  
            }  
        }  
  
  
        return deque.size  
    }
    
    
    //조금 더 쉽게 생각하면 끝나는 시간만 생각하면 된다.  
  
	private fun optimizeUseGreedy(timetable: Array<IntArray>): Int {  
	    timetable.sortBy { it[1] }  
	    var count = 1  
	    var lastEndTime = timetable[0][1]  
	  
	    for( i in 1 until  timetable.size) {  
	        if(timetable[i][0] >= lastEndTime) {  
	            count ++  
	            lastEndTime = timetable[i][1]  
	        }  
	    }  
	  
	   return count  
	}
}
```

2) 동전 개수 문제
```kotlin
class MinimumCoins {  
    /**  
     * 🟩 문제 이름: 최소 동전 개수 계산  
     *  
     * 📘 문제 설명  
     * 주어진 동전으로 목표 금액을 맞추려고 합니다.  
     * 동전 단위는 서로 배수 관계를 가질 수 있으며, 가능한 경우 가장 적은 동전 개수를 사용해야 합니다.  
     *     
     * ⸻  
     *  
     * 📥 입력  
     *  •  첫째 줄: 동전의 개수 N (1 ≤ N ≤ 10)    
     *  •  둘째 줄: 동전 단위 (공백으로 구분된 N개의 자연수)  
     *  •  셋째 줄: 목표 금액 M (1 ≤ M ≤ 10,000)  
     *   
     * ⸻  
     *  
     * 📤 출력  
     *  •  목표 금액 M을 만들기 위한 최소 동전 개수를 출력하세요.  
     *     
     * 🧪 예제 입력 1   
     * 동전 개수 : 4    
     * 동전 단위 : 500 100 50 10    
     * 목표 금액 : 1260    
     * 🧪 예제 출력 1    
     * 6     
     *     
     * 🧪 예제 입력 2   
     * 동전 개수 : 3   
     * 동전 단위 : 9 6 1    
     * 목표 금액 : 15   
     * 🧪 예제 출력 2   
     * 2    
     */
       
    @Test  
    fun solution1() {  
        val coinCount = 4  
        val coinTypes = intArrayOf(500, 100, 50, 10)  
        val target = 1260  
        val expected = 6  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    @Test  
    fun solution2() {  
        val coinCount = 3  
        val coinTypes = intArrayOf(9,6,1)  
        val target = 15  
        val expected = 2  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    private fun greedy(coinTypes: IntArray, target: Int): Int {  
        var usedCount = 0  
        var targetAmount = target  
        coinTypes.sortDescending()  
  
  
        for( coin in coinTypes ) {  
            if( targetAmount <= 0) break  
            if( targetAmount / coin > 0) {  
                val div = targetAmount/coin  
                usedCount += div  
                targetAmount -= coin * div  
            }  
        }  
  
        return usedCount  
    }  
  
}
```

3) 보상 카드 사용 전략 문제
```kotlin
package renewal.greedy  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.PriorityQueue  
  
class StrategyOfSelectionAboutRewardCard {  
    /**  
     * 🟩 문제 이름: 보상 카드 사용 전략  
     *  
     * 📘 문제 설명  
     * 당신에게는 다양한 보상 카드를 사용할 기회가 주어집니다. 각 보상 카드는 사용 기한(날짜)과 보상 금액이 정해져 있습니다.  
     * 하루에 한 번씩, 기한이 되기 전(포함)까지 사용할 수 있는 카드 중 보상이 가장 큰 카드를 선택할 수 있습니다.  
     *   
     * 주어진 카드 정보로, 보상 금액의 합이 최대가 되도록 사용하는 경우의 총 보상 금액을 구하세요.  
     *   
     * ⸻  
     *  
     * 📥 입력  
     *  •  첫째 줄: 카드의 개수 N (1 ≤ N ≤ 1,000)     
     *  •  둘째 줄 ~ N+1번째 줄: 각 카드의 사용 기한 d(1 ≤ d ≤ 1,000)와 보상 금액 p(1 ≤ p ≤ 100,000) 
     *
	 * ⸻  
     *  
     * 📤 출력  
     *  •  보상 금액의 합이 최대가 되는 값을 출력하세요.  
     * 
     *
	 * 
	 * 🧪 예제 입력 1   
	 *  3  
	 * 1 10 
	 * 2 20 
	 * 3 30     * -> 1일차(10) + 2일차(20) +3일차(30)  
     *    
     * 🧪 예제 출력 1  
     * 60   
     *    
     * 🧪 예제 입력 2   
     * 5    
     * 3 50    
     * 3 10    
     * 1 20     
     * 2 40   
     * 2 30    
     *   
     * 🧪 예제 출력 2     
     * 120   
     *     
     * -> 1일차 (3 50), (3 10), (1 20), (2 40), ✅ (2 30)    
     * -> 2일차 (3 50), (3 10), ✅ (2 40)    
     * -> 3일차 ✅ (3 50), (3 10)
     */  
  
    @Test  
    fun solution1() {  
        val table = arrayOf(  
            intArrayOf(1, 10),  
            intArrayOf(2, 20),  
            intArrayOf(3, 30),  
        )  
  
        val expected = 60  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution2() {  
        val table = arrayOf(  
            intArrayOf(3, 50),  
            intArrayOf(3, 10),  
            intArrayOf(1, 20),  
            intArrayOf(2, 40),  
            intArrayOf(2, 30),  
        )  
  
        val expected = 110  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution3() {  
        val table = arrayOf(  
            intArrayOf(1, 10),  
            intArrayOf(2, 20),  
            intArrayOf(3, 100),  
            intArrayOf(1, 100),  
            intArrayOf(2, 1),  
        )  
  
        val expected = 220  
  
        assertEquals(expected, greedy(table))  
    }  
  
  
    private fun greedy(table: Array<IntArray>): Int {  
        val sortedTable = table.sortedBy { it[0] }  
        val dueDate = sortedTable.maxOf { it[0] }  
        val queue = PriorityQueue<Int> (compareByDescending { it })  
  
        var result = 0  
        var index = 0  
  
        for (day in 1 .. dueDate) {  
           while(index < sortedTable.size && sortedTable[index][0] <= day){  
               queue.add(sortedTable[index][1])  
               index++  
           }  
  
  
            if(queue.isNotEmpty()) {  
                result += queue.poll()  
            }  
        }  
  
  
        return result  
    }  
}
```
4) 택배 배송 문제
```kotlin
package renewal.greedy  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.PriorityQueue  
  
class Delivery {  
    /**  
     * 🟩 문제 이름: 📦 택배 배송  
     *  
     * 📘 문제 설명  
     * 한 마을에 N개의 택배 주문이 있습니다.  
     * 각 주문은 배송 시작 가능일(start), 배송 마감일(end), 그리고 **배송비(payment)**가 정해져 있습니다.  
     * 하루에 하나의 주문만 처리할 수 있고,  
     * 배송비의 합이 최대가 되도록 배송 일정을 정하려고 합니다.  
     *   
     * ⸻  
     *  
     * 📥 입력  
     *  •  첫째 줄: 주문의 개수 N (1 ≤ N ≤ 10,000) 
     *  •  이후 N줄: 각 주문의 배송 시작일 start, 배송 마감일 end, 배송비 payment (1 ≤ start ≤ end ≤ 1,000 / 1 ≤ payment ≤ 100,000)    
     *     
     * ⸻  
     *  
     * 📤 출력  
     *  •  가능한 최대 배송비의 합을 출력하세요.  
     *   
     * 🧪 예제 입력  
     *  4  
     * 1 2 50   
     * 1 3 10   
     * 2 2 20   
     * 3 3 30    
     *    
     * 🧪 예제 출력  
     * 100  
     * 
     * 1일 -> ✅(1, 2, 50), (1, 3, 10)  
     * 2일 -> ✅(2, 2, 20)  
     * 3일 -> (1, 3, 10), ✅(3, 3, 30)  
     */  
    @Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 3, 10),  
            intArrayOf(2, 2, 20),  
            intArrayOf(3, 3, 30),  
        )  
  
        val expected = 100  
  
        assertEquals(expected, greedy(table))  
    }  
  
    @Test  
    fun solution2() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 2, 40),  
            intArrayOf(1, 2, 30),  
        )  
  
        val expected = 90  
  
        assertEquals(expected, greedy(table))  
    }  
  
    private fun greedy(table: Array<IntArray>): Int {  
        val sortedTable = table.sortedWith(compareBy({ it[0] }, { it[1] }))  
        val pq = PriorityQueue<IntArray>(compareByDescending { it[2] })  
        val maxDay = table.maxOf { it[1] }  
  
        var index = 0  
        var result = 0  
  
        for (day in 1..maxDay) {  
  
            while (index < sortedTable.size && sortedTable[index][0] <= day) {  
                pq.add(sortedTable[index])  
                index++  
            }  
  
            while (pq.isNotEmpty()) {  
                val content = pq.poll()  
                if(content[1] >= day){  
                    result += content[2]  
                    break  
                }  
            }  
  
        }  
  
        return result  
    }  
}
```
5) 과일 바구니 채우기
```kotlin
class FruitsBox {  
    /**  
     * 🟩 문제 이름: 📦 과일 바구니 채우기  
     *  
     * 📘 문제 설명  
     * 당신은 다양한 종류의 과일을 팔고 있는 상인이며, 각각의 과일에는 가격이 정해져 있습니다.  
     * 당신은 하루 동안 한 종류의 과일을 하나씩만 팔 수 있으며, 과일을 팔 수 있는 기간도 정해져 있습니다.  
     * 당신은 하루에 한 번, 팔 수 있는 과일 중 가장 비싼 과일을 팔아야 합니다.  
     *    
     * 과일마다 주어진 판매 가능 기간 중, 가장 비싼 과일을 팔아 얻을 수 있는 총 수익을 구하세요.  
     *    
     * ⸻  
     *  
     * 📥 입력  
     *  •  첫 번째 줄: 과일의 개수 N (1 ≤ N ≤ 1,000)    
     *  •  이후 N줄: 각 과일의 판매 시작일 start, 판매 종료일 end, 가격 price (1 ≤ start ≤ end ≤ 1,000 / 1 ≤ price ≤ 100,000)    
     *   
     * ⸻  
     *  
     * 📤 출력  
     *  •  하루에 하나씩만 팔 수 있을 때, 가능한 최대 수익을 출력하세요.  
     *   
     * ⸻  
     *  
     * 🧪 예제 입력  
     * 4  
     * 1 2 50   
     * 1 3 10    
     * 2 2 20     
     * 3 3 30   
     *    
     * 🧪 예제 입력  
     * 100  
     */ 
     
	@Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 50),  
            intArrayOf(1, 3, 10),  
            intArrayOf(2, 2, 20),  
            intArrayOf(3, 3, 30)  
        )  
  
        val expected = 100  
  
        assertEquals(expected, greedy(table))  
    }  
  
    private fun greedy(table: Array<IntArray>): Int {  
        table.sortWith(compareBy ({ it[0] }, {it[1]}))  
        val maxDay = table.maxOf { it[1] }  
        val queue = PriorityQueue<IntArray>(compareByDescending { it[2] })  
        var index = 0  
        var result = 0  
  
        for(day in 1 .. maxDay) {  
  
            while( index < table.size && day >= table[index][0]) {  
                queue.add(table[index++])  
            }  
  
  
            while (queue.isNotEmpty()) {  
                val element = queue.poll()  
                if( element[1] >= day ) {  
                    result += element[2]  
                    break  
                }  
            }  
        }  
  
        return result  
    }  
}
```
6) 최소 회의실 문제
```kotlin
class MeetingRoomMinimum {  
    /**  
     * 🟩 패턴: 정렬 기반 순서 결정  
     *  
     * 2. 최소 회의실 문제  
     *  
     * 💡 문제 이름  
     * 🪑 최소 회의실 개수  
     *  
     * 📘 문제 설명  
     * 여러 개의 회의가 주어져 있고, 각 회의는 시작 시간과 종료 시간이 있습니다.  
     * 동시에 여러 회의를 열 수 있지만, 같은 회의실에서 겹치는 회의는 불가능합니다.  
     * 모든 회의를 열기 위해 필요한 최소 회의실 수를 구하세요.  
     *     * ⸻  
     *  
     * 📥 입력  
     *  •  첫째 줄: 회의 수 N (1 ≤ N ≤ 1,000)
     *  •  이후 N줄: 각 회의의 시작 시간, 종료 시간 (0 ≤ s < e ≤ 1,000)    
     *  
     * ⸻  
     *  
     * 📤 출력  
     *  •  필요한 최소 회의실의 수  
     *  
     * ⸻  
     *  
     * 🧪 예제 입력  
     * 3  
     * 0 5 
     * 1 2    
     * 1 10   
     *    
     * 🧪 예제 출력  
     * 3  
     */  
 
    @Test  
    fun solution() {  
        val timetable = arrayOf(  
            intArrayOf(0, 5),  
            intArrayOf(1, 2),  
            intArrayOf(1, 10)  
        )  
  
        val expected = 3  
  
        assertEquals(expected, greedy((timetable)))  
    }  
  
    private fun greedy(timetable: Array<IntArray>): Int {  
        timetable.sortWith(compareBy({ it[0] }, { it[1] }))  
        val queue = PriorityQueue<IntArray>(compareBy { it[1] })  
        queue.add(timetable[0])  
        for (i in 1 until timetable.size) {  
            if (queue.peek()[1] <= timetable[i][0]) {  
                queue.poll()  
            }  
            queue.add(timetable[i])  
        }  
        return timetable.size  
    }  
}
```

7) 기타 수리
```kotlin
class GuitarRepairShop {  
    /**  
     * 🟩 문제 이름: 🎸 기타 수리  
     *  
     * 📘 문제 설명  
     * 당신은 기타 수리점의 기사입니다.  
     * 각 손님은 **도착일(start)**과 **최대 기다릴 수 있는 기간(wait)**을 가지고 있습니다.  
     * 하루에 기타 하나만 수리할 수 있으며, 손님은 자신이 도착한 날부터 기다릴 수 있는 날짜까지 수리를 맡기고 싶어 합니다.  
     *    
     * 모든 손님의 기타를 최대한 많이 수리하려고 합니다.  
     * 당신이 수리 가능한 기타의 개수를 구하세요.  
     * ⸻  
     * 📥 입력  
     *  •  첫째 줄: 손님 수 N (1 ≤ N ≤ 1,000)    
     *  •  이후 N줄: 각 손님의 도착일 start, 최대 대기일 wait (1 ≤ start ≤ 1,000, 1 ≤ wait ≤ 1,000)     
     * ⸻  
     * 📤 출력  
     *  •  수리할 수 있는 기타의 최대 개수  
     * ⸻  
     * 🧪 예제 입력  
     * 5  
     * 1 2    
     * 3 1   
     * 2 3    
     * 4 2    
     * 5 1   
     * 🧪 예제 출력  
     * 5  
     */  
     
    @Test  
    fun solution() {  
        val timetable = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(3, 1),  
            intArrayOf(2, 3),  
            intArrayOf(4, 2),  
            intArrayOf(5, 1),  
        )  
  
        val expected = 5  
  
        assertEquals(expected, greedy(timetable))  
    }  
  
    @Test  
    fun solution1() {  
        val timetable = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 2),  
            intArrayOf(2, 1),  
            intArrayOf(2, 1),  
            intArrayOf(1, 2),  
        )  
  
        val expected = 3  
  
        assertEquals(expected, greedy(timetable))  
    }  
  
  
    private fun greedy(timetable: Array<IntArray>): Int {  
        timetable.sortWith(compareBy { it[0] + it[1] })  
        var day = 1  
        var count = 0  
  
        for (table in timetable) {  
            val start = table[0]  
            val end = table[0] + table[1]  
  
            if(day < start) {  
                day = start  
            }  
  
            if(day in start .. end) {  
                count++  
                day++  
            }  
        }  
  
        return count  
    }  
}
```