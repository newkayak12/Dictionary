## 기본 개념
1. 매 순간마다 가장 최적이라고 생각하는 선택을 하는 방식(당시 상황에서 최적)
2. 과연 각 상황에서의 최적해의 합이 *"전체 최적해"*가 되는가는 증명이 필요하다.

## 핵심 특징
1. 탐욕 선택 조건 (Greedy Choice Property)
   -> 각 단계의 최선의 선택이 전체적으로 최적이 된다.
2. 문제 분할 불가능(DP와의 차이점)
   -> 중복 부분 문제는 없고, 한 번 결정되면 되돌릴 수 없다.
## 그리디인지 파악
#### **🔷** **문제를 보고 “그리디 문제”임을 어떻게 알 수 있는가?**
1.  전형적 패턴:
	- **정렬 후, 단순 규칙으로 반복 처리**
	- 한 번의 “선택”이 이후 선택에 영향을 주지 않는 경우 (국소적으로 최적 선택이 전체 최적)
	예)
	- 동전 거스름돈 문제
	- 활동 선택 문제
	- 최소 스패닝 트리 (크루스칼)
2.  키워드:
	- “최소 개수/최소 횟수”를 구하라는 문제
	- “최소 비용/최대 이익”을 구하라는 문제
	- “순서/위치”를 잘 정리해서 결정해야 하는 문제
3. 반례 체크:
	- “모든 경우를 고려할 필요 없는 문제”
	- “각 단계에서 최적이라고 보이는 것만 고르면 전체도 최적”이라는 암시가 있으면 그리디
> 정렬 -> 규칙 -> 반복
> 1. 정렬 기준 찾기
> 2. 선택 규칙 정의
> 3. 반복 구조 확인
> 4. 반례를 문제 구조로 확인

## 예시 문제
1) 회의실 배정 문제
```kotlin
class MeetingRoom {  
    /**  
     * 🟩 회의실 배정 문제  
     *  
     * ✅ 문제 설명  
     * 한 개의 회의실이 있습니다.  
     * N개의 회의가 있고, 각 회의마다 시작 시간과 끝나는 시간이 주어집니다.  
     * 각 회의는 한 번에 한 개씩만 진행할 수 있으며,  
     * 회의가 끝나는 시간과 다음 회의의 시작 시간은 같아도 됩니다.  
     *    
     * 👉 회의실을 사용할 수 있는 회의의 최대 개수를 구하세요.  
     *    
     * ⸻  
     *  
     * ✅ 입력  
     *  •  첫째 줄: 회의의 개수 N (1 ≤ N ≤ 100,000)  
     *  •  둘째 줄부터 N개의 줄에: 회의의 시작 시간과 끝나는 시간이 주어집니다.  
     *  •  시작 시간과 끝나는 시간은 0 이상 2^31-1 이하의 정수입니다.  
     *
	 * ✅ 출력  
     *  •  회의실에서 진행할 수 있는 최대 회의 개수를 출력하세요.  
     * 
     * ✅ 예제 입력  
     * 회의 개수: 5  
     * | 시작 | 끝 |  
     * |  1  | 4 |    
     * |  2  | 3 |
     * |  3  | 5 |
     * |  0  | 6 |
     * |  5  | 7 | 
     *    
     * ✅ 예제 출력  
     * 3  
     */


//일단 문제만으로 구체화해서 풀어보면?
	@Test  
    fun solution(){  
        val timetable: Array<IntArray> = arrayOf(  
                intArrayOf(1, 4),  
                intArrayOf(2, 3),  
                intArrayOf(3, 5),  
                intArrayOf(0, 6),  
                intArrayOf(5, 7)  
            )  
        val excepted = 3  
  
        /**  
         * 2-3 -> 3-5 -> 5-7로 총 3개로 예상  
         *  
         * 1. 이전 시간과 겹치는지 확인  
         *  1. 겹치면 시간 체크  
         *      1. running 타임 비교  
         *  2. 안겹치면 추가  
         */  
  
        assertEquals(excepted, useGreedy(timetable))  
        assertEquals(excepted, optimizeUseGreedy(timetable))
    }  
  
    private fun useGreedy(timetable: Array<IntArray>): Int {  
        val deque = ArrayDeque<IntArray>();  
        deque.add(timetable[0])  
  
        for( i in 1 ..< timetable.size) {  
            val before = deque.last()  
  
            if( before[1] <= timetable[i][0]) {  
                deque.add(timetable[i])  
            }  
            else {  
                val beforeRunningTime = before[1] - before[0]  
                val nowRunningTime = timetable[i][1] - timetable[i][0]  
  
                if(  
                    nowRunningTime < beforeRunningTime ||  
                    nowRunningTime == beforeRunningTime && before[1] > timetable[i][1]  
                ){  
                    deque.removeLast()  
                    deque.add(timetable[i])  
                }  
            }  
        }  
  
  
        return deque.size  
    }
    
    
    //조금 더 쉽게 생각하면 끝나는 시간만 생각하면 된다.  
  
	private fun optimizeUseGreedy(timetable: Array<IntArray>): Int {  
	    timetable.sortBy { it[1] }  
	    var count = 1  
	    var lastEndTime = timetable[0][1]  
	  
	    for( i in 1 until  timetable.size) {  
	        if(timetable[i][0] >= lastEndTime) {  
	            count ++  
	            lastEndTime = timetable[i][0]  
	        }  
	    }  
	  
	   return count  
	}
}
```

2) 동전 개수 문제
```kotlin
class MinimumCoins {  
    /**  
     * 🟩 문제 이름: 최소 동전 개수 계산  
     *  
     * 📘 문제 설명  
     * 주어진 동전으로 목표 금액을 맞추려고 합니다.  
     * 동전 단위는 서로 배수 관계를 가질 수 있으며, 가능한 경우 가장 적은 동전 개수를 사용해야 합니다.  
     *     
     * ⸻  
     *  
     * 📥 입력  
     *  •  첫째 줄: 동전의 개수 N (1 ≤ N ≤ 10)    
     *  •  둘째 줄: 동전 단위 (공백으로 구분된 N개의 자연수)  
     *  •  셋째 줄: 목표 금액 M (1 ≤ M ≤ 10,000)  
     *   
     * ⸻  
     *  
     * 📤 출력  
     *  •  목표 금액 M을 만들기 위한 최소 동전 개수를 출력하세요.  
     *     
     * 🧪 예제 입력 1   
     * 동전 개수 : 4    
     * 동전 단위 : 500 100 50 10    
     * 목표 금액 : 1260    
     * 🧪 예제 출력 1    
     * 6     
     *     
     * 🧪 예제 입력 2   
     * 동전 개수 : 3   
     * 동전 단위 : 9 6 1    
     * 목표 금액 : 15   
     * 🧪 예제 출력 2   
     * 2    
     */
       
    @Test  
    fun solution1() {  
        val coinCount = 4  
        val coinTypes = intArrayOf(500, 100, 50, 10)  
        val target = 1260  
        val expected = 6  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    @Test  
    fun solution2() {  
        val coinCount = 3  
        val coinTypes = intArrayOf(9,6,1)  
        val target = 15  
        val expected = 2  
  
        assertEquals(expected, greedy(coinTypes, target))  
    }  
  
    private fun greedy(coinTypes: IntArray, target: Int): Int {  
        var usedCount = 0  
        var targetAmount = target  
        coinTypes.sortDescending()  
  
  
        for( coin in coinTypes ) {  
            if( targetAmount <= 0) break  
            if( targetAmount / coin > 0) {  
                val div = targetAmount/coin  
                usedCount += div  
                targetAmount -= coin * div  
            }  
        }  
  
        return usedCount  
    }  
  
}
```