## 1. ì •ì˜
- ë°©í–¥ ê·¸ë˜í”„ì—ì„œ ì„ í›„ ê´€ê³„(ì˜ì¡´ì„±)ì„ ì§€í‚¤ë©´ì„œ ë…¸ë“œë¥¼ ì¼ë ¬ë¡œ ë‚˜ì—´í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.
- ë¹„ìˆœí™˜ ê·¸ë˜í”„(DAG, Directed Acyclic Graph)ì—ì„œ ëª¨ë“  ë…¸ë“œë¥¼ ì„ í–‰ ìˆœì„œì— ë”°ë¼ ë‚˜ì—´í•˜ëŠ” ì •ë ¬ì…ë‹ˆë‹¤.
- ìˆœì„œê°€ ì •í•´ì§„ ì‘ì—…ë“¤ì„ ì°¨ë¡€ëŒ€ë¡œ ì²˜ë¦¬í•´ì•¼ í•  ë–„ ì‚¬ìš©í•©ë‹ˆë‹¤.(ì˜ˆì‹œ. ì„ ìˆ˜ ê³¼ëª©, ì‘ì—… ìŠ¤ì¼€ì¥´ë§, ë¹Œë“œ ìˆœì„œ)

## 2. ì „ì œ ì¡°ê±´
- ìœ„ìƒì •ë ¬ì€ ë°˜ë“œì‹œ DAGì—¬ì•¼ í•œë‹¤.
- ì‚¬ì´í´ì´ ìˆìœ¼ë©´ ë¶ˆê°€í•˜ë‹¤.

## 3. í•µì‹¬ ê°œë…
- ì§„ì… ì°¨ìˆ˜(in-degree)
	- í•œ ë…¸ë“œë¡œ ë“¤ì–´ì˜¤ëŠ” ê°„ì„ ì˜ ê°œìˆ˜ì´ë‹¤.
	- ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¶€í„° ì •ë ¬ì„ ì‹œì‘í•œë‹¤.

## 4. êµ¬í˜„ ë°©ì‹
### 1. í ê¸°ë°˜ ìœ„ìƒ ì •ë ¬(Kahn's algorithm)
- ê° ë…¸ë“œì˜ ì§„ì… ì°¨ìˆ˜ë¥¼ ê³„ì‚°í•œë‹¤.
- ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ë…¸ë“œë¥¼ íì— ë„£ëŠ”ë‹¤.
- íì—ì„œ í•˜ë‚˜ì”© êº¼ë‚´ë©´ì„œ í•´ë‹¹ ë…¸ë“œì—ì„œ ë‚˜ê°€ëŠ” ê°„ì„ ì„ ì œê±°í•œë‹¤.
- ê°„ì„ ì„ ì œê±°í•œ í›„, ì§„ì… ì°¨ìˆ˜ê°€ 0ì¸ ëœ ë…¸ë“œë¥¼ íì— ë„£ëŠ”ë‹¤.
- ìœ„ ê³¼ì • ë°˜ë³µ
	- ë§Œì•½ ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ì§€ ëª»í–ˆë‹¤ë©´ -> ì‚¬ì´í´ ì¡´ì¬
### 2. DFS ê¸°ë°˜
- DFSë¥¼ íƒìƒ‰í•˜ë©´ì„œ ê° ë…¸ë“œë¥¼ í›„ìœ„ ìˆœíšŒ ë°©ì‹ìœ¼ë¡œ ê¸°ë¡í•œë‹¤.
- íƒìƒ‰ì´ ëë‚˜ë©´ ê¸°ë¡ëœ ë¦¬ìŠ¤íŠ¸ë¥¼ ì—­ìˆœìœ¼ë¡œ ë°˜í™˜í•œë‹¤.

## 5. ì˜ˆì‹œ
```yaml
ğŸ§© ë¬¸ì œ: ëª¨ë“  ì‘ì—…ì„ ëë‚´ê¸° ìœ„í•œ ìˆœì„œë¥¼ êµ¬í•˜ë¼

- ì‘ì—… ìˆ˜: 4ê°œ (1~4ë²ˆ ì‘ì—…)
- ì‘ì—… ìˆœì„œ ì¡°ê±´:
    - 1ë²ˆì„ ëë‚´ì•¼ 2ë²ˆ ê°€ëŠ¥
    - 1ë²ˆì„ ëë‚´ì•¼ 3ë²ˆ ê°€ëŠ¥
    - 2ë²ˆ, 3ë²ˆì„ ëë‚´ì•¼ 4ë²ˆ ê°€ëŠ¥


```
- ì–´ë–¤ ìˆœì„œë¡œ ì‘ì—…í•´ì•¼ í• ê¹Œ?
- 1 -> 2 or 1 -> 3 ì´í›„ (2 or 3) -> 4
- ê°€ëŠ¥í•œ ìˆœì„œê°€ ì—¬ëŸ¬ ê°œë‹¤.
- 4-1ì— ê¸°ì´ˆí•˜ë©´
```text
 1 -> 2
 1 -> 3
 2 -> 4
 3 -> 4

- ì´ˆê¸° ì§„ì… ì°¨ìˆ˜
1: 0
2: 1
3: 1
4: 2

ğŸª£ í: [1]
â¡ï¸ êº¼ë‚¸ë‹¤: 1 â†’ ì •ë‹µì— ì¶”ê°€
â¡ï¸ 2, 3 ì§„ì… ì°¨ìˆ˜ ê°ì†Œ â†’ 0 ë˜ë¯€ë¡œ íì— ì‚½ì…

ğŸª£ í: [2, 3]
â¡ï¸ êº¼ë‚¸ë‹¤: 2 â†’ ì •ë‹µì— ì¶”ê°€
â¡ï¸ 4ì˜ ì§„ì…ì°¨ìˆ˜ 1 â†’ 0 ì•ˆ ë¨


ğŸª£ í: [3]
â¡ï¸ êº¼ë‚¸ë‹¤: 3 â†’ ì •ë‹µì— ì¶”ê°€
â¡ï¸ 4ì˜ ì§„ì…ì°¨ìˆ˜ 0 â†’ í ì‚½ì…


ğŸª£ í: [4]
â¡ï¸ êº¼ë‚¸ë‹¤: 4 â†’ ì •ë‹µì— ì¶”ê°€

âœ”ï¸ ê²°ê³¼: 1 â†’ 2 â†’ 3 â†’ 4 (ë˜ëŠ” 1 â†’ 3 â†’ 2 â†’ 4)
```

1) ì¤„ ì„¸ìš°ê¸°
```kotlin
class TopologicalExample {  
    /**  
     * ğŸ“˜ ë¬¸ì œ: ì¤„ ì„¸ìš°ê¸° (BOJ 2252)    
     *   
     * â¸»  
     *  
     * âœ… ë¬¸ì œ ì„¤ëª…  
     *  
     * Nëª…ì˜ í•™ìƒë“¤ì„ í‚¤ ìˆœì„œëŒ€ë¡œ ì¼ë ¬ë¡œ ì„¸ìš°ë ¤ê³  í•œë‹¤.  
     * Mê°œì˜ í‚¤ ë¹„êµ ê²°ê³¼ê°€ ì£¼ì–´ì§„ë‹¤.  
     * ê° ë¹„êµëŠ” Aê°€ Bë³´ë‹¤ ì•ì— ì„œì•¼ í•œë‹¤ëŠ” ì˜ë¯¸ë‹¤.  
     *    
     * ëª¨ë“  ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í•˜ë‚˜ì˜ ì¤„ ì„¸ìš°ê¸° ê²°ê³¼ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤.  
     *    
     * â¸»  
     *  
     * âœ… ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„: ì •ìˆ˜ N(1 â‰¤ N â‰¤ 32,000), M(1 â‰¤ M â‰¤ 100,000)  
     *  â€¢  ë‹¤ìŒ Mì¤„: A B (Aê°€ Bë³´ë‹¤ ì•ì— ì„œì•¼ í•œë‹¤ëŠ” ì˜ë¯¸)  
     *    
     * â¸»  
     *  
     * âœ… ì¶œë ¥ í˜•ì‹  
     *  â€¢  ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” í•™ìƒë“¤ì˜ ë²ˆí˜¸ë¥¼ ìˆœì„œëŒ€ë¡œ ì¶œë ¥ (ì—¬ëŸ¬ ë‹µì´ ê°€ëŠ¥)  
     *     
     * â¸»  
     *  
     * ğŸ§ª ì…ë ¥ ì˜ˆì‹œ  
     * 3 2  
     * 1 3  
     * 2 3    
     * ğŸ§¾ ì¶œë ¥ ì˜ˆì‹œ  
     * 1 2 3  
     */
     
	@Test  
    fun solution() {  
        val n = 3  
        val edges = listOf(  
            1 to 2,  
            2 to 3,  
        )  
  
        val expected = "1 2 3"  
        assertEquals(expected, topologicalSort(n, edges))  
    }  
  
    fun topologicalSort(element: Int, edges: List<Pair<Int,Int>>):String {  
        val inDegree = IntArray(element + 1) { 0 }  
        val graph = Array(element + 1){ mutableListOf<Int>() }  
  
        for((inElement, outElement) in edges) {  
            inDegree[outElement] ++  
            graph[inElement].add(outElement)  
        }  
  
  
        val queue = ArrayDeque<Int>()  
        for( i in 1 .. element) {  
            if(inDegree[i] == 0) queue.addLast(i)  
        }  
        val builder = mutableListOf<Int>()  
        while(queue.isNotEmpty()) {  
            val node = queue.removeLast()  
            builder.add(node)  
  
            for( next in graph[node]) {  
                inDegree[next] --  
  
                if(inDegree[next] == 0) {  
                    queue.addLast(next)  
                }  
  
            }  
        }  
  
        return if (builder.size == element) {  
            builder.joinToString(" ")  
        } else {  
            "ì‚¬ì´í´ ë°œìƒ"  
        }  
    }  
}
```