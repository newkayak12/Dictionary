# 1. MST?
- Tree: 
	- 사이클이 없다.
	- N개의 노드가 있다면 항상 **N-1**개의 간선을 가진다.
	- 모든 노드가 하나의 연결되어 있다.
	- 자체적으로 독립적인 구조다.
	- 예시 
	> 	A - B - C - D
- Spanning Tree: 
	- 어떤 "주어진 그래프"로부터 뽑아낸 트리 
	- 그 그래프의 모든 정점을 포함
	- 사이클 없이, 모든 정점을 최소 간선으로 연결한다.
	- 즉, 원래 그래프의 부분 집합(간선 일부만 선택)
	- 하나의 그래프에는 여러 개의 스패닝 트리가 존재할 수 있다.
	- 예시
>	  트리의 경우
> 		D ----- E
> 		| \\   / | 
> 		|   C   |
> 		| /   \\ |
> 		D ----- E
> 		
> 	 스패닝 트리
> 		
> 	 D -- A -- B -- C -- E
> 	 	
- MST는 그 중에 간선들의 가중치 합이 가장 작은 트리 

## 2. MST가 필요한 이유
- 네트워크 비용 최소화 문제
- 모든 노드를 연결하면서 비용 최소화하는 문제

## 3. MST 조건 정리

|    조건    | 설명                            |
| :------: | ----------------------------- |
|   연결성    | 모든 정점이 연결되어 있어야 한다.           |
| 사이클이 없다. | 트리는 사이클을 가지지 않는다.             |
|  최소 비용   | 가능한 스패닝 트리 중에서 가장 가중치의 합이 낮다. |

## 4. MST의 성질
1. 정점이 `v` 개라면 간선은 `v - 1`
2. 간선 가중치가 다르다면 MST는 유일하다.
3. MST는 그래프가 **무방향 & 연결 그래프**일 때만 정의된다.

## 5. MST 알고리즘 두 가지
|  알고리즘   | 핵심 아이디어                            | 특징              |
| :-----: | ---------------------------------- | --------------- |
| Kruskal | 간선을 가중치 순으로 정렬한 뒤, 사이클이 생기지 않도록 선택 | UnionFind 사용    |
|  Prim   | 정점 기준으로 연결된 가장 짧은 간선을 탐색하며 확장      | 우선순위 큐 사용(Heap) |

### Kruskal
- MST를 구하는 대표적인 알고리즘
- **간선 중심**으로 작동
- "가장 가중치가 작은 간선부터 선택하되, **사이클을 만들지 않는 선**에서 계속 추가하는 방식"

#### 1. 동작 원리
1. 모든 간선을 가중치 기준으로 정렬
2. 사이클이 생기지 않는 한 MST에 포함
#### 2. 필요 사항
1. 간선 리스트
2. 정렬
3. Union-Find
#### 3. 예시
```
     1
  A-----B
  |   / |
  |  /  |
  | /   |
  C-----D
     4
```

| **간선** | **가중치** |
| ------ | ------- |
| A-B    | 1       |
| A-C    | 2       |
| B-C    | 3       |
| B-D    | 5       |
| C-D    | 4       |

작동 순서:

1. 간선 정렬 → A-B(1), A-C(2), B-C(3), C-D(4), B-D(5)
2. A-B 선택 → MST에 포함
3. A-C 선택 → MST에 포함
4. B-C 선택 → **사이클 생김** → 패스
5. C-D 선택 → MST에 포함
  

MST 결과 간선: A-B, A-C, C-D

#### 4. Union-Find(DisjoinSetUnion)
> 사이클이 생기지 않도록 간선을 추가하기 위해서
> 두 정점이 이미 연결되어 있는지를 빠르게 판단하고, 연결이 안되어 있으면 연결하기 위해서 
> 사용하는 자료 구조

##### find(x)
- x가 속한 집합의 대표 노드를 반환
- 루트 찾기 함수
- 경로 압축(PathCompression)을 사용하면 효율화
```kotlin
fun find(x: Int): Int {
    if (parent[x] != x) parent[x] = find(parent[x]) // 경로 압축
    return parent[x]
}
```

##### union(a,b)
- a, b가 서로 다른 집합이면 -> 하나로 합친다.
- 이미 같은 집합이면 아무것도 하지 않는다.(사이클 방지)
```kotlin
fun union(x: Int, y: Int) {
    val rootX = find(x)
    val rootY = find(y)
    if (rootX != rootY) parent[rootY] = rootX
}
```

##### 전체 예시
```kotlin
class DisjointSetUnion {
	val parent = IntArray(n + 1) { it }
	val rank = IntArray(n + 1) { 1 }
	
	fun find(x: Int): Int {
	    if (parent[x] != x) parent[x] = find(parent[x]) // 경로 압축
	    return parent[x]
	}
	
	fun union(x: Int, y: Int) {
	    val rootX = find(x)
	    val rootY = find(y)
	    if (rootX == rootY) return
	
	    if (rank[rootX] < rank[rootY]) {
	        parent[rootX] = rootY
	    } else {
	        parent[rootY] = rootX
	        if (rank[rootX] == rank[rootY]) rank[rootX]++
	    }
	}
}
```

#### 5. 사용 예시
```kotlin
val edges = mutableListOf<Edge>()
// edges.add(Edge(u, v, weight)) 여러 개 입력

edges.sortBy { it.weight }

var totalCost = 0
var edgeCount = 0

for (edge in edges) {
    if (union(edge.u, edge.v)) {
        totalCost += edge.weight
        edgeCount++
        if (edgeCount == V - 1) break
    }
}
```

#### 6. 기초 문제 예시

