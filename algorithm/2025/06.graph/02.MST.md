# 1. MST?
- Tree: 
	- ì‚¬ì´í´ì´ ì—†ë‹¤.
	- Nê°œì˜ ë…¸ë“œê°€ ìˆë‹¤ë©´ í•­ìƒ **N-1**ê°œì˜ ê°„ì„ ì„ ê°€ì§„ë‹¤.
	- ëª¨ë“  ë…¸ë“œê°€ í•˜ë‚˜ì˜ ì—°ê²°ë˜ì–´ ìˆë‹¤.
	- ìì²´ì ìœ¼ë¡œ ë…ë¦½ì ì¸ êµ¬ì¡°ë‹¤.
	- ì˜ˆì‹œ 
	> 	A - B - C - D
- Spanning Tree: 
	- ì–´ë–¤ "ì£¼ì–´ì§„ ê·¸ë˜í”„"ë¡œë¶€í„° ë½‘ì•„ë‚¸ íŠ¸ë¦¬ 
	- ê·¸ ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ í¬í•¨
	- ì‚¬ì´í´ ì—†ì´, ëª¨ë“  ì •ì ì„ ìµœì†Œ ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•œë‹¤.
	- ì¦‰, ì›ë˜ ê·¸ë˜í”„ì˜ ë¶€ë¶„ ì§‘í•©(ê°„ì„  ì¼ë¶€ë§Œ ì„ íƒ)
	- í•˜ë‚˜ì˜ ê·¸ë˜í”„ì—ëŠ” ì—¬ëŸ¬ ê°œì˜ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.
	- ì˜ˆì‹œ
>	  íŠ¸ë¦¬ì˜ ê²½ìš°
> 		D ----- E
> 		| \\   / | 
> 		|   C   |
> 		| /   \\ |
> 		D ----- E
> 		
> 	 ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬
> 		
> 	 D -- A -- B -- C -- E
> 	 	
- MSTëŠ” ê·¸ ì¤‘ì— ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ í•©ì´ ê°€ì¥ ì‘ì€ íŠ¸ë¦¬ 

## 2. MSTê°€ í•„ìš”í•œ ì´ìœ 
- ë„¤íŠ¸ì›Œí¬ ë¹„ìš© ìµœì†Œí™” ë¬¸ì œ
- ëª¨ë“  ë…¸ë“œë¥¼ ì—°ê²°í•˜ë©´ì„œ ë¹„ìš© ìµœì†Œí™”í•˜ëŠ” ë¬¸ì œ

## 3. MST ì¡°ê±´ ì •ë¦¬

|    ì¡°ê±´    | ì„¤ëª…                            |
| :------: | ----------------------------- |
|   ì—°ê²°ì„±    | ëª¨ë“  ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤.           |
| ì‚¬ì´í´ì´ ì—†ë‹¤. | íŠ¸ë¦¬ëŠ” ì‚¬ì´í´ì„ ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤.             |
|  ìµœì†Œ ë¹„ìš©   | ê°€ëŠ¥í•œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ì¤‘ì—ì„œ ê°€ì¥ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ë‚®ë‹¤. |

## 4. MSTì˜ ì„±ì§ˆ
1. ì •ì ì´ `v` ê°œë¼ë©´ ê°„ì„ ì€ `v - 1`
2. ê°„ì„  ê°€ì¤‘ì¹˜ê°€ ë‹¤ë¥´ë‹¤ë©´ MSTëŠ” ìœ ì¼í•˜ë‹¤.
3. MSTëŠ” ê·¸ë˜í”„ê°€ **ë¬´ë°©í–¥ & ì—°ê²° ê·¸ë˜í”„**ì¼ ë•Œë§Œ ì •ì˜ëœë‹¤.

## 5. MST ì•Œê³ ë¦¬ì¦˜ ë‘ ê°€ì§€
|  ì•Œê³ ë¦¬ì¦˜   | í•µì‹¬ ì•„ì´ë””ì–´                            | íŠ¹ì§•              |
| :-----: | ---------------------------------- | --------------- |
| Kruskal | ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë’¤, ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ ì„ íƒ | UnionFind ì‚¬ìš©    |
|  Prim   | ì •ì  ê¸°ì¤€ìœ¼ë¡œ ì—°ê²°ëœ ê°€ì¥ ì§§ì€ ê°„ì„ ì„ íƒìƒ‰í•˜ë©° í™•ì¥      | ìš°ì„ ìˆœìœ„ í ì‚¬ìš©(Heap) |

### Kruskal
- MSTë¥¼ êµ¬í•˜ëŠ” ëŒ€í‘œì ì¸ ì•Œê³ ë¦¬ì¦˜
- **ê°„ì„  ì¤‘ì‹¬**ìœ¼ë¡œ ì‘ë™
- "ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë¶€í„° ì„ íƒí•˜ë˜, **ì‚¬ì´í´ì„ ë§Œë“¤ì§€ ì•ŠëŠ” ì„ **ì—ì„œ ê³„ì† ì¶”ê°€í•˜ëŠ” ë°©ì‹"

#### 1. ë™ì‘ ì›ë¦¬
1. ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
2. ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•ŠëŠ” í•œ MSTì— í¬í•¨
#### 2. í•„ìš” ì‚¬í•­
1. ê°„ì„  ë¦¬ìŠ¤íŠ¸
2. ì •ë ¬
3. Union-Find
#### 3. ì˜ˆì‹œ
```
     1
  A-----B
  |   / |
  |  /  |
  | /   |
  C-----D
     4
```

| **ê°„ì„ ** | **ê°€ì¤‘ì¹˜** |
| ------ | ------- |
| A-B    | 1       |
| A-C    | 2       |
| B-C    | 3       |
| B-D    | 5       |
| C-D    | 4       |

ì‘ë™ ìˆœì„œ:

1. ê°„ì„  ì •ë ¬ â†’ A-B(1), A-C(2), B-C(3), C-D(4), B-D(5)
2. A-B ì„ íƒ â†’ MSTì— í¬í•¨
3. A-C ì„ íƒ â†’ MSTì— í¬í•¨
4. B-C ì„ íƒ â†’ **ì‚¬ì´í´ ìƒê¹€** â†’ íŒ¨ìŠ¤
5. C-D ì„ íƒ â†’ MSTì— í¬í•¨
  

MST ê²°ê³¼ ê°„ì„ : A-B, A-C, C-D

#### 4. Union-Find(DisjoinSetUnion)
> ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šë„ë¡ ê°„ì„ ì„ ì¶”ê°€í•˜ê¸° ìœ„í•´ì„œ
> ë‘ ì •ì ì´ ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ë¥¼ ë¹ ë¥´ê²Œ íŒë‹¨í•˜ê³ , ì—°ê²°ì´ ì•ˆë˜ì–´ ìˆìœ¼ë©´ ì—°ê²°í•˜ê¸° ìœ„í•´ì„œ 
> ì‚¬ìš©í•˜ëŠ” ìë£Œ êµ¬ì¡°

##### find(x)
- xê°€ ì†í•œ ì§‘í•©ì˜ ëŒ€í‘œ ë…¸ë“œë¥¼ ë°˜í™˜
- ë£¨íŠ¸ ì°¾ê¸° í•¨ìˆ˜
- ê²½ë¡œ ì••ì¶•(PathCompression)ì„ ì‚¬ìš©í•˜ë©´ íš¨ìœ¨í™”
```kotlin
fun find(x: Int): Int {
    if (parent[x] != x) parent[x] = find(parent[x]) // ê²½ë¡œ ì••ì¶•
    return parent[x]
}
```

##### union(a,b)
- a, bê°€ ì„œë¡œ ë‹¤ë¥¸ ì§‘í•©ì´ë©´ -> í•˜ë‚˜ë¡œ í•©ì¹œë‹¤.
- ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠëŠ”ë‹¤.(ì‚¬ì´í´ ë°©ì§€)
```kotlin
fun union(x: Int, y: Int) {
    val rootX = find(x)
    val rootY = find(y)
    if (rootX != rootY) parent[rootY] = rootX
}
```

##### ì „ì²´ ì˜ˆì‹œ
```kotlin
class DisjointSetUnion {
	val parent = IntArray(n + 1) { it }
	val rank = IntArray(n + 1) { 1 }
	
	fun find(x: Int): Int {
	    if (parent[x] != x) parent[x] = find(parent[x]) // ê²½ë¡œ ì••ì¶•
	    return parent[x]
	}
	
	fun union(x: Int, y: Int) {
	    val rootX = find(x)
	    val rootY = find(y)
	    if (rootX == rootY) return
	
	    if (rank[rootX] < rank[rootY]) {
	        parent[rootX] = rootY
	    } else {
	        parent[rootY] = rootX
	        if (rank[rootX] == rank[rootY]) rank[rootX]++
	    }
	}
}
```

#### 5. ì‚¬ìš© ì˜ˆì‹œ
```kotlin
val edges = mutableListOf<Edge>()
// edges.add(Edge(u, v, weight)) ì—¬ëŸ¬ ê°œ ì…ë ¥

edges.sortBy { it.weight }

var totalCost = 0
var edgeCount = 0

for (edge in edges) {
    if (union(edge.u, edge.v)) {
        totalCost += edge.weight
        edgeCount++
        if (edgeCount == V - 1) break
    }
}
```

#### 6. ê¸°ì´ˆ ë¬¸ì œ ì˜ˆì‹œ
1) í¬ë£¨ìŠ¤ì¹¼ ê¸°ì´ˆ ë¬¸ì œ
```kotlin
class KruskalExample {  
    /**  
     * ğŸ§© ë¬¸ì œ: ë„ì‹œ ë¶„í•  ê³„íš (BOJ 1647 ë³€í˜•)  
     *    
     * ë¬¸ì œ ì„¤ëª…  
     *  
     * ì–´ë–¤ ë‚˜ë¼ì—ëŠ” Nê°œì˜ ì§‘ê³¼ Mê°œì˜ ê¸¸ì´ ìˆìŠµë‹ˆë‹¤.  
     * ê¸¸ì€ ì§‘ê³¼ ì§‘ì„ ì—°ê²°í•˜ë©°, ê¸¸ë§ˆë‹¤ ìœ ì§€ë¹„ìš©ì´ ì¡´ì¬í•©ë‹ˆë‹¤.  
     *    
     * ë‹¹ì‹ ì€ ì´ ë§ˆì„ì— ì „ê¸°ë¥¼ ì„¤ì¹˜í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     * í•˜ì§€ë§Œ ëª¨ë“  ì§‘ì— ì „ê¸°ë¥¼ ì„¤ì¹˜í•˜ëŠ” ë¹„ìš©ì„ ìµœì†Œí™”í•˜ê¸° ìœ„í•´,  
     * ë§ˆì„ì„ ë‘ ê°œì˜ ë¶„ë¦¬ëœ ë§ˆì„ë¡œ ë¶„í• í•˜ë ¤ í•©ë‹ˆë‹¤.  
     *    
     * ë‹¨, ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:  
     *  â€¢  ê° ë§ˆì„ ì•ˆì— ìˆëŠ” ëª¨ë“  ì§‘ì€ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.  
     *  â€¢  ë‘ ë§ˆì„ì€ ì„œë¡œ ë¶„ë¦¬ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.  
     *  â€¢  ê¸¸ì„ ìµœì†Œí•œìœ¼ë¡œ ìœ ì§€í•˜ë˜, ë§ˆì„ì„ ë‘˜ë¡œ ë‚˜ëˆ„ì„¸ìš”.  
     *  â€¢  ë§ˆì„ì„ ë‘˜ë¡œ ë‚˜ëˆˆ ë’¤, ë‚¨ì€ ê¸¸ë“¤ì˜ ìœ ì§€ë¹„ ì´í•©ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *     *  ì…ë ¥ í˜•ì‹  
     *  - ì²«ì§¸ ì¤„ì— ì§‘ì˜ ê°œìˆ˜ N (2 â‰¤ N â‰¤ 100,000), ê¸¸ì˜ ê°œìˆ˜ M (1 â‰¤ M â‰¤ 1,000,000)     *  - ë‘˜ì§¸ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ ë‹¤ìŒì´ ì£¼ì–´ì§:  
     *  - A B C â†’ ì§‘ Aì™€ ì§‘ Bë¥¼ ì—°ê²°í•˜ëŠ” ê¸¸ì˜ ìœ ì§€ë¹„ C (1 â‰¤ C â‰¤ 1,000)
     *    
     *  ì¶œë ¥ í˜•ì‹  
     *  ë§ˆì„ì„ ë‘ ê°œë¡œ ë‚˜ëˆ„ì—ˆì„ ë•Œ, ë‚¨ì€ ê¸¸ë“¤ì˜ ìœ ì§€ë¹„ ì´í•©ì˜ ìµœì†Ÿê°’  
     *  
     *   
     *  ì˜ˆì œ ì…ë ¥  
     *  7 12 (ì§‘, ê¸¸)  
     * nodeA, nodeB, ê°€ì¤‘ì¹˜  
     * 1        2       3  
     * 1        3       2     
     * 3        2       1     
     * 2        5       2     
     * 3        4       4     
     * 7        3       6    
     * 5        1       5    
     * 1        6       2     
     * 6        4       1    
     * 6        5       3    
     * 4        5       3     
     * 6        7       4     
     *    
     *  ì˜ˆì œ ì¶œë ¥  
     *  8  
     */  
     
    inner class DisjointSetUnion( size: Int ) {  
        private val parent = IntArray(size + 1){it}  
        private val rank = IntArray(size + 1)  
  
        fun find(x: Int): Int {  
            if (x != parent[x]) {  
                parent[x] = find(parent[x])  
            }  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = find(a)  
            val rootB = find(b)  
            val rankA = rank[rootA]  
            val rankB = rank[rootB]  
  
            if (rootA == rootB) return false  
            if (rankA < rankB) {  
                parent[rootA] = rootB  
            } else if (rankA > rankB) {  
                parent[rootB] = rootA  
            } else {  
                parent[rootB] = rootA  
                rank[rootA]++  
            }  
  
            return true  
        }  
    }  
  
    @Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 3),  
            intArrayOf(1, 3, 2),  
            intArrayOf(3, 2, 1),  
            intArrayOf(2, 5, 2),  
            intArrayOf(3, 4, 4),  
            intArrayOf(7, 3, 6),  
            intArrayOf(5, 1, 5),  
            intArrayOf(1, 6, 2),  
            intArrayOf(6, 4, 1),  
            intArrayOf(6, 5, 3),  
            intArrayOf(4, 5, 3),  
            intArrayOf(6, 7, 4),  
        )  
  
        val expected = 8  
  
        assertEquals(expected, kruskal(table))  
    }  
  
    private fun kruskal(table: Array<IntArray>): Int {  
  
        table.sortBy { it[2] }  
        val count = table.flatMap { intArrayOf(it[0], it[1]).asSequence() }.distinct().count()  
        val unionFind = DisjointSetUnion(count + 1)  
  
        var totalScore = 0;  
        var max = Int.MIN_VALUE  
  
        for((a, b, score) in table) {  
            if(unionFind.union(a, b)){  
                totalScore += score  
                max = maxOf(max, score)  
            }  
        }  
  
        return totalScore - max  
    }  
}
```
2) ë„ì‹œ ë¶„í•  ê³„íš(Kruskal)
```kotlin
class KruskalExample2 {  
    /**  
     *```     
     * ğŸ“˜ ë¬¸ì œ: ë„ì‹œ ë¶„í•  ê³„íš (ë°±ì¤€ 1647 ë³€í˜•)  
     *     
     * ì–´ë–¤ ë‚˜ë¼ì—ëŠ” Nê°œì˜ ì§‘ì´ ìˆë‹¤. ì´ ì§‘ë“¤ì„ ì—°ê²°í•˜ëŠ” Mê°œì˜ ê¸¸ì´ ìˆê³ , ê° ê¸¸ì€ ìœ ì§€ë¹„ê°€ ìˆë‹¤.  
     * ì´ ë‚˜ë¼ì˜ ìˆ˜ë„ëŠ” ë„ˆë¬´ ë„“ì–´ì§€ì§€ ì•Šë„ë¡ ë§ˆì„ì„ ë‘ ê°œë¡œ ë¶„ë¦¬í•˜ë ¤ í•œë‹¤.  
     * ì¡°ê±´ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:  
     *  â€¢  ëª¨ë“  ì§‘ì€ ë‘ ë§ˆì„ ì¤‘ í•˜ë‚˜ì— í¬í•¨ë˜ì–´ì•¼ í•œë‹¤.  
     *  â€¢  ê° ë§ˆì„ ì•ˆì— ìˆëŠ” ì§‘ë“¤ì€ ëª¨ë‘ ì„œë¡œ ì—°ê²°ë˜ì–´ì•¼ í•œë‹¤.  
     *  â€¢  ë§ˆì„ ê°„ì—ëŠ” ê¸¸ì´ ì—†ì–´ì•¼ í•œë‹¤.  
     *  â€¢  ë‘ ë§ˆì„ë¡œ ë‚˜ëˆ„ë˜, ìœ ì§€ë¹„ì˜ ì´í•©ì´ ìµœì†Œê°€ ë˜ì–´ì•¼ í•œë‹¤.  
     *     
     * ğŸ§¾ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²« ì¤„ì— ì§‘ì˜ ìˆ˜ N, ê¸¸ì˜ ìˆ˜ Mì´ ì£¼ì–´ì§„ë‹¤. (2 â‰¤ N â‰¤ 100,000, 1 â‰¤ M â‰¤ 1,000,000)  
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ A B Cê°€ ì£¼ì–´ì§„ë‹¤.  
     * Aë²ˆ ì§‘ê³¼ Bë²ˆ ì§‘ ì‚¬ì´ì— ìœ ì§€ë¹„ê°€ Cì¸ ê¸¸ì´ ì¡´ì¬í•œë‹¤. (1 â‰¤ C â‰¤ 1,000)  
     *     
     * ğŸ§¾ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ë‘ ë§ˆì„ë¡œ ë‚˜ëˆŒ ë•Œì˜ ìµœì†Œ ìœ ì§€ë¹„ ì´í•©ì„ ì¶œë ¥í•œë‹¤.  
     *     
     * â¸»  
     *  
     * ì˜ˆì œ ì…ë ¥  
     * 7 12  
     * 1 2 3     
     * 1 3 2     
     * 3 2 1     
     * 2 5 2     
     * 3 4 4     
     * 7 3 6     
     * 5 1 5     
     * 1 6 2    
     * 6 4 1     
     * 6 5 3     
     * 4 5 3     
     * 6 7 4     
     *     
     * ì˜ˆì œ ì¶œë ¥  
     * 8  
     * ```
     * */  
 
    inner class DisjointSetUnion(size: Int) {  
        private val parent = IntArray(size + 1) { it }  
        private val rank = IntArray(size + 1)  
  
        fun find(x: Int): Int {  
            if (x != parent[x]) {  
                parent[x] = find(parent[x])  
            }  
  
            return parent[x]  
        }  
  
        fun union(a: Int, b: Int): Boolean {  
            val rootA = find(a)  
            val rootB = find(b)  
            val rankA = rank[rootA]  
            val rankB = rank[rootB]  
  
            if (rootA == rootB) return false  
  
  
            if (rankA < rankB) {  
                parent[rootA] = rootB  
            } else if (rankA > rankB) {  
                parent[rootB] = rootA  
            } else {  
                parent[rootB] = rootA  
                rank[rootA]++  
            }  
  
            return true  
        }  
    }  
  
    @Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(1, 2, 3),  
            intArrayOf(1, 3, 2),  
            intArrayOf(3, 2, 1),  
            intArrayOf(2, 5, 2),  
            intArrayOf(3, 4, 4),  
            intArrayOf(7, 3, 6),  
            intArrayOf(5, 1, 5),  
            intArrayOf(1, 6, 2),  
            intArrayOf(6, 4, 1),  
            intArrayOf(6, 5, 3),  
            intArrayOf(4, 5, 3),  
            intArrayOf(6, 7, 4),  
        )  
        val expected = 8  
  
        assertEquals(expected, kruskal(table))  
    }  
  
    private fun kruskal(table: Array<IntArray>): Int {  
        val count = table.flatMap { intArrayOf(it[0], it[1]).asSequence() }.distinct().count()  
        table.sortBy { it[2] }  
  
        val unionFind = DisjointSetUnion(count)  
  
        var totalScore = 0  
        var max = Int.MIN_VALUE  
  
        for ((a, b, score) in table) {  
            if( unionFind.union(a, b)) {  
                totalScore += score  
                max = maxOf(score, max)  
            }  
        }  
  
        return totalScore - max  
    }  
}
```