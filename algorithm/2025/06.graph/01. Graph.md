
### 1. 그래프
- node, edge로 구성된 구조
	- node(vertex) : 그래프에서 대상
	- edge: 정점 간의 연결

### 2. 그래프 종류
1. Directed Graph: 간선에 방향이 있음
2. Undirected Graph: 양방향 간선
3. Weighted Graph: 간선마다 비용이나 거리 등의 숫자 정보가 있다.
4. Unweighted Graph: 간선에 별도 숫자가 없다.

### 3. 그래프 표현 방식
1. Adjacency List
	1. 각 정점에 연결된 노드들을 리스트로 저장
	2. 공간 효율이 좋고, 연결된 노드만 확인 가능
	3. 일반적으로 많이 사용
2. Adjacency Matrix
	1. 정점 개수 만큼 2차원 매열로 표현
	2. 연결 여부를 빠르게 확인할 수 있으나, 메모리 사용이 많음
	3. 노드가 많을수록 비효율적

### 4. DFS(Depth-First Search)
- 깊이 우선 탐색
- 한 노드에서 가능한 한 깊에 들어감
- 더 이상 갈 수 없을 때만 되돌아가면서(backtracking) 다른 경로 탐색
- 보통 재귀 호출 혹은 스택으로 구현
- 미로 탐색, 조합 탐색, 경로 존재 확인에 사용
	- 방문 순서보다 깊이
	- 경로가 다양하거나, 전부 확인이 필요한 경우

#### 핵심 아이디어
- 한 방향으로 갈 수 있을 만큼 쭉 들어갔다가, 더 이상 갈 수 없으면 되돌아와서 다른 방향을 탐색하는 방식

#### 구현

- 재귀 기준
	1. 현재 노드 방문 처리
	2. 현재 노드에서 연결된 다른 노드 중 아직 방문하지 않은 곳이 있으면 다시 재귀  호출
	3. 이 과정을 반복하여 깊이 탐색
	4. 모든 노드가 방문되면 탐색 종료
- 필요한 구성 요소
	1. 그래프
	2. 방문 여부 배열
	3. DFS 함수
```kotlin
/**
 * ### **📌 설명**
 *
 *	- node: 현재 방문 중인 노드
 *	- graph: 인접 리스트 형태로 저장된 그래프
 *	- visited: 방문 여부를 저장하는 배열
 *    → 이 함수는 node부터 시작해서, **연결된 모든 노드를 깊이 우선적으로 방문**합니다.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // 인접 노드를 넣을 때, 순서 역순 주의
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- 너비 우선 탐색
- 한 노드에서 가까운 노드부터 탐색
- 보통 큐를 사용해서 구현
- 최단 거리를 구할 때 많이 사용
	- 방문 순서가 거리 중심
	- 최단 경로 문제에 적합

#### 핵심 아이디어
- 현재 노드에서 가까운 노드부터 먼저 탐색하고 그 다음 가까운 노드의 이웃들을 탐색해내가는 방식

#### 구현 
- 과정 
	1. 시작 노드를 큐에 넣고 방문 처리
	2.  큐에서 노드를 꺼내고 해당 노드와 연결된 노드들 중 아직 방문하지 않은 노드들을 큐에 넣음
	3. 큐가 빌 때까지 위의 과정을 반복
- 필요한 구성 요소 
	- 그래프
	- 방문 배열
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```

### DFS/BFS
0) 순회 확인하기
```kotlin
package renewal.graph  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.concurrent.LinkedBlockingQueue  
  
class Traverse {  
    /**  
     * 🧩 문제 2. DFS와 BFS 순서 출력  
     *  
     * 설명  
     *  
     * 하나의 무방향 그래프가 주어졌을 때,  
     * 특정한 정점에서 DFS와 BFS를 수행한 결과의 노드 방문 순서를 각각 출력하세요.  
     * 단, 방문할 수 있는 노드가 여러 개인 경우, 정점 번호가 작은 것부터 먼저 방문합니다.  
     *  
     * ⸻  
     *  
     * 입력  
     *  •  첫 줄에 정점 수 N, 간선 수 M, 시작 정점 V가 주어집니다.  
     *  •  다음 M개의 줄에는 간선 정보 u v가 주어집니다.  
     * (u와 v는 양방향으로 연결됨)  
     *   
     * 예시 입력:  
     * 4 5 1   
     *    
     * 1 2   
     * 1 3     
     * 1 4    
     * 2 4    
     * 3 4    
     *     
     * 출력  
     *  •  첫 줄: DFS 방문 순서  
     *  •  둘째 줄: BFS 방문 순서  
     *  예시 출력:  
     * 1 2 4 3    
     * 1 2 3 4    
     * */  
      
    /**
     * 기본 사이즈  
     */  
    @Test  
    fun solution1() {  
        val vertex = 4  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(1, 4),  
            intArrayOf(2, 4),  
            intArrayOf(3, 4),  
        )  
  
        val dfsExpected = "1 2 4 3"  
        val bfsExpected = "1 2 3 4"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * 더 큰 사이즈  
     */  
    @Test  
    fun solution2() {  
        /**  
         * 정점 수: 10  
         * 간선 수: 9  
         * 시작 정점: 1  
         * 간선 목록:  
         * 1 2        
         * 1 3       
         * 2 4       
         * 2 5       
         * 5 6        
         * 3 7       
         * 3 8        
         * 8 9        
         * 9 10         
         *         
         * 시각화  
         *          1  
         *        /   \         
         *       2     3      
         *      / \     \       
         *     4   5     8      
         *          \     \       
         *           6     9     
         *                  \       
         *                  10    
         * */
        
        val vertex = 10  
        val edge = 9  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(2, 4),  
            intArrayOf(2, 5),  
            intArrayOf(5, 6),  
            intArrayOf(3, 7),  
            intArrayOf(3, 8),  
            intArrayOf(8, 9),  
            intArrayOf(9, 10),  
        )  
  
        val dfsExpected = "1 2 4 5 6 3 7 8 9 10"  
        val bfsExpected = "1 2 3 4 5 7 8 6 9 10"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * 비연결 그래프  
     */  
    @Test  
    fun solution3() {  
        val vertex = 8  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(4, 5),  
            intArrayOf(6, 7),  
            intArrayOf(7, 8),  
        )  
  
        val dfsExpected = "1 2 3"  
        val bfsExpected = "1 2 3"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    private fun createGraph(vertex: Int, table: Array<IntArray>): Array<MutableList<Int>> {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table.sortedBy { it[1] }) {  
            val u = element.first()  
            val v = element.last()  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        for (adj in graph) {  
            adj.sort()  
        }  
  
        return graph  
    }  
  
    private fun createVisit(vertex: Int) = BooleanArray(vertex + 1)  
  
    private fun dfsUseStack(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val stack = ArrayDeque<Int>()  
        val builder = StringBuilder()  
        stack.add(start)  
  
        while (stack.isNotEmpty()) {  
            val now = stack.removeLast()  
            if(visited[now]) continue  
  
            visited[now] = true  
            builder.append("$now ")  
  
            for (next in graph[now].reversed()) {  
                if (!visited[next]) {  
                    stack.addLast(next)  
                }  
            }  
        }  
  
        return builder.toString().trim()  
    }  
  
    private fun dfsUseRecursive(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        recursive(start, graph, visited, builder)  
  
        return builder.toString().trim()  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray, builder: StringBuilder) {  
        if (visited[node]) return  
  
        visited[node] = true  
        builder.append("$node ")  
  
        for (next in graph[node]) {  
            recursive(next, graph, visited, builder)  
        }  
    }  
  
    private fun bfsUseQueue(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        val queue = LinkedBlockingQueue<Int>()  
        queue.add(start)  
  
        while(queue.isNotEmpty()) {  
            val now = queue.poll()  
  
            if(visited[now]) continue  
            builder.append("$now ")  
            visited[now] = true  
  
            for(next in graph[now]) {  
                queue.add(next)  
            }  
        }  
  
  
        return builder.toString().trim()  
    }  
}
```

### DFS 예시 문제
1) 연결성 확인
```kotlin
class Connectivity {  
    /**  
     * 문제 1. 연결 요소의 개수  
     *  
     * 설명  
     *  
     * 하나의 무방향 그래프가 주어졌을 때, 이 그래프에서 연결 요소가 몇 개인지 구하세요.  
     * 연결 요소란, 노드들끼리 서로 도달 가능한 그룹을 말합니다.  
     *    
     * 입력  
     *  •  첫 줄에 정점의 개수 N (1 ≤ N ≤ 1,000)과 간선의 개수 M (0 ≤ M ≤ N×(N-1)/2)이 주어집니다.  
     *  •  다음 줄부터 M개의 줄에 걸쳐 두 정점 u, v가 주어집니다. 이는 정점 u와 v가 연결되어 있다는 의미입니다.  
     *    
     * 출력  
     *  •  연결 요소의 개수를 한 줄에 출력하세요.  
     *     
     * 예시 입력  
     * 6 5  
     *    
     * 1 2     
     * 2 5    
     * 5 1     
     * 3 4     
     * 4 6    
     *    
     * 예시 출력  
     * 2  //(1,2,5) (3,4,6) -> 두 덩어리 
     *    
     *     
     * 1. 정점  
     * [1, 2, 3, 4, 5, 6]  
     * 2. 간선  
     * [(1,2), (2,5), (5,1), (3,4), (4,6)]  
     *    
     * 3. 방법?  
     * 1. DFS/BFS -> DFS (모든 노드를 돌면서 확인)  
     *     
     * 2. DisjointSetUnion
     */  
    @Test  
    fun solution() {  
        val vertex = 6  
        val edge = 5  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 5),  
            intArrayOf(5, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 6),  
        )  
        val expected = 2  
        assertEquals(expected, useStack(vertex, edge, table))  
        assertEquals(expected, useRecursive(vertex, edge, table))  
        assertEquals(expected, useDisjointSetUnion(vertex, edge, table))
    }  
  
    private fun useStack(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val graph = Array(vertex + 1) { mutableListOf<Int>() }  
	    for (element in table) {  
	        val u = element[0]  
	        val v = element[1]  
	  
	        graph[u].add(v)  
	        graph[v].add(u)  
	    }  
	  
	    val stack = ArrayDeque<Int>()  
	    val visited = BooleanArray(vertex + 1)  
	    var count = 0  
	  
	  
	    for (i in 1..vertex) {  
	        if (!visited[i]) {  
	            stack.addLast(i)  
	            visited[i] = true  
	            count += 1  
	        }  
	  
	        while (stack.isNotEmpty()) {  
	            val node = stack.removeLast()  
	            for (next in graph[node].reversed()) {  
	                if (!visited[next]) {  
	                    stack.addLast(next)  
	                    visited[next] = true  
	                }  
	            }  
	        }  
	    }  
	  
	    return count  
	}  
  
    private fun useRecursive(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
           if(!visited[i]) {  
               count ++  
               recursive(i, graph, visited)  
           }  
        }  
  
        return count  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {  
        visited[node] = true  
  
        for(next in graph[node].reversed()) {  
            if(!visited[next]) {  
                recursive(next, graph, visited)  
            }  
        }  
    }  
   
	private fun useDisjointSetUnion(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex + 1)  
	    for( (a,b) in table) { dsu.union(a,b) }  
	  
	  
	    val rootSet = mutableSetOf<Int>()  
	    for ( node in 1 .. vertex) {  
	        rootSet.add(dsu.find(node))  
	    }  
	  
	    return rootSet.size  
	}  
	  
	inner class DisjointSetUnion(size: Int) {  
	    private val parents = IntArray(size) { it }  
	    private val ranking = IntArray(size) { 0 }  
	  
	  
	    fun find(x: Int): Int {  
	        if (x != parents[x]) {  
	            parents[x] = find(parents[x])  
	        }  
	        return parents[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if( rootA > rootB ) {  
	            parents[rootB] = rootA  
	        }  
	        else if( rootA < rootB) {  
	            parents[rootA] = rootB  
	        }  
	        else {  
	            parents[rootB] = rootA  
	            ranking[rootA] ++  
	        }  
	  
	        return true  
	    }  
	}
}
```

### BFS 예시 문제
3) 숨바꼭질
```kotlin
class HideAndSeek {  
    /**  
     * 🧩 문제 3. 숨바꼭질 (최단 거리 탐색)  
     *     
     * 설명  
     *  
     * 수빈이는 현재 위치 N에 있고, 동생은 위치 K에 있다.  
     * 수빈이는 걷거나 순간이동할 수 있다.  
     *  •  걷는 경우: X - 1 또는 X + 1 (1초 소요)  
     *  •  순간이동: 2 * X (1초 소요)  
     *     * 수빈이가 동생을 찾을 수 있는 가장 빠른 시간을 구하세요.  
     *     * ⸻  
     *  
     * 입력  
     *  •  첫 줄에 수빈이의 위치 N과 동생의 위치 K가 주어진다. (0 ≤ N, K ≤ 100,000)  
     *     * 출력  
     *  •  수빈이가 동생을 찾을 수 있는 최소 시간(초)을 출력하세요.  
     *     * ⸻  
     *  
     * 예시 입력 1    
     * 5 17    
     * 예시 출력 1  
     * 4    
     * 5 → 10 → 9 → 18 → 17 (총 4초)  
     */  
    @Test  
    fun solution() {  
        val start = 5  
        val end = 17  
  
        val expected = 4  
  
  
        assertEquals(expected, bfs(start, end))  
    }  
  
    private fun bfs(start: Int, end: Int): Int {  
        val queue = LinkedBlockingQueue<Int>()  
        val visited = BooleanArray(100_001)  
        val distance = IntArray(100_001)  
        queue.add(start)  
        visited[start] = true  
  
  
  
  
        while (queue.isNotEmpty()) {  
            val now = queue.poll()  
            if (end == now) return distance[now]  
            val direction = listOf(now - 1, now + 1, now * 2)  
  
            for (next in direction) {  
                if(next in 0 .. 100_000 && !visited[next]) {  
                    queue.add(next)  
                    distance[next] = distance[now] + 1  
                    visited[next] = true  
                }  
            }  
  
        }  
  
  
        return -1  
    }  

	private fun bfsNoVisited(start: Int, end: Int): Int {  
	    val queue = LinkedBlockingQueue<Int>()  
	    val distance = IntArray(100_001){-1}  
	    queue.add(start)  
	    distance[start] = 0  
	  
	  
	  
	  
	    while (queue.isNotEmpty()) {  
	        val now = queue.poll()  
	        if (end == now) return distance[now]  
	        val direction = listOf(now - 1, now + 1, now * 2)  
	  
	        for (next in direction) {  
	            if(next in 0 .. 100_000 && distance[next] == -1) {  
	                queue.add(next)  
	                distance[next] = distance[now] + 1  
	            }  
	        }  
	  
	    }  
	  
	  
	    return -1  
	}
}
```

### 6. DFS/BFS의 그래프 형태에 따른 동작 차이
1) 트리(cycle 없는 트리)
	- DFS: 루트에서 리프까지 경로를 모두 탐색한다. 백트래킹 문제에 적합하다.
	- BFS: 같은 레벨 노드 순차 탐색. 레벨 기반 문제에 적합하다.(최소 거리, 최소 횟수)
2) 사이클이 있는 일반 그래프
	- 방문 여부 체크 -> 안 하면 무한 루프
	- DFS: `visited[node] = true`  진입 시점에
	- BFS: `visited[node] = true`  큐에 넣는 시점
3) 응용 구조
	1) DFS
		1) 백트래킹 탐색
		2) 부분 집합 생성
		3) 그래프 탐색(연결 요쇼, 사이클 탐지)
		4) 깊이 기반 탐색
	2) BFS
		1) 최단거리(가중치 없는)
		2) 최소 횟수 이동(숨바꼭질)
		3) 레벨 탐색
		4) 최단 거리 복원 
4) 탐색 순서
	- 방문할 수 있는 노드가 여러 개인 경우
		- 작은 번호 먼저 탐색 -> 정렬
		- DFS: `graph[node].sort()` 후 `reversed()`로 stack 사용
		- BFS: `graph[node].sort()` 후 큐에 추가