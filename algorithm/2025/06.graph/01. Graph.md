
### 1. ê·¸ë˜í”„
- node, edgeë¡œ êµ¬ì„±ëœ êµ¬ì¡°
	- node(vertex) : ê·¸ë˜í”„ì—ì„œ ëŒ€ìƒ
	- edge: ì •ì  ê°„ì˜ ì—°ê²°

### 2. ê·¸ë˜í”„ ì¢…ë¥˜
1. Directed Graph: ê°„ì„ ì— ë°©í–¥ì´ ìˆìŒ
2. Undirected Graph: ì–‘ë°©í–¥ ê°„ì„ 
3. Weighted Graph: ê°„ì„ ë§ˆë‹¤ ë¹„ìš©ì´ë‚˜ ê±°ë¦¬ ë“±ì˜ ìˆ«ì ì •ë³´ê°€ ìˆë‹¤.
4. Unweighted Graph: ê°„ì„ ì— ë³„ë„ ìˆ«ìê°€ ì—†ë‹¤.

### 3. ê·¸ë˜í”„ í‘œí˜„ ë°©ì‹
1. Adjacency List
	1. ê° ì •ì ì— ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
	2. ê³µê°„ íš¨ìœ¨ì´ ì¢‹ê³ , ì—°ê²°ëœ ë…¸ë“œë§Œ í™•ì¸ ê°€ëŠ¥
	3. ì¼ë°˜ì ìœ¼ë¡œ ë§ì´ ì‚¬ìš©
2. Adjacency Matrix
	1. ì •ì  ê°œìˆ˜ ë§Œí¼ 2ì°¨ì› ë§¤ì—´ë¡œ í‘œí˜„
	2. ì—°ê²° ì—¬ë¶€ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆìœ¼ë‚˜, ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ë§ìŒ
	3. ë…¸ë“œê°€ ë§ì„ìˆ˜ë¡ ë¹„íš¨ìœ¨ì 

### 4. DFS(Depth-First Search)
- ê¹Šì´ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ëŠ¥í•œ í•œ ê¹Šì— ë“¤ì–´ê°
- ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ì„ ë•Œë§Œ ë˜ëŒì•„ê°€ë©´ì„œ(backtracking) ë‹¤ë¥¸ ê²½ë¡œ íƒìƒ‰
- ë³´í†µ ì¬ê·€ í˜¸ì¶œ í˜¹ì€ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„
- ë¯¸ë¡œ íƒìƒ‰, ì¡°í•© íƒìƒ‰, ê²½ë¡œ ì¡´ì¬ í™•ì¸ì— ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œë³´ë‹¤ ê¹Šì´
	- ê²½ë¡œê°€ ë‹¤ì–‘í•˜ê±°ë‚˜, ì „ë¶€ í™•ì¸ì´ í•„ìš”í•œ ê²½ìš°

#### í•µì‹¬ ì•„ì´ë””ì–´
- í•œ ë°©í–¥ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆì„ ë§Œí¼ ì­‰ ë“¤ì–´ê°”ë‹¤ê°€, ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ìœ¼ë©´ ë˜ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ë°©í–¥ì„ íƒìƒ‰í•˜ëŠ” ë°©ì‹

#### êµ¬í˜„

- ì¬ê·€ ê¸°ì¤€
	1. í˜„ì¬ ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
	2. í˜„ì¬ ë…¸ë“œì—ì„œ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ì´ ìˆìœ¼ë©´ ë‹¤ì‹œ ì¬ê·€  í˜¸ì¶œ
	3. ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ê¹Šì´ íƒìƒ‰
	4. ëª¨ë“  ë…¸ë“œê°€ ë°©ë¬¸ë˜ë©´ íƒìƒ‰ ì¢…ë£Œ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ
	1. ê·¸ë˜í”„
	2. ë°©ë¬¸ ì—¬ë¶€ ë°°ì—´
	3. DFS í•¨ìˆ˜
```kotlin
/**
 * ### **ğŸ“Œ ì„¤ëª…**
 *
 *	- node: í˜„ì¬ ë°©ë¬¸ ì¤‘ì¸ ë…¸ë“œ
 *	- graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì €ì¥ëœ ê·¸ë˜í”„
 *	- visited: ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
 *    â†’ ì´ í•¨ìˆ˜ëŠ” nodeë¶€í„° ì‹œì‘í•´ì„œ, **ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œë¥¼ ê¹Šì´ ìš°ì„ ì ìœ¼ë¡œ ë°©ë¬¸**í•©ë‹ˆë‹¤.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // ì¸ì ‘ ë…¸ë“œë¥¼ ë„£ì„ ë•Œ, ìˆœì„œ ì—­ìˆœ ì£¼ì˜
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- ë„ˆë¹„ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰
- ë³´í†µ íë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„
- ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•  ë•Œ ë§ì´ ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œê°€ ê±°ë¦¬ ì¤‘ì‹¬
	- ìµœë‹¨ ê²½ë¡œ ë¬¸ì œì— ì í•©

#### í•µì‹¬ ì•„ì´ë””ì–´
- í˜„ì¬ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ë¨¼ì € íƒìƒ‰í•˜ê³  ê·¸ ë‹¤ìŒ ê°€ê¹Œìš´ ë…¸ë“œì˜ ì´ì›ƒë“¤ì„ íƒìƒ‰í•´ë‚´ê°€ëŠ” ë°©ì‹

#### êµ¬í˜„ 
- ê³¼ì • 
	1. ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
	2.  íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ê³  í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œë“¤ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ì„ íì— ë„£ìŒ
	3. íê°€ ë¹Œ ë•Œê¹Œì§€ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ 
	- ê·¸ë˜í”„
	- ë°©ë¬¸ ë°°ì—´
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```

### DFS/BFS
0) ìˆœíšŒ í™•ì¸í•˜ê¸°
```kotlin
package renewal.graph  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.concurrent.LinkedBlockingQueue  
  
class Traverse {  
    /**  
     * ğŸ§© ë¬¸ì œ 2. DFSì™€ BFS ìˆœì„œ ì¶œë ¥  
     *  
     * ì„¤ëª…  
     *  
     * í•˜ë‚˜ì˜ ë¬´ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * íŠ¹ì •í•œ ì •ì ì—ì„œ DFSì™€ BFSë¥¼ ìˆ˜í–‰í•œ ê²°ê³¼ì˜ ë…¸ë“œ ë°©ë¬¸ ìˆœì„œë¥¼ ê°ê° ì¶œë ¥í•˜ì„¸ìš”.  
     * ë‹¨, ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°, ì •ì  ë²ˆí˜¸ê°€ ì‘ì€ ê²ƒë¶€í„° ë¨¼ì € ë°©ë¬¸í•©ë‹ˆë‹¤.  
     *  
     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì •ì  ìˆ˜ N, ê°„ì„  ìˆ˜ M, ì‹œì‘ ì •ì  Vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ê°„ì„  ì •ë³´ u vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * (uì™€ vëŠ” ì–‘ë°©í–¥ìœ¼ë¡œ ì—°ê²°ë¨)  
     *   
     * ì˜ˆì‹œ ì…ë ¥:  
     * 4 5 1   
     *    
     * 1 2   
     * 1 3     
     * 1 4    
     * 2 4    
     * 3 4    
     *     
     * ì¶œë ¥  
     *  â€¢  ì²« ì¤„: DFS ë°©ë¬¸ ìˆœì„œ  
     *  â€¢  ë‘˜ì§¸ ì¤„: BFS ë°©ë¬¸ ìˆœì„œ  
     *  ì˜ˆì‹œ ì¶œë ¥:  
     * 1 2 4 3    
     * 1 2 3 4    
     * */  
      
    /**
     * ê¸°ë³¸ ì‚¬ì´ì¦ˆ  
     */  
    @Test  
    fun solution1() {  
        val vertex = 4  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(1, 4),  
            intArrayOf(2, 4),  
            intArrayOf(3, 4),  
        )  
  
        val dfsExpected = "1 2 4 3"  
        val bfsExpected = "1 2 3 4"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * ë” í° ì‚¬ì´ì¦ˆ  
     */  
    @Test  
    fun solution2() {  
        /**  
         * ì •ì  ìˆ˜: 10  
         * ê°„ì„  ìˆ˜: 9  
         * ì‹œì‘ ì •ì : 1  
         * ê°„ì„  ëª©ë¡:  
         * 1 2        
         * 1 3       
         * 2 4       
         * 2 5       
         * 5 6        
         * 3 7       
         * 3 8        
         * 8 9        
         * 9 10         
         *         
         * ì‹œê°í™”  
         *          1  
         *        /   \         
         *       2     3      
         *      / \     \       
         *     4   5     8      
         *          \     \       
         *           6     9     
         *                  \       
         *                  10    
         * */
        
        val vertex = 10  
        val edge = 9  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(2, 4),  
            intArrayOf(2, 5),  
            intArrayOf(5, 6),  
            intArrayOf(3, 7),  
            intArrayOf(3, 8),  
            intArrayOf(8, 9),  
            intArrayOf(9, 10),  
        )  
  
        val dfsExpected = "1 2 4 5 6 3 7 8 9 10"  
        val bfsExpected = "1 2 3 4 5 7 8 6 9 10"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * ë¹„ì—°ê²° ê·¸ë˜í”„  
     */  
    @Test  
    fun solution3() {  
        val vertex = 8  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(4, 5),  
            intArrayOf(6, 7),  
            intArrayOf(7, 8),  
        )  
  
        val dfsExpected = "1 2 3"  
        val bfsExpected = "1 2 3"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    private fun createGraph(vertex: Int, table: Array<IntArray>): Array<MutableList<Int>> {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table.sortedBy { it[1] }) {  
            val u = element.first()  
            val v = element.last()  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        for (adj in graph) {  
            adj.sort()  
        }  
  
        return graph  
    }  
  
    private fun createVisit(vertex: Int) = BooleanArray(vertex + 1)  
  
    private fun dfsUseStack(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val stack = ArrayDeque<Int>()  
        val builder = StringBuilder()  
        stack.add(start)  
  
        while (stack.isNotEmpty()) {  
            val now = stack.removeLast()  
            if(visited[now]) continue  
  
            visited[now] = true  
            builder.append("$now ")  
  
            for (next in graph[now].reversed()) {  
                if (!visited[next]) {  
                    stack.addLast(next)  
                }  
            }  
        }  
  
        return builder.toString().trim()  
    }  
  
    private fun dfsUseRecursive(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        recursive(start, graph, visited, builder)  
  
        return builder.toString().trim()  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray, builder: StringBuilder) {  
        if (visited[node]) return  
  
        visited[node] = true  
        builder.append("$node ")  
  
        for (next in graph[node]) {  
            recursive(next, graph, visited, builder)  
        }  
    }  
  
    private fun bfsUseQueue(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        val queue = LinkedBlockingQueue<Int>()  
        queue.add(start)  
  
        while(queue.isNotEmpty()) {  
            val now = queue.poll()  
  
            if(visited[now]) continue  
            builder.append("$now ")  
            visited[now] = true  
  
            for(next in graph[now]) {  
                queue.add(next)  
            }  
        }  
  
  
        return builder.toString().trim()  
    }  
}
```

### DFS ì˜ˆì‹œ ë¬¸ì œ
1) ì—°ê²°ì„± í™•ì¸
```kotlin
class Connectivity {  
    /**  
     * ë¬¸ì œ 1. ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜  
     *  
     * ì„¤ëª…  
     *  
     * í•˜ë‚˜ì˜ ë¬´ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ë˜í”„ì—ì„œ ì—°ê²° ìš”ì†Œê°€ ëª‡ ê°œì¸ì§€ êµ¬í•˜ì„¸ìš”.  
     * ì—°ê²° ìš”ì†Œë€, ë…¸ë“œë“¤ë¼ë¦¬ ì„œë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ê·¸ë£¹ì„ ë§í•©ë‹ˆë‹¤.  
     *    
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì •ì ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 1,000)ê³¼ ê°„ì„ ì˜ ê°œìˆ˜ M (0 â‰¤ M â‰¤ NÃ—(N-1)/2)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ ë‘ ì •ì  u, vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ëŠ” ì •ì  uì™€ vê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.  
     *    
     * ì¶œë ¥  
     *  â€¢  ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ í•œ ì¤„ì— ì¶œë ¥í•˜ì„¸ìš”.  
     *     
     * ì˜ˆì‹œ ì…ë ¥  
     * 6 5  
     *    
     * 1 2     
     * 2 5    
     * 5 1     
     * 3 4     
     * 4 6    
     *    
     * ì˜ˆì‹œ ì¶œë ¥  
     * 2  //(1,2,5) (3,4,6) -> ë‘ ë©ì–´ë¦¬ 
     *    
     *     
     * 1. ì •ì   
     * [1, 2, 3, 4, 5, 6]  
     * 2. ê°„ì„   
     * [(1,2), (2,5), (5,1), (3,4), (4,6)]  
     *    
     * 3. ë°©ë²•?  
     * 1. DFS/BFS -> DFS (ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ í™•ì¸)  
     *     
     * 2. DisjointSetUnion
     */  
    @Test  
    fun solution() {  
        val vertex = 6  
        val edge = 5  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 5),  
            intArrayOf(5, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 6),  
        )  
        val expected = 2  
        assertEquals(expected, useStack(vertex, edge, table))  
        assertEquals(expected, useRecursive(vertex, edge, table))  
        assertEquals(expected, useDisjointSetUnion(vertex, edge, table))
    }  
  
    private fun useStack(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val graph = Array(vertex + 1) { mutableListOf<Int>() }  
	    for (element in table) {  
	        val u = element[0]  
	        val v = element[1]  
	  
	        graph[u].add(v)  
	        graph[v].add(u)  
	    }  
	  
	    val stack = ArrayDeque<Int>()  
	    val visited = BooleanArray(vertex + 1)  
	    var count = 0  
	  
	  
	    for (i in 1..vertex) {  
	        if (!visited[i]) {  
	            stack.addLast(i)  
	            visited[i] = true  
	            count += 1  
	        }  
	  
	        while (stack.isNotEmpty()) {  
	            val node = stack.removeLast()  
	            for (next in graph[node].reversed()) {  
	                if (!visited[next]) {  
	                    stack.addLast(next)  
	                    visited[next] = true  
	                }  
	            }  
	        }  
	    }  
	  
	    return count  
	}  
  
    private fun useRecursive(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
           if(!visited[i]) {  
               count ++  
               recursive(i, graph, visited)  
           }  
        }  
  
        return count  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {  
        visited[node] = true  
  
        for(next in graph[node].reversed()) {  
            if(!visited[next]) {  
                recursive(next, graph, visited)  
            }  
        }  
    }  
   
	private fun useDisjointSetUnion(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex + 1)  
	    for( (a,b) in table) { dsu.union(a,b) }  
	  
	  
	    val rootSet = mutableSetOf<Int>()  
	    for ( node in 1 .. vertex) {  
	        rootSet.add(dsu.find(node))  
	    }  
	  
	    return rootSet.size  
	}  
	  
	inner class DisjointSetUnion(size: Int) {  
	    private val parents = IntArray(size) { it }  
	    private val ranking = IntArray(size) { 0 }  
	  
	  
	    fun find(x: Int): Int {  
	        if (x != parents[x]) {  
	            parents[x] = find(parents[x])  
	        }  
	        return parents[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if( rootA > rootB ) {  
	            parents[rootB] = rootA  
	        }  
	        else if( rootA < rootB) {  
	            parents[rootA] = rootB  
	        }  
	        else {  
	            parents[rootB] = rootA  
	            ranking[rootA] ++  
	        }  
	  
	        return true  
	    }  
	}
}
```

### BFS ì˜ˆì‹œ ë¬¸ì œ
3) ìˆ¨ë°”ê¼­ì§ˆ
```kotlin
class HideAndSeek {  
    /**  
     * ğŸ§© ë¬¸ì œ 3. ìˆ¨ë°”ê¼­ì§ˆ (ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰)  
     *     
     * ì„¤ëª…  
     *  
     * ìˆ˜ë¹ˆì´ëŠ” í˜„ì¬ ìœ„ì¹˜ Nì— ìˆê³ , ë™ìƒì€ ìœ„ì¹˜ Kì— ìˆë‹¤.  
     * ìˆ˜ë¹ˆì´ëŠ” ê±·ê±°ë‚˜ ìˆœê°„ì´ë™í•  ìˆ˜ ìˆë‹¤.  
     *  â€¢  ê±·ëŠ” ê²½ìš°: X - 1 ë˜ëŠ” X + 1 (1ì´ˆ ì†Œìš”)  
     *  â€¢  ìˆœê°„ì´ë™: 2 * X (1ì´ˆ ì†Œìš”)  
     *     * ìˆ˜ë¹ˆì´ê°€ ë™ìƒì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì„ êµ¬í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ìˆ˜ë¹ˆì´ì˜ ìœ„ì¹˜ Nê³¼ ë™ìƒì˜ ìœ„ì¹˜ Kê°€ ì£¼ì–´ì§„ë‹¤. (0 â‰¤ N, K â‰¤ 100,000)  
     *     * ì¶œë ¥  
     *  â€¢  ìˆ˜ë¹ˆì´ê°€ ë™ìƒì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ìµœì†Œ ì‹œê°„(ì´ˆ)ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ì˜ˆì‹œ ì…ë ¥ 1    
     * 5 17    
     * ì˜ˆì‹œ ì¶œë ¥ 1  
     * 4    
     * 5 â†’ 10 â†’ 9 â†’ 18 â†’ 17 (ì´ 4ì´ˆ)  
     */  
    @Test  
    fun solution() {  
        val start = 5  
        val end = 17  
  
        val expected = 4  
  
  
        assertEquals(expected, bfs(start, end))  
    }  
  
    private fun bfs(start: Int, end: Int): Int {  
        val queue = LinkedBlockingQueue<Int>()  
        val visited = BooleanArray(100_001)  
        val distance = IntArray(100_001)  
        queue.add(start)  
        visited[start] = true  
  
  
  
  
        while (queue.isNotEmpty()) {  
            val now = queue.poll()  
            if (end == now) return distance[now]  
            val direction = listOf(now - 1, now + 1, now * 2)  
  
            for (next in direction) {  
                if(next in 0 .. 100_000 && !visited[next]) {  
                    queue.add(next)  
                    distance[next] = distance[now] + 1  
                    visited[next] = true  
                }  
            }  
  
        }  
  
  
        return -1  
    }  

	private fun bfsNoVisited(start: Int, end: Int): Int {  
	    val queue = LinkedBlockingQueue<Int>()  
	    val distance = IntArray(100_001){-1}  
	    queue.add(start)  
	    distance[start] = 0  
	  
	  
	  
	  
	    while (queue.isNotEmpty()) {  
	        val now = queue.poll()  
	        if (end == now) return distance[now]  
	        val direction = listOf(now - 1, now + 1, now * 2)  
	  
	        for (next in direction) {  
	            if(next in 0 .. 100_000 && distance[next] == -1) {  
	                queue.add(next)  
	                distance[next] = distance[now] + 1  
	            }  
	        }  
	  
	    }  
	  
	  
	    return -1  
	}
}
```

### 6. DFS/BFSì˜ ê·¸ë˜í”„ í˜•íƒœì— ë”°ë¥¸ ë™ì‘ ì°¨ì´
1) íŠ¸ë¦¬(cycle ì—†ëŠ” íŠ¸ë¦¬)
	- DFS: ë£¨íŠ¸ì—ì„œ ë¦¬í”„ê¹Œì§€ ê²½ë¡œë¥¼ ëª¨ë‘ íƒìƒ‰í•œë‹¤. ë°±íŠ¸ë˜í‚¹ ë¬¸ì œì— ì í•©í•˜ë‹¤.
	- BFS: ê°™ì€ ë ˆë²¨ ë…¸ë“œ ìˆœì°¨ íƒìƒ‰. ë ˆë²¨ ê¸°ë°˜ ë¬¸ì œì— ì í•©í•˜ë‹¤.(ìµœì†Œ ê±°ë¦¬, ìµœì†Œ íšŸìˆ˜)
2) ì‚¬ì´í´ì´ ìˆëŠ” ì¼ë°˜ ê·¸ë˜í”„
	- ë°©ë¬¸ ì—¬ë¶€ ì²´í¬ -> ì•ˆ í•˜ë©´ ë¬´í•œ ë£¨í”„
	- DFS: `visited[node] = true`  ì§„ì… ì‹œì ì—
	- BFS: `visited[node] = true`  íì— ë„£ëŠ” ì‹œì 
3) ì‘ìš© êµ¬ì¡°
	1) DFS
		1) ë°±íŠ¸ë˜í‚¹ íƒìƒ‰
		2) ë¶€ë¶„ ì§‘í•© ìƒì„±
		3) ê·¸ë˜í”„ íƒìƒ‰(ì—°ê²° ìš”ì‡¼, ì‚¬ì´í´ íƒì§€)
		4) ê¹Šì´ ê¸°ë°˜ íƒìƒ‰
	2) BFS
		1) ìµœë‹¨ê±°ë¦¬(ê°€ì¤‘ì¹˜ ì—†ëŠ”)
		2) ìµœì†Œ íšŸìˆ˜ ì´ë™(ìˆ¨ë°”ê¼­ì§ˆ)
		3) ë ˆë²¨ íƒìƒ‰
		4) ìµœë‹¨ ê±°ë¦¬ ë³µì› 
4) íƒìƒ‰ ìˆœì„œ
	- ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°
		- ì‘ì€ ë²ˆí˜¸ ë¨¼ì € íƒìƒ‰ -> ì •ë ¬
		- DFS: `graph[node].sort()` í›„ `reversed()`ë¡œ stack ì‚¬ìš©
		- BFS: `graph[node].sort()` í›„ íì— ì¶”ê°€

### 7. ì˜ˆì‹œ ë¬¸ì œ
1) virus ê°ì—¼ - BFS
```kotlin
  
class Virus {  
    /**  
     *    
     * ğŸ§© ë¬¸ì œ 3. ë°”ì´ëŸ¬ìŠ¤  
     *  
     * ì„¤ëª…  
     * 1ë²ˆ ì»´í“¨í„°ê°€ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë ¸ì„ ë•Œ, 1ë²ˆì„ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë¦¬ëŠ” ì»´í“¨í„°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì»´í“¨í„°ì˜ ìˆ˜ N (2 â‰¤ N â‰¤ 100)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ ì¤„ì— ê°„ì„ ì˜ ìˆ˜ Mì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ê·¸ ë‹¤ìŒ Mì¤„ì—ëŠ” ì—°ê²°ëœ ë‘ ì»´í“¨í„°ì˜ ë²ˆí˜¸ê°€ í•œ ì¤„ì— í•˜ë‚˜ì”© ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *   
     * ì¶œë ¥  
     *  â€¢  1ë²ˆ ì»´í“¨í„°ë¥¼ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë¦¬ëŠ” ì»´í“¨í„° ìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”. (1ë²ˆ ì œì™¸)  
     *   
     * ì˜ˆì‹œ ì…ë ¥  
     * 7  
     * 6    
     * 1 2     
     * 2 3    
     * 1 5   
     * 5 2    
     * 5 6   
	 * 4 7  
	 * ì˜ˆì‹œ ì¶œë ¥  
     * 4  
     */  
     
    @Test  
    fun solution() {  
        val vertex = 7  
        val edge = 6  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 3),  
            intArrayOf(1, 5),  
            intArrayOf(5, 2),  
            intArrayOf(5, 6),  
            intArrayOf(4, 7),  
        )  
  
        val expected = 4  
  
        assertEquals(expected, dfsWithStack(vertex, table))  
    }  
  
    private fun createGraph(vertex: Int, table: Array<IntArray>): Array<MutableList<Int>> {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        table.sortedWith(compareBy({ it[0] }, { it[1] }))  
  
        for (element in table) {  
            val u = element.first()  
            val v = element.last()  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        for (element in graph) {  
            element.sort()  
        }  
        return graph  
    }  
  
    private fun createVisited(vertex: Int): BooleanArray = BooleanArray(vertex + 1)  
  
    private fun dfsWithStack(vertex: Int, table: Array<IntArray>): Int {  
        val graph = createGraph(vertex, table)  
        val visited = createVisited(vertex)  
        val stack = ArrayDeque<Int>()  
  
        visited[1] = true  
        stack.addLast(1)  
        var count = 0  
  
        while (stack.isNotEmpty()) {  
            val now = stack.removeLast()  
            count += 1  
  
  
            for (next in graph[now]) {  
                if (!visited[next]) {  
                    visited[next] = true  
                    stack.addLast(next)  
                }  
            }  
        }  
  
        return count - 1  
    }  
}
```
2) ì¥ì• ë¬¼ì„ í”¼í•´ì„œ ìµœë‹¨ ê±°ë¦¬ë¡œ ê°€ê¸° - DFS
```kotlin
class `Escape Easy` {  
  
    /**  
     * â¸»  
     *  
     * âœ… ë‚œì´ë„ í•˜í–¥ ë¬¸ì œ: ì¥ì• ë¬¼ì„ í”¼í•´ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•˜ê¸°  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     * NÃ—M í¬ê¸°ì˜ ì§€ë„ì—ì„œ ê³ ìŠ´ë„ì¹˜ â€˜Sâ€™ëŠ” ë¹„ë²„ì˜ êµ´ â€˜Dâ€™ê¹Œì§€ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ì§€ë„ì—ëŠ” ëŒ(â€˜Xâ€™)ì´ ìˆì–´ ì´ë™ì´ ë¶ˆê°€ëŠ¥í•œ ì¹¸ì´ ìˆìœ¼ë©°, ê³ ìŠ´ë„ì¹˜ëŠ” ì¸ì ‘í•œ ë„¤ ë°©í–¥(ìƒí•˜ì¢Œìš°)ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ê³ ìŠ´ë„ì¹˜ëŠ” ëŒì„ í”¼í•´ì„œ ëª©ì ì§€ â€˜Dâ€™ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤.  
     *     * ì§€ë„ ì •ë³´  
     *  â€¢  S: ì‹œì‘ ì§€ì  (ê³ ìŠ´ë„ì¹˜)  
     *  â€¢  D: ë„ì°© ì§€ì  (ë¹„ë²„ì˜ êµ´)  
     *  â€¢  .: ë¹ˆ ê³µê°„  
     *  â€¢  X: ëŒ (ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ìŒ)  
     *     * â¸»  
     *  
     * âœ¨ ì…ë ¥ ì˜ˆì‹œ  
     * 5 4  
     * D . . .   
     * . X X .  
     * . . . .   
     * X X . X   
     * S . . .   
     * âœ… ì¶œë ¥ ì˜ˆì‹œ  
     * 8  
     */  
     
    @Test  
    fun solution() {  
        val table = arrayOf(  
            arrayOf("D", ".", ".", "."),  
            arrayOf(".", "X", "X", "."),  
            arrayOf(".", ".", ".", "."),  
            arrayOf("X", "X", ".", "X"),  
            arrayOf("S", ".", ".", "."),  
        )  
        val expected = 8  
  
        assertEquals(expected, bfs(table))  
    }  
  
    private fun bfs(table: Array<Array<String>>): Int {  
        var startPoint: Pair<Int, Int>? = null  
        var endPoint: Pair<Int, Int>? = null  
  
        for ((rowIndex, row) in table.withIndex()) {  
            for ((cellIndex, cell) in row.withIndex()) {  
                if (cell == "S") startPoint = rowIndex to cellIndex  
                if (cell == "D") endPoint = rowIndex to cellIndex  
            }  
        }  
  
  
        if(startPoint == null || endPoint == null) return  - 1  
  
        val queue = LinkedBlockingQueue<Pair<Int, Int>>()  
        val visited = Array(table.size) { IntArray(table.first().size){ -1 } }  
  
        queue.add(startPoint)  
        visited[startPoint.first][startPoint.second] = 0  
  
        while (queue.isNotEmpty()) {  
            val (x, y) = queue.poll()  
            if(x == endPoint.first && y == endPoint.second ) break  
  
            val direction = mutableListOf<Pair<Int, Int>>()  
            if (x - 1 >= 0) direction.add(x - 1 to y)  
            if (x + 1 < table.size) direction.add(x + 1 to y)  
            if (y - 1 >= 0) direction.add(x to y - 1)  
            if (y + 1 < table.first().size) direction.add(x to y + 1)  
  
  
  
            for ((nextX, nextY) in direction) {  
                if ((table[nextX][nextY] == "." || table[nextX][nextY] == "D") && visited[nextX][nextY] == -1) {  
                    queue.add(nextX to nextY)  
                    visited[nextX][nextY] = visited[x][y] + 1  
                }  
            }  
        }  
        return visited[endPoint?.first ?: 0][endPoint?. second?: 0]  
    }  
}

```