
### 1. ê·¸ë˜í”„
- node, edgeë¡œ êµ¬ì„±ëœ êµ¬ì¡°
	- node(vertex) : ê·¸ë˜í”„ì—ì„œ ëŒ€ìƒ
	- edge: ì •ì  ê°„ì˜ ì—°ê²°

### 2. ê·¸ë˜í”„ ì¢…ë¥˜
1. Directed Graph: ê°„ì„ ì— ë°©í–¥ì´ ìˆìŒ
2. Undirected Graph: ì–‘ë°©í–¥ ê°„ì„ 
3. Weighted Graph: ê°„ì„ ë§ˆë‹¤ ë¹„ìš©ì´ë‚˜ ê±°ë¦¬ ë“±ì˜ ìˆ«ì ì •ë³´ê°€ ìˆë‹¤.
4. Unweighted Graph: ê°„ì„ ì— ë³„ë„ ìˆ«ìê°€ ì—†ë‹¤.

### 3. ê·¸ë˜í”„ í‘œí˜„ ë°©ì‹
1. Adjacency List
	1. ê° ì •ì ì— ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
	2. ê³µê°„ íš¨ìœ¨ì´ ì¢‹ê³ , ì—°ê²°ëœ ë…¸ë“œë§Œ í™•ì¸ ê°€ëŠ¥
	3. ì¼ë°˜ì ìœ¼ë¡œ ë§ì´ ì‚¬ìš©
2. Adjacency Matrix
	1. ì •ì  ê°œìˆ˜ ë§Œí¼ 2ì°¨ì› ë§¤ì—´ë¡œ í‘œí˜„
	2. ì—°ê²° ì—¬ë¶€ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆìœ¼ë‚˜, ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ë§ìŒ
	3. ë…¸ë“œê°€ ë§ì„ìˆ˜ë¡ ë¹„íš¨ìœ¨ì 

### 4. DFS(Depth-First Search)
- ê¹Šì´ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ëŠ¥í•œ í•œ ê¹Šì— ë“¤ì–´ê°
- ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ì„ ë•Œë§Œ ë˜ëŒì•„ê°€ë©´ì„œ(backtracking) ë‹¤ë¥¸ ê²½ë¡œ íƒìƒ‰
- ë³´í†µ ì¬ê·€ í˜¸ì¶œ í˜¹ì€ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„
- ë¯¸ë¡œ íƒìƒ‰, ì¡°í•© íƒìƒ‰, ê²½ë¡œ ì¡´ì¬ í™•ì¸ì— ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œë³´ë‹¤ ê¹Šì´
	- ê²½ë¡œê°€ ë‹¤ì–‘í•˜ê±°ë‚˜, ì „ë¶€ í™•ì¸ì´ í•„ìš”í•œ ê²½ìš°

#### í•µì‹¬ ì•„ì´ë””ì–´
- í•œ ë°©í–¥ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆì„ ë§Œí¼ ì­‰ ë“¤ì–´ê°”ë‹¤ê°€, ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ìœ¼ë©´ ë˜ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ë°©í–¥ì„ íƒìƒ‰í•˜ëŠ” ë°©ì‹

#### êµ¬í˜„

- ì¬ê·€ ê¸°ì¤€
	1. í˜„ì¬ ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
	2. í˜„ì¬ ë…¸ë“œì—ì„œ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ì´ ìˆìœ¼ë©´ ë‹¤ì‹œ ì¬ê·€  í˜¸ì¶œ
	3. ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ê¹Šì´ íƒìƒ‰
	4. ëª¨ë“  ë…¸ë“œê°€ ë°©ë¬¸ë˜ë©´ íƒìƒ‰ ì¢…ë£Œ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ
	1. ê·¸ë˜í”„
	2. ë°©ë¬¸ ì—¬ë¶€ ë°°ì—´
	3. DFS í•¨ìˆ˜
```kotlin
/**
 * ### **ğŸ“Œ ì„¤ëª…**
 *
 *	- node: í˜„ì¬ ë°©ë¬¸ ì¤‘ì¸ ë…¸ë“œ
 *	- graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì €ì¥ëœ ê·¸ë˜í”„
 *	- visited: ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
 *    â†’ ì´ í•¨ìˆ˜ëŠ” nodeë¶€í„° ì‹œì‘í•´ì„œ, **ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œë¥¼ ê¹Šì´ ìš°ì„ ì ìœ¼ë¡œ ë°©ë¬¸**í•©ë‹ˆë‹¤.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // ì¸ì ‘ ë…¸ë“œë¥¼ ë„£ì„ ë•Œ, ìˆœì„œ ì—­ìˆœ ì£¼ì˜
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- ë„ˆë¹„ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰
- ë³´í†µ íë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„
- ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•  ë•Œ ë§ì´ ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œê°€ ê±°ë¦¬ ì¤‘ì‹¬
	- ìµœë‹¨ ê²½ë¡œ ë¬¸ì œì— ì í•©

#### í•µì‹¬ ì•„ì´ë””ì–´
- í˜„ì¬ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ë¨¼ì € íƒìƒ‰í•˜ê³  ê·¸ ë‹¤ìŒ ê°€ê¹Œìš´ ë…¸ë“œì˜ ì´ì›ƒë“¤ì„ íƒìƒ‰í•´ë‚´ê°€ëŠ” ë°©ì‹

#### êµ¬í˜„ 
- ê³¼ì • 
	1. ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
	2.  íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ê³  í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œë“¤ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ì„ íì— ë„£ìŒ
	3. íê°€ ë¹Œ ë•Œê¹Œì§€ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ 
	- ê·¸ë˜í”„
	- ë°©ë¬¸ ë°°ì—´
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```

### DFS ì˜ˆì‹œ ë¬¸ì œ
1) ì—°ê²°ì„± í™•ì¸
```kotlin
class Connectivity {  
    /**  
     * ë¬¸ì œ 1. ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜  
     *  
     * ì„¤ëª…  
     *  
     * í•˜ë‚˜ì˜ ë¬´ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ë˜í”„ì—ì„œ ì—°ê²° ìš”ì†Œê°€ ëª‡ ê°œì¸ì§€ êµ¬í•˜ì„¸ìš”.  
     * ì—°ê²° ìš”ì†Œë€, ë…¸ë“œë“¤ë¼ë¦¬ ì„œë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ê·¸ë£¹ì„ ë§í•©ë‹ˆë‹¤.  
     *    
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì •ì ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 1,000)ê³¼ ê°„ì„ ì˜ ê°œìˆ˜ M (0 â‰¤ M â‰¤ NÃ—(N-1)/2)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ ë‘ ì •ì  u, vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ëŠ” ì •ì  uì™€ vê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.  
     *    
     * ì¶œë ¥  
     *  â€¢  ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ í•œ ì¤„ì— ì¶œë ¥í•˜ì„¸ìš”.  
     *     
     * ì˜ˆì‹œ ì…ë ¥  
     * 6 5  
     *    
     * 1 2     
     * 2 5    
     * 5 1     
     * 3 4     
     * 4 6    
     *    
     * ì˜ˆì‹œ ì¶œë ¥  
     * 2  //(1,2,5) (3,4,6) -> ë‘ ë©ì–´ë¦¬ 
     *    
     *     
     * 1. ì •ì   
     * [1, 2, 3, 4, 5, 6]  
     * 2. ê°„ì„   
     * [(1,2), (2,5), (5,1), (3,4), (4,6)]  
     *    
     * 3. ë°©ë²•?  
     * 1. DFS/BFS -> DFS (ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ í™•ì¸)  
     *     
     * 2. DisjointSetUnion
     */  
    @Test  
    fun solution() {  
        val vertex = 6  
        val edge = 5  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 5),  
            intArrayOf(5, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 6),  
        )  
        val expected = 2  
        assertEquals(expected, useStack(vertex, edge, table))  
        assertEquals(expected, useRecursive(vertex, edge, table))  
        assertEquals(expected, useDisjointSetUnion(vertex, edge, table))
    }  
  
    private fun useStack(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val stack = Stack<Int>()  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
            if(!visited[i]) {  
                stack.add(i)  
                visited[i] = true  
                count += 1  
            }  
  
            while(stack.isNotEmpty()) {  
                val node = stack.pop()  
                for(next in graph[node].reversed()) {  
                    if(!visited[next]) {  
                        stack.add(next)  
                        visited[next] = true  
                    }  
                }  
            }  
        }  
  
        return count  
    }  
  
    private fun useRecursive(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
           if(!visited[i]) {  
               count ++  
               recursive(i, graph, visited)  
           }  
        }  
  
        return count  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {  
        visited[node] = true  
  
        for(next in graph[node].reversed()) {  
            if(!visited[next]) {  
                recursive(next, graph, visited)  
            }  
        }  
    }  
   
	private fun useDisjointSetUnion(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex + 1)  
	    for( (a,b) in table) { dsu.union(a,b) }  
	  
	  
	    val rootSet = mutableSetOf<Int>()  
	    for ( node in 1 .. vertex) {  
	        rootSet.add(dsu.find(node))  
	    }  
	  
	    return rootSet.size  
	}  
	  
	inner class DisjointSetUnion(size: Int) {  
	    private val parents = IntArray(size) { it }  
	    private val ranking = IntArray(size) { 0 }  
	  
	  
	    fun find(x: Int): Int {  
	        if (x != parents[x]) {  
	            parents[x] = find(parents[x])  
	        }  
	        return parents[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if( rootA > rootB ) {  
	            parents[rootB] = rootA  
	        }  
	        else if( rootA < rootB) {  
	            parents[rootA] = rootB  
	        }  
	        else {  
	            parents[rootB] = rootA  
	            ranking[rootA] ++  
	        }  
	  
	        return true  
	    }  
	}
}
```