
### 1. ê·¸ë˜í”„
- node, edgeë¡œ êµ¬ì„±ëœ êµ¬ì¡°
	- node(vertex) : ê·¸ë˜í”„ì—ì„œ ëŒ€ìƒ
	- edge: ì •ì  ê°„ì˜ ì—°ê²°

### 2. ê·¸ë˜í”„ ì¢…ë¥˜
1. Directed Graph: ê°„ì„ ì— ë°©í–¥ì´ ìˆìŒ
2. Undirected Graph: ì–‘ë°©í–¥ ê°„ì„ 
3. Weighted Graph: ê°„ì„ ë§ˆë‹¤ ë¹„ìš©ì´ë‚˜ ê±°ë¦¬ ë“±ì˜ ìˆ«ì ì •ë³´ê°€ ìˆë‹¤.
4. Unweighted Graph: ê°„ì„ ì— ë³„ë„ ìˆ«ìê°€ ì—†ë‹¤.

### 3. ê·¸ë˜í”„ í‘œí˜„ ë°©ì‹
1. Adjacency List
	1. ê° ì •ì ì— ì—°ê²°ëœ ë…¸ë“œë“¤ì„ ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥
	2. ê³µê°„ íš¨ìœ¨ì´ ì¢‹ê³ , ì—°ê²°ëœ ë…¸ë“œë§Œ í™•ì¸ ê°€ëŠ¥
	3. ì¼ë°˜ì ìœ¼ë¡œ ë§ì´ ì‚¬ìš©
2. Adjacency Matrix
	1. ì •ì  ê°œìˆ˜ ë§Œí¼ 2ì°¨ì› ë§¤ì—´ë¡œ í‘œí˜„
	2. ì—°ê²° ì—¬ë¶€ë¥¼ ë¹ ë¥´ê²Œ í™•ì¸í•  ìˆ˜ ìˆìœ¼ë‚˜, ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ë§ìŒ
	3. ë…¸ë“œê°€ ë§ì„ìˆ˜ë¡ ë¹„íš¨ìœ¨ì 

### 4. DFS(Depth-First Search)
- ê¹Šì´ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ëŠ¥í•œ í•œ ê¹Šì— ë“¤ì–´ê°
- ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ì„ ë•Œë§Œ ë˜ëŒì•„ê°€ë©´ì„œ(backtracking) ë‹¤ë¥¸ ê²½ë¡œ íƒìƒ‰
- ë³´í†µ ì¬ê·€ í˜¸ì¶œ í˜¹ì€ ìŠ¤íƒìœ¼ë¡œ êµ¬í˜„
- ë¯¸ë¡œ íƒìƒ‰, ì¡°í•© íƒìƒ‰, ê²½ë¡œ ì¡´ì¬ í™•ì¸ì— ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œë³´ë‹¤ ê¹Šì´
	- ê²½ë¡œê°€ ë‹¤ì–‘í•˜ê±°ë‚˜, ì „ë¶€ í™•ì¸ì´ í•„ìš”í•œ ê²½ìš°

#### í•µì‹¬ ì•„ì´ë””ì–´
- í•œ ë°©í–¥ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆì„ ë§Œí¼ ì­‰ ë“¤ì–´ê°”ë‹¤ê°€, ë” ì´ìƒ ê°ˆ ìˆ˜ ì—†ìœ¼ë©´ ë˜ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ë°©í–¥ì„ íƒìƒ‰í•˜ëŠ” ë°©ì‹

#### êµ¬í˜„

- ì¬ê·€ ê¸°ì¤€
	1. í˜„ì¬ ë…¸ë“œ ë°©ë¬¸ ì²˜ë¦¬
	2. í˜„ì¬ ë…¸ë“œì—ì„œ ì—°ê²°ëœ ë‹¤ë¥¸ ë…¸ë“œ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ì´ ìˆìœ¼ë©´ ë‹¤ì‹œ ì¬ê·€  í˜¸ì¶œ
	3. ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ê¹Šì´ íƒìƒ‰
	4. ëª¨ë“  ë…¸ë“œê°€ ë°©ë¬¸ë˜ë©´ íƒìƒ‰ ì¢…ë£Œ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ
	1. ê·¸ë˜í”„
	2. ë°©ë¬¸ ì—¬ë¶€ ë°°ì—´
	3. DFS í•¨ìˆ˜
```kotlin
/**
 * ### **ğŸ“Œ ì„¤ëª…**
 *
 *	- node: í˜„ì¬ ë°©ë¬¸ ì¤‘ì¸ ë…¸ë“œ
 *	- graph: ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì €ì¥ëœ ê·¸ë˜í”„
 *	- visited: ë°©ë¬¸ ì—¬ë¶€ë¥¼ ì €ì¥í•˜ëŠ” ë°°ì—´
 *    â†’ ì´ í•¨ìˆ˜ëŠ” nodeë¶€í„° ì‹œì‘í•´ì„œ, **ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œë¥¼ ê¹Šì´ ìš°ì„ ì ìœ¼ë¡œ ë°©ë¬¸**í•©ë‹ˆë‹¤.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // ì¸ì ‘ ë…¸ë“œë¥¼ ë„£ì„ ë•Œ, ìˆœì„œ ì—­ìˆœ ì£¼ì˜
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- ë„ˆë¹„ ìš°ì„  íƒìƒ‰
- í•œ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰
- ë³´í†µ íë¥¼ ì‚¬ìš©í•´ì„œ êµ¬í˜„
- ìµœë‹¨ ê±°ë¦¬ë¥¼ êµ¬í•  ë•Œ ë§ì´ ì‚¬ìš©
	- ë°©ë¬¸ ìˆœì„œê°€ ê±°ë¦¬ ì¤‘ì‹¬
	- ìµœë‹¨ ê²½ë¡œ ë¬¸ì œì— ì í•©

#### í•µì‹¬ ì•„ì´ë””ì–´
- í˜„ì¬ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° ë¨¼ì € íƒìƒ‰í•˜ê³  ê·¸ ë‹¤ìŒ ê°€ê¹Œìš´ ë…¸ë“œì˜ ì´ì›ƒë“¤ì„ íƒìƒ‰í•´ë‚´ê°€ëŠ” ë°©ì‹

#### êµ¬í˜„ 
- ê³¼ì • 
	1. ì‹œì‘ ë…¸ë“œë¥¼ íì— ë„£ê³  ë°©ë¬¸ ì²˜ë¦¬
	2.  íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ê³  í•´ë‹¹ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œë“¤ ì¤‘ ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ì„ íì— ë„£ìŒ
	3. íê°€ ë¹Œ ë•Œê¹Œì§€ ìœ„ì˜ ê³¼ì •ì„ ë°˜ë³µ
- í•„ìš”í•œ êµ¬ì„± ìš”ì†Œ 
	- ê·¸ë˜í”„
	- ë°©ë¬¸ ë°°ì—´
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```

### DFS/BFS
0) ìˆœíšŒ í™•ì¸í•˜ê¸°
```kotlin
package renewal.graph  
  
import org.junit.jupiter.api.Assertions.assertEquals  
import org.junit.jupiter.api.Test  
import java.util.concurrent.LinkedBlockingQueue  
  
class Traverse {  
    /**  
     * ğŸ§© ë¬¸ì œ 2. DFSì™€ BFS ìˆœì„œ ì¶œë ¥  
     *  
     * ì„¤ëª…  
     *  
     * í•˜ë‚˜ì˜ ë¬´ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ,  
     * íŠ¹ì •í•œ ì •ì ì—ì„œ DFSì™€ BFSë¥¼ ìˆ˜í–‰í•œ ê²°ê³¼ì˜ ë…¸ë“œ ë°©ë¬¸ ìˆœì„œë¥¼ ê°ê° ì¶œë ¥í•˜ì„¸ìš”.  
     * ë‹¨, ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°, ì •ì  ë²ˆí˜¸ê°€ ì‘ì€ ê²ƒë¶€í„° ë¨¼ì € ë°©ë¬¸í•©ë‹ˆë‹¤.  
     *  
     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì •ì  ìˆ˜ N, ê°„ì„  ìˆ˜ M, ì‹œì‘ ì •ì  Vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ Mê°œì˜ ì¤„ì—ëŠ” ê°„ì„  ì •ë³´ u vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     * (uì™€ vëŠ” ì–‘ë°©í–¥ìœ¼ë¡œ ì—°ê²°ë¨)  
     *   
     * ì˜ˆì‹œ ì…ë ¥:  
     * 4 5 1   
     *    
     * 1 2   
     * 1 3     
     * 1 4    
     * 2 4    
     * 3 4    
     *     
     * ì¶œë ¥  
     *  â€¢  ì²« ì¤„: DFS ë°©ë¬¸ ìˆœì„œ  
     *  â€¢  ë‘˜ì§¸ ì¤„: BFS ë°©ë¬¸ ìˆœì„œ  
     *  ì˜ˆì‹œ ì¶œë ¥:  
     * 1 2 4 3    
     * 1 2 3 4    
     * */  
      
    /**
     * ê¸°ë³¸ ì‚¬ì´ì¦ˆ  
     */  
    @Test  
    fun solution1() {  
        val vertex = 4  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(1, 4),  
            intArrayOf(2, 4),  
            intArrayOf(3, 4),  
        )  
  
        val dfsExpected = "1 2 4 3"  
        val bfsExpected = "1 2 3 4"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * ë” í° ì‚¬ì´ì¦ˆ  
     */  
    @Test  
    fun solution2() {  
        /**  
         * ì •ì  ìˆ˜: 10  
         * ê°„ì„  ìˆ˜: 9  
         * ì‹œì‘ ì •ì : 1  
         * ê°„ì„  ëª©ë¡:  
         * 1 2        
         * 1 3       
         * 2 4       
         * 2 5       
         * 5 6        
         * 3 7       
         * 3 8        
         * 8 9        
         * 9 10         
         *         
         * ì‹œê°í™”  
         *          1  
         *        /   \         
         *       2     3      
         *      / \     \       
         *     4   5     8      
         *          \     \       
         *           6     9     
         *                  \       
         *                  10    
         * */
        
        val vertex = 10  
        val edge = 9  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(2, 4),  
            intArrayOf(2, 5),  
            intArrayOf(5, 6),  
            intArrayOf(3, 7),  
            intArrayOf(3, 8),  
            intArrayOf(8, 9),  
            intArrayOf(9, 10),  
        )  
  
        val dfsExpected = "1 2 4 5 6 3 7 8 9 10"  
        val bfsExpected = "1 2 3 4 5 7 8 6 9 10"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    /**  
     * ë¹„ì—°ê²° ê·¸ë˜í”„  
     */  
    @Test  
    fun solution3() {  
        val vertex = 8  
        val edge = 5  
        val start = 1  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(1, 3),  
            intArrayOf(4, 5),  
            intArrayOf(6, 7),  
            intArrayOf(7, 8),  
        )  
  
        val dfsExpected = "1 2 3"  
        val bfsExpected = "1 2 3"  
  
        assertEquals(dfsExpected, dfsUseStack(vertex, edge, start, table))  
        assertEquals(dfsExpected, dfsUseRecursive(vertex, edge, start, table))  
        assertEquals(bfsExpected, bfsUseQueue(vertex, edge, start, table))  
    }  
  
    private fun createGraph(vertex: Int, table: Array<IntArray>): Array<MutableList<Int>> {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table.sortedBy { it[1] }) {  
            val u = element.first()  
            val v = element.last()  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        for (adj in graph) {  
            adj.sort()  
        }  
  
        return graph  
    }  
  
    private fun createVisit(vertex: Int) = BooleanArray(vertex + 1)  
  
    private fun dfsUseStack(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val stack = ArrayDeque<Int>()  
        val builder = StringBuilder()  
        stack.add(start)  
  
        while (stack.isNotEmpty()) {  
            val now = stack.removeLast()  
            if(visited[now]) continue  
  
            visited[now] = true  
            builder.append("$now ")  
  
            for (next in graph[now].reversed()) {  
                if (!visited[next]) {  
                    stack.addLast(next)  
                }  
            }  
        }  
  
        return builder.toString().trim()  
    }  
  
    private fun dfsUseRecursive(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        recursive(start, graph, visited, builder)  
  
        return builder.toString().trim()  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray, builder: StringBuilder) {  
        if (visited[node]) return  
  
        visited[node] = true  
        builder.append("$node ")  
  
        for (next in graph[node]) {  
            recursive(next, graph, visited, builder)  
        }  
    }  
  
    private fun bfsUseQueue(vertex: Int, edge: Int, start: Int, table: Array<IntArray>): String {  
        val graph = createGraph(vertex, table)  
        val visited = createVisit(vertex)  
        val builder = StringBuilder()  
        val queue = LinkedBlockingQueue<Int>()  
        queue.add(start)  
  
        while(queue.isNotEmpty()) {  
            val now = queue.poll()  
  
            if(visited[now]) continue  
            builder.append("$now ")  
            visited[now] = true  
  
            for(next in graph[now]) {  
                queue.add(next)  
            }  
        }  
  
  
        return builder.toString().trim()  
    }  
}
```

### DFS ì˜ˆì‹œ ë¬¸ì œ
1) ì—°ê²°ì„± í™•ì¸
```kotlin
class Connectivity {  
    /**  
     * ë¬¸ì œ 1. ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜  
     *  
     * ì„¤ëª…  
     *  
     * í•˜ë‚˜ì˜ ë¬´ë°©í–¥ ê·¸ë˜í”„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ë˜í”„ì—ì„œ ì—°ê²° ìš”ì†Œê°€ ëª‡ ê°œì¸ì§€ êµ¬í•˜ì„¸ìš”.  
     * ì—°ê²° ìš”ì†Œë€, ë…¸ë“œë“¤ë¼ë¦¬ ì„œë¡œ ë„ë‹¬ ê°€ëŠ¥í•œ ê·¸ë£¹ì„ ë§í•©ë‹ˆë‹¤.  
     *    
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì •ì ì˜ ê°œìˆ˜ N (1 â‰¤ N â‰¤ 1,000)ê³¼ ê°„ì„ ì˜ ê°œìˆ˜ M (0 â‰¤ M â‰¤ NÃ—(N-1)/2)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ ì¤„ë¶€í„° Mê°œì˜ ì¤„ì— ê±¸ì³ ë‘ ì •ì  u, vê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤. ì´ëŠ” ì •ì  uì™€ vê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.  
     *    
     * ì¶œë ¥  
     *  â€¢  ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜ë¥¼ í•œ ì¤„ì— ì¶œë ¥í•˜ì„¸ìš”.  
     *     
     * ì˜ˆì‹œ ì…ë ¥  
     * 6 5  
     *    
     * 1 2     
     * 2 5    
     * 5 1     
     * 3 4     
     * 4 6    
     *    
     * ì˜ˆì‹œ ì¶œë ¥  
     * 2  //(1,2,5) (3,4,6) -> ë‘ ë©ì–´ë¦¬ 
     *    
     *     
     * 1. ì •ì   
     * [1, 2, 3, 4, 5, 6]  
     * 2. ê°„ì„   
     * [(1,2), (2,5), (5,1), (3,4), (4,6)]  
     *    
     * 3. ë°©ë²•?  
     * 1. DFS/BFS -> DFS (ëª¨ë“  ë…¸ë“œë¥¼ ëŒë©´ì„œ í™•ì¸)  
     *     
     * 2. DisjointSetUnion
     */  
    @Test  
    fun solution() {  
        val vertex = 6  
        val edge = 5  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 5),  
            intArrayOf(5, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 6),  
        )  
        val expected = 2  
        assertEquals(expected, useStack(vertex, edge, table))  
        assertEquals(expected, useRecursive(vertex, edge, table))  
        assertEquals(expected, useDisjointSetUnion(vertex, edge, table))
    }  
  
    private fun useStack(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val graph = Array(vertex + 1) { mutableListOf<Int>() }  
	    for (element in table) {  
	        val u = element[0]  
	        val v = element[1]  
	  
	        graph[u].add(v)  
	        graph[v].add(u)  
	    }  
	  
	    val stack = ArrayDeque<Int>()  
	    val visited = BooleanArray(vertex + 1)  
	    var count = 0  
	  
	  
	    for (i in 1..vertex) {  
	        if (!visited[i]) {  
	            stack.addLast(i)  
	            visited[i] = true  
	            count += 1  
	        }  
	  
	        while (stack.isNotEmpty()) {  
	            val node = stack.removeLast()  
	            for (next in graph[node].reversed()) {  
	                if (!visited[next]) {  
	                    stack.addLast(next)  
	                    visited[next] = true  
	                }  
	            }  
	        }  
	    }  
	  
	    return count  
	}  
  
    private fun useRecursive(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
           if(!visited[i]) {  
               count ++  
               recursive(i, graph, visited)  
           }  
        }  
  
        return count  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {  
        visited[node] = true  
  
        for(next in graph[node].reversed()) {  
            if(!visited[next]) {  
                recursive(next, graph, visited)  
            }  
        }  
    }  
   
	private fun useDisjointSetUnion(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex + 1)  
	    for( (a,b) in table) { dsu.union(a,b) }  
	  
	  
	    val rootSet = mutableSetOf<Int>()  
	    for ( node in 1 .. vertex) {  
	        rootSet.add(dsu.find(node))  
	    }  
	  
	    return rootSet.size  
	}  
	  
	inner class DisjointSetUnion(size: Int) {  
	    private val parents = IntArray(size) { it }  
	    private val ranking = IntArray(size) { 0 }  
	  
	  
	    fun find(x: Int): Int {  
	        if (x != parents[x]) {  
	            parents[x] = find(parents[x])  
	        }  
	        return parents[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if( rootA > rootB ) {  
	            parents[rootB] = rootA  
	        }  
	        else if( rootA < rootB) {  
	            parents[rootA] = rootB  
	        }  
	        else {  
	            parents[rootB] = rootA  
	            ranking[rootA] ++  
	        }  
	  
	        return true  
	    }  
	}
}
```

### BFS ì˜ˆì‹œ ë¬¸ì œ
3) ìˆ¨ë°”ê¼­ì§ˆ
```kotlin
class HideAndSeek {  
    /**  
     * ğŸ§© ë¬¸ì œ 3. ìˆ¨ë°”ê¼­ì§ˆ (ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰)  
     *     
     * ì„¤ëª…  
     *  
     * ìˆ˜ë¹ˆì´ëŠ” í˜„ì¬ ìœ„ì¹˜ Nì— ìˆê³ , ë™ìƒì€ ìœ„ì¹˜ Kì— ìˆë‹¤.  
     * ìˆ˜ë¹ˆì´ëŠ” ê±·ê±°ë‚˜ ìˆœê°„ì´ë™í•  ìˆ˜ ìˆë‹¤.  
     *  â€¢  ê±·ëŠ” ê²½ìš°: X - 1 ë˜ëŠ” X + 1 (1ì´ˆ ì†Œìš”)  
     *  â€¢  ìˆœê°„ì´ë™: 2 * X (1ì´ˆ ì†Œìš”)  
     *     * ìˆ˜ë¹ˆì´ê°€ ë™ìƒì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ê°€ì¥ ë¹ ë¥¸ ì‹œê°„ì„ êµ¬í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ìˆ˜ë¹ˆì´ì˜ ìœ„ì¹˜ Nê³¼ ë™ìƒì˜ ìœ„ì¹˜ Kê°€ ì£¼ì–´ì§„ë‹¤. (0 â‰¤ N, K â‰¤ 100,000)  
     *     * ì¶œë ¥  
     *  â€¢  ìˆ˜ë¹ˆì´ê°€ ë™ìƒì„ ì°¾ì„ ìˆ˜ ìˆëŠ” ìµœì†Œ ì‹œê°„(ì´ˆ)ì„ ì¶œë ¥í•˜ì„¸ìš”.  
     *     * â¸»  
     *  
     * ì˜ˆì‹œ ì…ë ¥ 1    
     * 5 17    
     * ì˜ˆì‹œ ì¶œë ¥ 1  
     * 4    
     * 5 â†’ 10 â†’ 9 â†’ 18 â†’ 17 (ì´ 4ì´ˆ)  
     */  
    @Test  
    fun solution() {  
        val start = 5  
        val end = 17  
  
        val expected = 4  
  
  
        assertEquals(expected, bfs(start, end))  
    }  
  
    private fun bfs(start: Int, end: Int): Int {  
        val queue = LinkedBlockingQueue<Int>()  
        val visited = BooleanArray(100_001)  
        val distance = IntArray(100_001)  
        queue.add(start)  
        visited[start] = true  
  
  
  
  
        while (queue.isNotEmpty()) {  
            val now = queue.poll()  
            if (end == now) return distance[now]  
            val direction = listOf(now - 1, now + 1, now * 2)  
  
            for (next in direction) {  
                if(next in 0 .. 100_000 && !visited[next]) {  
                    queue.add(next)  
                    distance[next] = distance[now] + 1  
                    visited[next] = true  
                }  
            }  
  
        }  
  
  
        return -1  
    }  

	private fun bfsNoVisited(start: Int, end: Int): Int {  
	    val queue = LinkedBlockingQueue<Int>()  
	    val distance = IntArray(100_001){-1}  
	    queue.add(start)  
	    distance[start] = 0  
	  
	  
	  
	  
	    while (queue.isNotEmpty()) {  
	        val now = queue.poll()  
	        if (end == now) return distance[now]  
	        val direction = listOf(now - 1, now + 1, now * 2)  
	  
	        for (next in direction) {  
	            if(next in 0 .. 100_000 && distance[next] == -1) {  
	                queue.add(next)  
	                distance[next] = distance[now] + 1  
	            }  
	        }  
	  
	    }  
	  
	  
	    return -1  
	}
}
```

### 6. DFS/BFSì˜ ê·¸ë˜í”„ í˜•íƒœì— ë”°ë¥¸ ë™ì‘ ì°¨ì´
1) íŠ¸ë¦¬(cycle ì—†ëŠ” íŠ¸ë¦¬)
	- DFS: ë£¨íŠ¸ì—ì„œ ë¦¬í”„ê¹Œì§€ ê²½ë¡œë¥¼ ëª¨ë‘ íƒìƒ‰í•œë‹¤. ë°±íŠ¸ë˜í‚¹ ë¬¸ì œì— ì í•©í•˜ë‹¤.
	- BFS: ê°™ì€ ë ˆë²¨ ë…¸ë“œ ìˆœì°¨ íƒìƒ‰. ë ˆë²¨ ê¸°ë°˜ ë¬¸ì œì— ì í•©í•˜ë‹¤.(ìµœì†Œ ê±°ë¦¬, ìµœì†Œ íšŸìˆ˜)
2) ì‚¬ì´í´ì´ ìˆëŠ” ì¼ë°˜ ê·¸ë˜í”„
	- ë°©ë¬¸ ì—¬ë¶€ ì²´í¬ -> ì•ˆ í•˜ë©´ ë¬´í•œ ë£¨í”„
	- DFS: `visited[node] = true`  ì§„ì… ì‹œì ì—
	- BFS: `visited[node] = true`  íì— ë„£ëŠ” ì‹œì 
3) ì‘ìš© êµ¬ì¡°
	1) DFS
		1) ë°±íŠ¸ë˜í‚¹ íƒìƒ‰
		2) ë¶€ë¶„ ì§‘í•© ìƒì„±
		3) ê·¸ë˜í”„ íƒìƒ‰(ì—°ê²° ìš”ì‡¼, ì‚¬ì´í´ íƒì§€)
		4) ê¹Šì´ ê¸°ë°˜ íƒìƒ‰
	2) BFS
		1) ìµœë‹¨ê±°ë¦¬(ê°€ì¤‘ì¹˜ ì—†ëŠ”)
		2) ìµœì†Œ íšŸìˆ˜ ì´ë™(ìˆ¨ë°”ê¼­ì§ˆ)
		3) ë ˆë²¨ íƒìƒ‰
		4) ìµœë‹¨ ê±°ë¦¬ ë³µì› 
4) íƒìƒ‰ ìˆœì„œ
	- ë°©ë¬¸í•  ìˆ˜ ìˆëŠ” ë…¸ë“œê°€ ì—¬ëŸ¬ ê°œì¸ ê²½ìš°
		- ì‘ì€ ë²ˆí˜¸ ë¨¼ì € íƒìƒ‰ -> ì •ë ¬
		- DFS: `graph[node].sort()` í›„ `reversed()`ë¡œ stack ì‚¬ìš©
		- BFS: `graph[node].sort()` í›„ íì— ì¶”ê°€

### 7. ì˜ˆì‹œ ë¬¸ì œ

1) ì¥ì• ë¬¼ì„ í”¼í•´ì„œ ìµœë‹¨ ê±°ë¦¬ë¡œ ê°€ê¸° - DFS
```kotlin
class `Escape Easy` {  
  
    /**  
     * â¸»  
     *  
     * âœ… ë‚œì´ë„ í•˜í–¥ ë¬¸ì œ: ì¥ì• ë¬¼ì„ í”¼í•´ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•˜ê¸°  
     *  
     * ë¬¸ì œ ì„¤ëª…  
     * NÃ—M í¬ê¸°ì˜ ì§€ë„ì—ì„œ ê³ ìŠ´ë„ì¹˜ â€˜Sâ€™ëŠ” ë¹„ë²„ì˜ êµ´ â€˜Dâ€™ê¹Œì§€ ì´ë™í•˜ë ¤ê³  í•©ë‹ˆë‹¤.  
     * ì§€ë„ì—ëŠ” ëŒ(â€˜Xâ€™)ì´ ìˆì–´ ì´ë™ì´ ë¶ˆê°€ëŠ¥í•œ ì¹¸ì´ ìˆìœ¼ë©°, ê³ ìŠ´ë„ì¹˜ëŠ” ì¸ì ‘í•œ ë„¤ ë°©í–¥(ìƒí•˜ì¢Œìš°)ìœ¼ë¡œ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ê³ ìŠ´ë„ì¹˜ëŠ” ëŒì„ í”¼í•´ì„œ ëª©ì ì§€ â€˜Dâ€™ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤.  
     *     * ì§€ë„ ì •ë³´  
     *  â€¢  S: ì‹œì‘ ì§€ì  (ê³ ìŠ´ë„ì¹˜)  
     *  â€¢  D: ë„ì°© ì§€ì  (ë¹„ë²„ì˜ êµ´)  
     *  â€¢  .: ë¹ˆ ê³µê°„  
     *  â€¢  X: ëŒ (ì§€ë‚˜ê°ˆ ìˆ˜ ì—†ìŒ)  
     *     * â¸»  
     *  
     * âœ¨ ì…ë ¥ ì˜ˆì‹œ  
     * 5 4  
     * D . . .   
     * . X X .  
     * . . . .   
     * X X . X   
     * S . . .   
     * âœ… ì¶œë ¥ ì˜ˆì‹œ  
     * 8  
     */  
     
    @Test  
    fun solution() {  
        val table = arrayOf(  
            arrayOf("D", ".", ".", "."),  
            arrayOf(".", "X", "X", "."),  
            arrayOf(".", ".", ".", "."),  
            arrayOf("X", "X", ".", "X"),  
            arrayOf("S", ".", ".", "."),  
        )  
        val expected = 8  
  
        assertEquals(expected, bfs(table))  
    }  
  
    private fun bfs(table: Array<Array<String>>): Int {  
        var startPoint: Pair<Int, Int>? = null  
        var endPoint: Pair<Int, Int>? = null  
  
        for ((rowIndex, row) in table.withIndex()) {  
            for ((cellIndex, cell) in row.withIndex()) {  
                if (cell == "S") startPoint = rowIndex to cellIndex  
                if (cell == "D") endPoint = rowIndex to cellIndex  
            }  
        }  
  
  
        if(startPoint == null || endPoint == null) return  - 1  
  
        val queue = LinkedBlockingQueue<Pair<Int, Int>>()  
        val visited = Array(table.size) { IntArray(table.first().size){ -1 } }  
  
        queue.add(startPoint)  
        visited[startPoint.first][startPoint.second] = 0  
  
        while (queue.isNotEmpty()) {  
            val (x, y) = queue.poll()  
            if(x == endPoint.first && y == endPoint.second ) break  
  
            val direction = mutableListOf<Pair<Int, Int>>()  
            if (x - 1 >= 0) direction.add(x - 1 to y)  
            if (x + 1 < table.size) direction.add(x + 1 to y)  
            if (y - 1 >= 0) direction.add(x to y - 1)  
            if (y + 1 < table.first().size) direction.add(x to y + 1)  
  
  
  
            for ((nextX, nextY) in direction) {  
                if ((table[nextX][nextY] == "." || table[nextX][nextY] == "D") && visited[nextX][nextY] == -1) {  
                    queue.add(nextX to nextY)  
                    visited[nextX][nextY] = visited[x][y] + 1  
                }  
            }  
        }  
        return visited[endPoint?.first ?: 0][endPoint?. second?: 0]  
    }  
}

```
2) ê°ì‹œ
```kotlin
class Surveillance {  
    /**  
     * ğŸ§© ë¬¸ì œ: ê°ì‹œ (ì½”ë”© í…ŒìŠ¤íŠ¸ ë³€í˜•)  
     * (ê¸°ë°˜: BOJ 15683)  
     * â¸»  
     * ğŸ“ ë¬¸ì œ ì„¤ëª…  
     *  
     * ì‚¬ë¬´ì‹¤ì€ NÃ—M í¬ê¸°ì˜ ê²©ìíŒì´ë‹¤. ê° ì¹¸ì—ëŠ” ë‹¤ìŒ ì¤‘ í•˜ë‚˜ê°€ ì¡´ì¬í•œë‹¤.  
     *  â€¢  0: ë¹ˆ ì¹¸  
     *  â€¢  6: ë²½  
     *  â€¢  1~5: CCTV (ì´ 5ì¢…ë¥˜, ê°ì‹œ ë°©í–¥ ë‹¤ë¦„)  
     *    
     * CCTVëŠ” ìì‹ ì˜ ì¢…ë¥˜ì— ë”°ë¼ í•œ ë°©í–¥ ë˜ëŠ” ì—¬ëŸ¬ ë°©í–¥ì„ ê°ì‹œí•  ìˆ˜ ìˆë‹¤.  
     * ê°ì‹œ ë°©í–¥ì— ìˆëŠ” ëª¨ë“  ë¹ˆ ì¹¸ì€ ê°ì‹œ ê°€ëŠ¥í•˜ë‹¤. ë²½ì´ ìˆìœ¼ë©´ ê°ì‹œê°€ ê·¸ ì¹¸ì—ì„œ ë§‰íŒë‹¤.  
     *    
     * ë‹¹ì‹ ì€ ëª¨ë“  CCTVì— ëŒ€í•´ ê°ì‹œ ë°©í–¥ì„ í•˜ë‚˜ì”© ì •í•  ìˆ˜ ìˆë‹¤.  
     *   
     * ëª¨ë“  CCTVì˜ ë°©í–¥ì„ ì ì ˆíˆ ì •í–ˆì„ ë•Œ, ê°ì‹œë˜ì§€ ì•ŠëŠ” ë¹ˆ ì¹¸(0)ì˜ ìµœì†Œ ê°œìˆ˜ëŠ”?  
     * â¸»  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„ì— N, Mì´ ì£¼ì–´ì§„ë‹¤. (1 â‰¤ N, M â‰¤ 8)  
     *  â€¢  ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ì‚¬ë¬´ì‹¤ ì •ë³´ê°€ ì£¼ì–´ì§„ë‹¤.  
     *  â€¢  ì‚¬ë¬´ì‹¤ì—ëŠ” CCTVê°€ ìµœì†Œ 1ê°œ ì´ìƒ ì¡´ì¬í•œë‹¤.  
     * â¸»  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ê°ì‹œë˜ì§€ ì•ŠëŠ” ìµœì†Œ ë¹ˆ ì¹¸ ìˆ˜ë¥¼ ì¶œë ¥í•˜ì‹œì˜¤.  
     * â¸»  
     * ğŸ’¡ CCTV ì¢…ë¥˜ ë° ê°ì‹œ ë°©í–¥  
     * |  ë²ˆí˜¸   |  ê°ì‹œ ê°€ëŠ¥ ë°©í–¥ (íšŒì „ ê°€ëŠ¥)            |  
     * |  1     |  â†’ or â†“ or â† or â†‘ (1ë°©í–¥)         |  
     * |  2     |  â†” or â†• (2ë°©í–¥)                   |  
     * |  3     |  â†’â†‘ or â†‘â† or â†â†“ or â†“â†’ (ì§ê° 2ë°©í–¥) |  
     * |  4     |  â†’â†‘â† or â†‘â†â†“ or â†â†“â†’ or â†“â†’â†‘ (3ë°©í–¥) |  
     * |  5     |  â†’â†“â†â†‘ (ëª¨ë“  ë°©í–¥, ê³ ì •)             |  
     *    
     *    
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 4 6  
     * 0 0 0 0 0 0   
     * 0 1 0 0 6 0   
     * 0 0 0 0 0 0   
     * 0 0 0 0 0 5   
     *     
     * âœ… ì˜ˆì œ ì¶œë ¥  
     * 11  
     *    
     *    
     * 0 0 0 0 0 #  
     * 0 1 # # 6 #  
     * 0 0 0 0 0 #  
     * # # # # # 5  
     * */  
 
    @Test  
    fun solution() {  
        val table = arrayOf(  
            intArrayOf(0, 0, 0, 0, 0, 0),  
            intArrayOf(0, 1, 0, 0, 6, 0),  
            intArrayOf(0, 0, 0, 0, 0, 0),  
            intArrayOf(0, 0, 0, 0, 0, 5),  
        )  
        val expected = 11  
  
        assertEquals(expected, dfsUseRecursive(table))  
        assertEquals(expected, dfsUseStack(table))  
    }  
  
    private fun dfsUseRecursive(table: Array<IntArray>): Int {  
  
        val camera = mutableListOf<Pair<Int, Int>>()  
        for ((rowIndex, row) in table.withIndex()) {  
            for ((cellIndex, cell) in row.withIndex()) {  
                if (cell in 1..5) camera.add(rowIndex to cellIndex)  
            }        }  
        return recursive(0, camera, table, table.sumOf { it.count { cell -> cell == 0 } })  
    }  
  
    /**  
     * ```   
     * fun ì¬ê·€í˜¸ì¶œ (í˜„ì¬ ì¹´ë©”ë¼ ì¸ë±ìŠ¤, ì´ ì¹´ë©”ë¼ ë¦¬ìŠ¤íŠ¸, í…Œì´ë¸”, 0ì˜ ê°œìˆ˜) {  
     *    
     *      if(í˜„ì¬ ì¹´ë©”ë¼ ì¹´ìš´íŠ¸ < 0 || í˜„ì¬ ì¹´ë©”ë¼ ì¹´ìš´íŠ¸ > ì¹´ë©”ë¼ ì‚¬ì´ì¦ˆ ) return ì§€ê¸ˆê¹Œì§€ 0ì˜ ê°œìˆ˜  
     *      for( ë°©í–¥ in í˜„ì¬ ì¹´ë©”ë¼ì˜ ì‹œê°ë“¤ ) {  
     *           val ì´ë²ˆ í„´ì— í•œ ë°©í–¥ ë§ˆí‚¹ ê¸°ì–µ = mutableList()   
     *    
     *           for( ë°©í–¥ in ë°©í–¥ ) {   
     *               ë°©í–¥ ë§ˆí‚¹ì²˜ë¦¬  
     *               ì´ë²ˆ í„´ì— í•œ ë°©í–¥ ë§ˆí‚¹ ê¸°ì–µì— ê¸°ë¡  
     *           }  
     *   
     *           val í˜„ì¬ ë§ˆí‚¹ê¹Œì§€ 0ì˜ ê°œìˆ˜ = table.sumOf{it.count{element == 0}}     
     *           ì¬ê·€ í˜¸ì¶œ (í˜„ì¬ ì¹´ë©”ë¼ ì¸ë±ìŠ¤ + 1, ì´ ì¹´ë©”ë¼ ë¦¬ìŠ¤íŠ¸, í…Œì´ë¸” ,í˜„ì¬ ë§ˆí‚¹ê¹Œì§€ 0ì˜ ê°œìˆ˜)  
     *    
     *           for (ë³µì› ìš”ì†Œ in ì´ë²ˆ í„´ì— í•œ ë°©í–¥ ë§ˆí‚¹ ê¸°ì–µ) {  
     *              ë³µì›  
     *           }  
     *      }     
     * }   
     * ```   
     * 
     * */  
	 
	 private fun recursive(  
        index: Int,  
        camera: MutableList<Pair<Int, Int>>,  
        table: Array<IntArray>,  
        count: Int  
    ): Int {  
        if (index !in 0 until camera.size) return count  
  
        var min = count  
        val directions: Map<Int, List<List<Direction>>> = mapOf(  
            1 to listOf(listOf(RIGHT), listOf(DOWN), listOf(LEFT), listOf(UP)),       // â†’ â†“ â† â†‘  
            2 to listOf(listOf(RIGHT, LEFT), listOf(DOWN, UP)),                       // â†” â†•  
            3 to listOf(listOf(RIGHT, UP), listOf(UP, LEFT), listOf(LEFT, DOWN), listOf(DOWN, RIGHT)), // ì§ê°  
            4 to listOf(  
                listOf(RIGHT, UP, LEFT),  
                listOf(UP, LEFT, DOWN),  
                listOf(LEFT, DOWN, RIGHT),  
                listOf(DOWN, RIGHT, UP)  
            ), // 3ë°©í–¥  
            5 to listOf(listOf(RIGHT, DOWN, LEFT, UP))                                // ì „ ë°©í–¥  
        )  
  
        /**  
         * for ë°©í–¥  
         *    visitedì— ê° ìƒí™© ë§ˆí‚¹  
         *    visitiedì—ì„œ 0 ì„¸ê³  minì— minOf ì—…ë°ì´íŠ¸  
         *        ë§Œì•½ ì—…ë°ì´íŠ¸ë¼ë©´ visited ë‘ê³   
         *      ì•„ë‹ˆë©´ ëŒë ¤ë†“ê¸°  
         */  
  
  
        val (y, x) = camera[index]  
        val cameraNumber: Int = table[y][x]  
  
        for( direction in directions[cameraNumber]!!) {  
            val memorize = mutableListOf<Triple<Int, Int, Int>>()  
            for( dir in direction) {  
               when (dir) {  
                   UP -> {  
                       for( i in y downTo 0) {  
                           if(table[i][x] == 6 ) break  
                           if(table[i][x] == 0) {  
                               memorize.add(Triple(i, x, table[i][x]))  
                               table[i][x] = 7  
                           }  
                       }  
                   }  
                   LEFT -> {  
                       for( i in x downTo 0) {  
                           if(table[y][i] == 6) break  
                           if(table[y][i] == 0) {  
                               memorize.add(Triple(y, i, table[y][i]))  
                               table[y][i] = 7  
                           }  
                       }  
                   }  
                   RIGHT -> {  
                       for( i in x until  table.first().size) {  
                           if(table[y][i] == 6) break  
                           if(table[y][i] == 0) {  
                               memorize.add(Triple(y, i, table[y][i]))  
                               table[y][i] = 7  
                           }  
                       }  
                   }  
                   DOWN -> {  
                       for( i in y until  table.size) {  
                           if(table[i][x] == 6) break  
                           if(table[i][x] == 0) {  
                               memorize.add(Triple(i, x, table[i][x]))  
                               table[i][x] = 7  
                           }  
                       }  
                   }  
               }  
  
            }  
  
            val count = table.sumOf { it.count { cell -> cell == 0 } }  
            min = minOf(min, recursive(index + 1, camera, table, count))  
  
            for((y, x, value) in memorize) {  
                table[y][x] = value  
            }  
  
        }  
  
        return min  
    }  
  
  
    /**  
     *```    
      *  val {í˜„ì¬ ì¹´ë©”ë¼, í˜„ì¬ ë°©í–¥, ì´ì „ê¹Œì§€ í…Œì´ë¸”} = stack.pop()  
     *  val copyTable = ì´ì „ê¹Œì§€ í…Œì´ë¸” ì¹´í”¼  
     *  
     *  for( ë°©í–¥ in í˜„ì¬ ë°©í–¥) {  
     *      ë°©í–¥ ë§ˆí‚¹ -> copyTable  
     *  }    
     *    
     *  if(cameraIndex ê°€ ë„˜ì§€ ì•Šì•˜ë‹¤ë©´) {  
     *      val ë‹¤ìŒ ì¹´ë©”ë¼ = ì¹´ë©”ë¼ ì„¸íŠ¸[í˜„ì¬ ì¹´ë©”ë¼ ì¸ë±ìŠ¤ + 1]    
     *      for(ë‹¤ìŒ ì¹´ë©”ë¼ ë°©í–¥ in ë‹¤ìŒ ì¹´ë©”ë¼ ë°©í–¥ë“¤ ) {    
     *        stack.push(í˜„ì¬ ì¹´ë©”ë¼ ì¸ë±ìŠ¤ + 1, ë‹¤ìŒ ì¹´ë©”ë¼ ë°©í–¥, copyTable )  
     *      }  
     *  }    
     *  else {    
     *      ì§‘ê³„  
     *  }  
     *```   
     */   
     
	private fun dfsUseStack(table: Array<IntArray>): Int {  
        val camera = mutableListOf<Pair<Int, Int>>()  
        val directions: Map<Int, List<List<Direction>>> = mapOf(  
            1 to listOf(listOf(RIGHT), listOf(DOWN), listOf(LEFT), listOf(UP)),       // â†’ â†“ â† â†‘  
            2 to listOf(listOf(RIGHT, LEFT), listOf(DOWN, UP)),                       // â†” â†•  
            3 to listOf(listOf(RIGHT, UP), listOf(UP, LEFT), listOf(LEFT, DOWN), listOf(DOWN, RIGHT)), // ì§ê°  
            4 to listOf(  
                listOf(RIGHT, UP, LEFT),  
                listOf(UP, LEFT, DOWN),  
                listOf(LEFT, DOWN, RIGHT),  
                listOf(DOWN, RIGHT, UP)  
            ), // 3ë°©í–¥  
            5 to listOf(listOf(RIGHT, DOWN, LEFT, UP))                                // ì „ ë°©í–¥  
        )  
  
        for ((rowIndex, row) in table.withIndex()) {  
            for ((cellIndex, cell) in row.withIndex()) {  
                if (cell in 1..5) camera.add(rowIndex to cellIndex)  
            }        }  
  
        val stack = ArrayDeque<Triple<Int, Array<IntArray>, List<Direction>>>()  
        var minOf = Int.MAX_VALUE  
  
        // ì²« ì¹´ë©”ë¼ ë°©í–¥ë³„ë¡œ push        val firstY = camera.first().first  
        val firstX = camera.first().second  
        val first = table[firstY][firstX]  
        for (dirs in directions[first]!!) {  
            // table deep copy  
            val copy = Array(table.size) { table[it].clone() }  
            mark(copy, firstY, firstX, dirs)  
            stack.addLast(Triple(0, copy, dirs))  
        }  
  
        while (stack.isNotEmpty()) {  
            val (index, curTable, dirs) = stack.removeLast()  
  
            if (index + 1 < camera.size) {  
                val (nextY, nextX) = camera[index + 1]  
                val camType = table[nextY][nextX]  
                for (nextDirs in directions[camType]!!) {  
                    // ë‹¤ìŒ ë¶„ê¸°ìš© table deep copy                    val nextTable = Array(curTable.size) { curTable[it].clone() }  
                    mark(nextTable, nextY, nextX, nextDirs)  
                    stack.addLast(Triple(index + 1, nextTable, nextDirs))  
                }  
            } else {  
                // ë¦¬í”„ì—ì„œ 0 ê°œìˆ˜ ì„¸ê¸°  
                val min = curTable.sumOf { it.count { v -> v == 0 } }  
                minOf = minOf(minOf, min)  
            }  
        }  
        return minOf  
    }  
  
    // tableì— dirs ë°©í–¥ ë§ˆí‚¹ í•¨ìˆ˜  
    private fun mark(table: Array<IntArray>, y: Int, x: Int, dirs: List<Direction>) {  
        for (dir in dirs) {  
            when (dir) {  
                UP -> {  
                    for (i in y - 1 downTo 0) {  
                        if (table[i][x] == 6) break  
                        if (table[i][x] == 0) table[i][x] = 7  
                    }  
                }  
                DOWN -> {  
                    for (i in y + 1 until table.size) {  
                        if (table[i][x] == 6) break  
                        if (table[i][x] == 0) table[i][x] = 7  
                    }  
                }  
                LEFT -> {  
                    for (i in x - 1 downTo 0) {  
                        if (table[y][i] == 6) break  
                        if (table[y][i] == 0) table[y][i] = 7  
                    }  
                }  
                RIGHT -> {  
                    for (i in x + 1 until table[0].size) {  
                        if (table[y][i] == 6) break  
                        if (table[y][i] == 0) table[y][i] = 7  
                    }  
                }  
            }  
        }  
    }  
  
    enum class Direction {  
        UP,  
        DOWN,  
        LEFT,  
        RIGHT  
    }  
  
}
```



### BFS

1) virus ê°ì—¼ - BFS
```kotlin
class Virus {  
    /**  
     *<pre>   
       * ğŸ§© ë¬¸ì œ 3. ë°”ì´ëŸ¬ìŠ¤  
     *  
     * ì„¤ëª…  
     * 1ë²ˆ ì»´í“¨í„°ê°€ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë ¸ì„ ë•Œ, 1ë²ˆì„ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë¦¬ëŠ” ì»´í“¨í„°ì˜ ìˆ˜ë¥¼ êµ¬í•˜ì„¸ìš”.  
     *    
     * ì…ë ¥  
     *  â€¢  ì²« ì¤„ì— ì»´í“¨í„°ì˜ ìˆ˜ N (2 â‰¤ N â‰¤ 100)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ë‹¤ìŒ ì¤„ì— ê°„ì„ ì˜ ìˆ˜ Mì´ ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *  â€¢  ê·¸ ë‹¤ìŒ Mì¤„ì—ëŠ” ì—°ê²°ëœ ë‘ ì»´í“¨í„°ì˜ ë²ˆí˜¸ê°€ í•œ ì¤„ì— í•˜ë‚˜ì”© ì£¼ì–´ì§‘ë‹ˆë‹¤.  
     *     
     * ì¶œë ¥  
     *  â€¢  1ë²ˆ ì»´í“¨í„°ë¥¼ í†µí•´ ë°”ì´ëŸ¬ìŠ¤ì— ê±¸ë¦¬ëŠ” ì»´í“¨í„° ìˆ˜ë¥¼ ì¶œë ¥í•˜ì„¸ìš”. (1ë²ˆ ì œì™¸)  
     *     
     * ì˜ˆì‹œ ì…ë ¥  
     * 7  
     * 6   
     * 1 2   
     * 2 3    
     * 1 5    
     * 5 2    
     * 5 6     
     * 4 7     
     * ì˜ˆì‹œ ì¶œë ¥  
     * 4  
     * </pre> 
     * */  

    @Test  
    fun solution() {  
        val vertex = 7  
        val edge = 6  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 3),  
            intArrayOf(1, 5),  
            intArrayOf(5, 2),  
            intArrayOf(5, 6),  
            intArrayOf(4, 7),  
        )  
  
        val expected = 4  
  
        assertEquals(expected, dfsWithStack(vertex, table))  
    }  
  
    private fun createGraph(vertex: Int, table: Array<IntArray>): Array<MutableList<Int>> {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        table.sortedWith(compareBy({ it[0] }, { it[1] }))  
  
        for (element in table) {  
            val u = element.first()  
            val v = element.last()  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        for (element in graph) {  
            element.sort()  
        }  
        return graph  
    }  
  
    private fun createVisited(vertex: Int): BooleanArray = BooleanArray(vertex + 1)  
  
    private fun dfsWithStack(vertex: Int, table: Array<IntArray>): Int {  
        val graph = createGraph(vertex, table)  
        val visited = createVisited(vertex)  
        val stack = ArrayDeque<Int>()  
  
        visited[1] = true  
        stack.addLast(1)  
        var count = 0  
  
        while (stack.isNotEmpty()) {  
            val now = stack.removeLast()  
            count += 1  
  
  
            for (next in graph[now]) {  
                if (!visited[next]) {  
                    visited[next] = true  
                    stack.addLast(next)  
                }  
            }  
        }  
  
        return count - 1  
    }  
}
```


2) ì¥ì• ë¬¼ í”¼í•´ì„œ ìµœë‹¨ê±°ë¦¬ë¡œ ê°€ê¸° (ë‹¨ 1íšŒ ì¥ì• ë¬¼ì„ ì¹˜ìš¸ ìˆ˜ ìˆë‹¤.) - BFS
```kotlin
//> **â€œë³µí•© ìƒíƒœë¥¼ ëª¨ë¸ë§í•˜ê³ , ê·¸ê²ƒì„ ê¸°ì¤€ìœ¼ë¡œ íƒìƒ‰í•˜ê±°ë‚˜ ìµœì í™”í•˜ëŠ” íŒ¨í„´â€**
//1. í˜„ì‹¤ ê°œë…ì„ ì½”ë“œë¡œ ì˜®ê¸°ëŠ” ëŠ¥ë ¥ì´ ë¶€ì¡±í•˜ë‹¤
//2. ì‚¬ê±´ì„ ì‘ê²Œ ìª¼ê°œì„œ ìƒê°í•˜ì§€ ëª»í•œë‹¤
class BreakWall {  
    /**  
     * ğŸ§© ë¬¸ì œ: ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸° (BOJ 2206)   
     *     
     * ğŸ“ ë¬¸ì œ ì„¤ëª…  
     *  â€¢  NÃ—Mì˜ í–‰ë ¬ë¡œ í‘œí˜„ë˜ëŠ” ë§µì´ ìˆë‹¤.  
     *  â€¢  ê³ ìŠ´ë„ì¹˜(í˜¹ì€ ì‚¬ëŒ)ëŠ” (1, 1)ì—ì„œ ì¶œë°œí•˜ì—¬ (N, M)ìœ¼ë¡œ ì´ë™í•´ì•¼ í•œë‹¤.  
     *  â€¢  0ì€ ì´ë™í•  ìˆ˜ ìˆëŠ” ê³³, 1ì€ ë²½.  
     *  â€¢  ë‹¨ ë²½ì„ ìµœëŒ€ 1ê°œê¹Œì§€ ë¶€ìˆ  ìˆ˜ ìˆë‹¤.  
     *  â€¢  ì´ë™ì€ ìƒí•˜ì¢Œìš° ì¸ì ‘í•œ ì¹¸ë§Œ ê°€ëŠ¥.  
     *  â€¢  ìµœë‹¨ ê±°ë¦¬ë¡œ ë„ì°©í•  ìˆ˜ ìˆëŠ” ìµœì†Œ ì´ë™ íšŸìˆ˜ë¥¼ ì¶œë ¥í•˜ë¼.  
     *  â€¢  ë„ë‹¬í•  ìˆ˜ ì—†ë‹¤ë©´ -1ì„ ì¶œë ¥í•˜ë¼.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„: N M (1 â‰¤ N, M â‰¤ 1,000)  
     *  â€¢  ë‹¤ìŒ Nì¤„: ê¸¸ì´ Mì˜ 0ê³¼ 1ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´  
     *  
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ëª©ì ì§€ê¹Œì§€ ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥  
     *  â€¢  ë„ë‹¬í•  ìˆ˜ ì—†ìœ¼ë©´ -1    
     *    
     * â¸»  
     *  
     * ğŸ§ª ì˜ˆì œ ì…ë ¥  
     * 6 4  
     * 0100   
     * 1110   
     * 1000   
     * 0000   
     * 0111    
     * 0000    
     *   
     * âœ…ì˜ˆì œ ì¶œë ¥  
     * 15  
     */  
    @Test  
    fun solution() {  
        val destination = 6 to 4  
        val table = arrayOf(  
            intArrayOf(0, 1, 0, 0),  
            intArrayOf(1, 1, 1, 0),  
            intArrayOf(1, 0, 0, 0),  
            intArrayOf(0, 0, 0, 0),  
            intArrayOf(0, 1, 1, 1),  
            intArrayOf(0, 0, 0, 0),  
        )  
        val expected = 15  
  
        assertEquals(expected, bfs(destination, table))  
    }  
  
    private fun bfs(destination: Pair<Int, Int>, table: Array<IntArray>): Int {  
        val (startY, startX, wallBreak) = Triple(0, 0, 0)  
        val (destinationY, destinationX) = destination  
  
        val visited = Array(table.size) {  
            Array(table.first().size) {  
                IntArray(2) { -1 }  
            }        }        val queue = LinkedBlockingQueue<Triple<Int, Int, Int>>()  
        queue.add(Triple(0, 0, 0))  
        visited[startY][startX][wallBreak] = 1  
  
        val direction = listOf(1 to 0, -1 to 0, 0 to 1, 0 to -1)  
  
        while (queue.isNotEmpty()) {  
            val (y, x, wb) = queue.poll()  
  
            for ((moveY, moveX) in direction) {  
                val nextX = moveX + x  
                val nextY = moveY + y  
  
                if(  
                    nextY in table.indices &&  
                    nextX in table.first().indices  
                ){  
  
                    if( table[nextY][nextX] == 1 && wb == 0 && visited[nextY][nextX][1] == -1) {  
                        visited[nextY][nextX][1] = visited[y][x][0] + 1  
                        queue.add(Triple(nextY, nextX, 1))  
                    }  
  
                    if( table[nextY][nextX] != 1 && visited[nextY][nextX][wb] == -1) {  
                        visited[nextY][nextX][wb] = visited[y][x][wb] + 1  
                        queue.add(Triple(nextY, nextX, wb))  
                    }  
  
                }  
            }  
        }  
  
        val response0 = visited[destinationY - 1][destinationX - 1][0]  
        val response1 = visited[destinationY - 1][destinationX - 1][1]  
        return when {  
            response0 == -1 && response1 == -1 -> -1  
            response0 == -1 && response1 != -1 -> response1  
            response0 != -1 && response1 == -1 -> response0  
            else -> minOf(response0, response1)  
        }  
    }  
}
```
3) ì¥ì• ë¬¼ í”¼í•´ì„œ ìµœë‹¨ê±°ë¦¬ë¡œ ê°€ê¸° (ë‹¨ níšŒ ì¥ì• ë¬¼ì„ ì¹˜ìš¸ ìˆ˜ ìˆë‹¤.) - BFS
```kotlin
class BreakWall2 {  
    /**  
     * ğŸ§© ë¬¸ì œ: ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸° 2 (BOJ 14442 ë³€í˜•, ì½”ë”© í…ŒìŠ¤íŠ¸ ìŠ¤íƒ€ì¼)  
     *   
     * â¸»  
     *  
     * ğŸ“ ë¬¸ì œ ì„¤ëª…  
     *  
     * ë‹¹ì‹ ì€ N Ã— M í¬ê¸°ì˜ í‰ë©´ ë§µ ìœ„ì— ì„œ ìˆìŠµë‹ˆë‹¤.  
     * ì´ ë§µì€ 0(ë¹ˆì¹¸)ê³¼ 1(ë²½)ë¡œ êµ¬ì„±ë˜ì–´ ìˆê³ ,  
     * ë‹¹ì‹ ì€ ì‹œì‘ì  (1, 1)ì—ì„œ ë„ì°©ì  (N, M)ìœ¼ë¡œ ì´ë™í•´ì•¼ í•©ë‹ˆë‹¤.  
     *   
     * ì´ë•Œ, ìµœëŒ€ Kê°œì˜ ë²½ì„ ë¶€ìˆ˜ê³  ì§€ë‚˜ê°ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
     * ë‹¨, í•œ ì¹¸ ì´ë™ì€ ìƒí•˜ì¢Œìš° ì¸ì ‘í•œ ì¹¸ìœ¼ë¡œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
     *   
     * â¸»  
     *  
     * ğŸ“¥ ì…ë ¥ í˜•ì‹  
     *  â€¢  ì²«ì§¸ ì¤„: N M K (1 â‰¤ N, M â‰¤ 1,000, 1 â‰¤ K â‰¤ 10)  
     *  â€¢  ë‹¤ìŒ Nì¤„: ê¸¸ì´ Mì˜ 0 ë˜ëŠ” 1ë¡œë§Œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´  
     *  
     * â¸»  
     *  
     * ğŸ“¤ ì¶œë ¥ í˜•ì‹  
     *  â€¢  ë„ì°©ì ê¹Œì§€ ì´ë™í•  ìˆ˜ ìˆë‹¤ë©´, ìµœì†Œ ì´ë™ íšŸìˆ˜ë¥¼ ì¶œë ¥  
     *  â€¢  ì´ë™í•  ìˆ˜ ì—†ë‹¤ë©´ -1ì„ ì¶œë ¥  
     *  
     * â¸»  
     *  
     * ğŸ’¡ ì˜ˆì œ ì…ë ¥  
     * 6 4 1  
     * 0100  
     * 1110 
     * 1000  
     * 0000 
     * 0111 
     * 0000
     *
	 * âœ… ì˜ˆì œ ì¶œë ¥  
     * 15  
     */
       
    @Test  
    fun solution() {  
        val destination = 6 to 4  
        val wallBreakCount = 1  
        val table = arrayOf(  
            intArrayOf(0, 1, 0, 0),  
            intArrayOf(1, 1, 1, 0),  
            intArrayOf(1, 0, 0, 0),  
            intArrayOf(0, 0, 0, 0),  
            intArrayOf(0, 1, 1, 1),  
            intArrayOf(0, 0, 0, 0),  
        )  
        val expected = 15  
  
        assertEquals(expected, bfs(destination, wallBreakCount, table))  
    }  
  
    fun bfs(destination: Pair<Int, Int>, wallBreakCount: Int, table: Array<IntArray>): Int {  
        val startPoint = 0 to 0  
        val (endPointY, endPointX) = destination.first - 1 to destination.second - 1  
  
        val queue = ArrayDeque<Triple<Int, Int, Int>>()  
        val visited = Array(table.size) { Array(table.first().size) { IntArray(wallBreakCount + 1) { -1 } } }  
        val direction = listOf(1 to 0, -1 to 0, 0 to 1, 0 to -1)  
  
        queue.addLast(Triple(startPoint.first, startPoint.second, 0))  
        visited[startPoint.first][startPoint.second][0] = 1  
  
  
  
        while (queue.isNotEmpty()) {  
            val (y, x, wallBreak) = queue.removeLast()  
  
            for ((moveY, moveX) in direction) {  
                val nextY = moveY + y  
                val nextX = moveX + x  
                if (nextY !in table.indices || nextX !in table.first().indices) continue  
  
                if (table[nextY][nextX] != 1 && visited[nextY][nextX][wallBreak] == -1) {  
                    queue.addLast(Triple(nextY, nextX, wallBreak))  
                    visited[nextY][nextX][wallBreak] = visited[y][x][wallBreak] + 1  
                }  
                else if (  
                    table[nextY][nextX] == 1 &&  
                    wallBreak < wallBreakCount &&  
                    visited[nextY][nextX][wallBreak + 1] == -1  
                ) {  
                    queue.addLast(Triple(nextY, nextX, wallBreak + 1))  
                    visited[nextY][nextX][wallBreak + 1] = visited[y][x][wallBreak] + 1  
                }  
            }  
        }  
  
  
        return visited[endPointY][endPointX].filter { it != -1 }.minOrNull() ?: -1  
    }  
}
```
