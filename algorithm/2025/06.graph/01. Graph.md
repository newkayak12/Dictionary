
### 1. 그래프
- node, edge로 구성된 구조
	- node(vertex) : 그래프에서 대상
	- edge: 정점 간의 연결

### 2. 그래프 종류
1. Directed Graph: 간선에 방향이 있음
2. Undirected Graph: 양방향 간선
3. Weighted Graph: 간선마다 비용이나 거리 등의 숫자 정보가 있다.
4. Unweighted Graph: 간선에 별도 숫자가 없다.

### 3. 그래프 표현 방식
1. Adjacency List
	1. 각 정점에 연결된 노드들을 리스트로 저장
	2. 공간 효율이 좋고, 연결된 노드만 확인 가능
	3. 일반적으로 많이 사용
2. Adjacency Matrix
	1. 정점 개수 만큼 2차원 매열로 표현
	2. 연결 여부를 빠르게 확인할 수 있으나, 메모리 사용이 많음
	3. 노드가 많을수록 비효율적

### 4. DFS(Depth-First Search)
- 깊이 우선 탐색
- 한 노드에서 가능한 한 깊에 들어감
- 더 이상 갈 수 없을 때만 되돌아가면서(backtracking) 다른 경로 탐색
- 보통 재귀 호출 혹은 스택으로 구현
- 미로 탐색, 조합 탐색, 경로 존재 확인에 사용
	- 방문 순서보다 깊이
	- 경로가 다양하거나, 전부 확인이 필요한 경우

#### 핵심 아이디어
- 한 방향으로 갈 수 있을 만큼 쭉 들어갔다가, 더 이상 갈 수 없으면 되돌아와서 다른 방향을 탐색하는 방식

#### 구현

- 재귀 기준
	1. 현재 노드 방문 처리
	2. 현재 노드에서 연결된 다른 노드 중 아직 방문하지 않은 곳이 있으면 다시 재귀  호출
	3. 이 과정을 반복하여 깊이 탐색
	4. 모든 노드가 방문되면 탐색 종료
- 필요한 구성 요소
	1. 그래프
	2. 방문 여부 배열
	3. DFS 함수
```kotlin
/**
 * ### **📌 설명**
 *
 *	- node: 현재 방문 중인 노드
 *	- graph: 인접 리스트 형태로 저장된 그래프
 *	- visited: 방문 여부를 저장하는 배열
 *    → 이 함수는 node부터 시작해서, **연결된 모든 노드를 깊이 우선적으로 방문**합니다.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // 인접 노드를 넣을 때, 순서 역순 주의
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- 너비 우선 탐색
- 한 노드에서 가까운 노드부터 탐색
- 보통 큐를 사용해서 구현
- 최단 거리를 구할 때 많이 사용
	- 방문 순서가 거리 중심
	- 최단 경로 문제에 적합

#### 핵심 아이디어
- 현재 노드에서 가까운 노드부터 먼저 탐색하고 그 다음 가까운 노드의 이웃들을 탐색해내가는 방식

#### 구현 
- 과정 
	1. 시작 노드를 큐에 넣고 방문 처리
	2.  큐에서 노드를 꺼내고 해당 노드와 연결된 노드들 중 아직 방문하지 않은 노드들을 큐에 넣음
	3. 큐가 빌 때까지 위의 과정을 반복
- 필요한 구성 요소 
	- 그래프
	- 방문 배열
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```