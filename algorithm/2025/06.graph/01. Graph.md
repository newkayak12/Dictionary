
### 1. 그래프
- node, edge로 구성된 구조
	- node(vertex) : 그래프에서 대상
	- edge: 정점 간의 연결

### 2. 그래프 종류
1. Directed Graph: 간선에 방향이 있음
2. Undirected Graph: 양방향 간선
3. Weighted Graph: 간선마다 비용이나 거리 등의 숫자 정보가 있다.
4. Unweighted Graph: 간선에 별도 숫자가 없다.

### 3. 그래프 표현 방식
1. Adjacency List
	1. 각 정점에 연결된 노드들을 리스트로 저장
	2. 공간 효율이 좋고, 연결된 노드만 확인 가능
	3. 일반적으로 많이 사용
2. Adjacency Matrix
	1. 정점 개수 만큼 2차원 매열로 표현
	2. 연결 여부를 빠르게 확인할 수 있으나, 메모리 사용이 많음
	3. 노드가 많을수록 비효율적

### 4. DFS(Depth-First Search)
- 깊이 우선 탐색
- 한 노드에서 가능한 한 깊에 들어감
- 더 이상 갈 수 없을 때만 되돌아가면서(backtracking) 다른 경로 탐색
- 보통 재귀 호출 혹은 스택으로 구현
- 미로 탐색, 조합 탐색, 경로 존재 확인에 사용
	- 방문 순서보다 깊이
	- 경로가 다양하거나, 전부 확인이 필요한 경우

#### 핵심 아이디어
- 한 방향으로 갈 수 있을 만큼 쭉 들어갔다가, 더 이상 갈 수 없으면 되돌아와서 다른 방향을 탐색하는 방식

#### 구현

- 재귀 기준
	1. 현재 노드 방문 처리
	2. 현재 노드에서 연결된 다른 노드 중 아직 방문하지 않은 곳이 있으면 다시 재귀  호출
	3. 이 과정을 반복하여 깊이 탐색
	4. 모든 노드가 방문되면 탐색 종료
- 필요한 구성 요소
	1. 그래프
	2. 방문 여부 배열
	3. DFS 함수
```kotlin
/**
 * ### **📌 설명**
 *
 *	- node: 현재 방문 중인 노드
 *	- graph: 인접 리스트 형태로 저장된 그래프
 *	- visited: 방문 여부를 저장하는 배열
 *    → 이 함수는 node부터 시작해서, **연결된 모든 노드를 깊이 우선적으로 방문**합니다.
 */

fun dfs(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    if (visited[node]) return

    visited[node] = true

    for (next in graph[node]) {
        if (!visited[next]) {
            dfs(next, graph, visited)
        }
    }
}
```
```kotlin
import java.util.*

fun dfsStack(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val stack = Stack<Int>()
    stack.push(start)

    while (stack.isNotEmpty()) {
        val node = stack.pop()

        if (!visited[node]) {
            visited[node] = true

            // 인접 노드를 넣을 때, 순서 역순 주의
            for (next in graph[node].reversed()) {
                if (!visited[next]) {
                    stack.push(next)
                }
            }
        }
    }
}
```

### 5. BFS(Breadth-First Search)
- 너비 우선 탐색
- 한 노드에서 가까운 노드부터 탐색
- 보통 큐를 사용해서 구현
- 최단 거리를 구할 때 많이 사용
	- 방문 순서가 거리 중심
	- 최단 경로 문제에 적합

#### 핵심 아이디어
- 현재 노드에서 가까운 노드부터 먼저 탐색하고 그 다음 가까운 노드의 이웃들을 탐색해내가는 방식

#### 구현 
- 과정 
	1. 시작 노드를 큐에 넣고 방문 처리
	2.  큐에서 노드를 꺼내고 해당 노드와 연결된 노드들 중 아직 방문하지 않은 노드들을 큐에 넣음
	3. 큐가 빌 때까지 위의 과정을 반복
- 필요한 구성 요소 
	- 그래프
	- 방문 배열
	- queue

```kotlin
import java.util.*

fun bfs(start: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {
    val queue: Queue<Int> = LinkedList()
    queue.add(start)
    visited[start] = true

    while (queue.isNotEmpty()) {
        val current = queue.poll()

        for (next in graph[current]) {
            if (!visited[next]) {
                visited[next] = true
                queue.add(next)
            }
        }
    }
}
```

### DFS 예시 문제
1) 연결성 확인
```kotlin
class Connectivity {  
    /**  
     * 문제 1. 연결 요소의 개수  
     *  
     * 설명  
     *  
     * 하나의 무방향 그래프가 주어졌을 때, 이 그래프에서 연결 요소가 몇 개인지 구하세요.  
     * 연결 요소란, 노드들끼리 서로 도달 가능한 그룹을 말합니다.  
     *    
     * 입력  
     *  •  첫 줄에 정점의 개수 N (1 ≤ N ≤ 1,000)과 간선의 개수 M (0 ≤ M ≤ N×(N-1)/2)이 주어집니다.  
     *  •  다음 줄부터 M개의 줄에 걸쳐 두 정점 u, v가 주어집니다. 이는 정점 u와 v가 연결되어 있다는 의미입니다.  
     *    
     * 출력  
     *  •  연결 요소의 개수를 한 줄에 출력하세요.  
     *     
     * 예시 입력  
     * 6 5  
     *    
     * 1 2     
     * 2 5    
     * 5 1     
     * 3 4     
     * 4 6    
     *    
     * 예시 출력  
     * 2  //(1,2,5) (3,4,6) -> 두 덩어리 
     *    
     *     
     * 1. 정점  
     * [1, 2, 3, 4, 5, 6]  
     * 2. 간선  
     * [(1,2), (2,5), (5,1), (3,4), (4,6)]  
     *    
     * 3. 방법?  
     * 1. DFS/BFS -> DFS (모든 노드를 돌면서 확인)  
     *     
     * 2. DisjointSetUnion
     */  
    @Test  
    fun solution() {  
        val vertex = 6  
        val edge = 5  
  
        val table = arrayOf(  
            intArrayOf(1, 2),  
            intArrayOf(2, 5),  
            intArrayOf(5, 1),  
            intArrayOf(3, 4),  
            intArrayOf(4, 6),  
        )  
        val expected = 2  
        assertEquals(expected, useStack(vertex, edge, table))  
        assertEquals(expected, useRecursive(vertex, edge, table))  
        assertEquals(expected, useDisjointSetUnion(vertex, edge, table))
    }  
  
    private fun useStack(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val stack = Stack<Int>()  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
            if(!visited[i]) {  
                stack.add(i)  
                visited[i] = true  
                count += 1  
            }  
  
            while(stack.isNotEmpty()) {  
                val node = stack.pop()  
                for(next in graph[node].reversed()) {  
                    if(!visited[next]) {  
                        stack.add(next)  
                        visited[next] = true  
                    }  
                }  
            }  
        }  
  
        return count  
    }  
  
    private fun useRecursive(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
        val graph = Array(vertex + 1) { mutableListOf<Int>() }  
        for (element in table) {  
            val u = element[0]  
            val v = element[1]  
  
            graph[u].add(v)  
            graph[v].add(u)  
        }  
  
        val visited = BooleanArray(vertex + 1)  
        var count = 0  
  
  
        for (i in 1 .. vertex) {  
           if(!visited[i]) {  
               count ++  
               recursive(i, graph, visited)  
           }  
        }  
  
        return count  
    }  
  
    private fun recursive(node: Int, graph: Array<MutableList<Int>>, visited: BooleanArray) {  
        visited[node] = true  
  
        for(next in graph[node].reversed()) {  
            if(!visited[next]) {  
                recursive(next, graph, visited)  
            }  
        }  
    }  
   
	private fun useDisjointSetUnion(vertex: Int, edge: Int, table: Array<IntArray>): Int {  
	    val dsu = DisjointSetUnion(vertex + 1)  
	    for( (a,b) in table) { dsu.union(a,b) }  
	  
	  
	    val rootSet = mutableSetOf<Int>()  
	    for ( node in 1 .. vertex) {  
	        rootSet.add(dsu.find(node))  
	    }  
	  
	    return rootSet.size  
	}  
	  
	inner class DisjointSetUnion(size: Int) {  
	    private val parents = IntArray(size) { it }  
	    private val ranking = IntArray(size) { 0 }  
	  
	  
	    fun find(x: Int): Int {  
	        if (x != parents[x]) {  
	            parents[x] = find(parents[x])  
	        }  
	        return parents[x]  
	    }  
	  
	    fun union(a: Int, b: Int): Boolean {  
	  
	        val rootA = find(a)  
	        val rootB = find(b)  
	  
	        if (rootA == rootB) return false  
	  
	        if( rootA > rootB ) {  
	            parents[rootB] = rootA  
	        }  
	        else if( rootA < rootB) {  
	            parents[rootA] = rootB  
	        }  
	        else {  
	            parents[rootB] = rootA  
	            ranking[rootA] ++  
	        }  
	  
	        return true  
	    }  
	}
}
```