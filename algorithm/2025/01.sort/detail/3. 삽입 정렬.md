### 흐름
0. 왼쪽에서 오른쪽으로 갈수록 작은 수에서 큰 수가 되는 것을 목표로 한다.
1. 첫 번째 인덱스부터 마지막 인덱스까지 순회하면서 진행한다.
2. 현재 인덱스 대비 앞쪽의 인덱스들과 비교하면서 진행한다.
	1. 만약 현재 인덱스 대비 앞쪽 인덱스의 값이 더 크면 그 인덱스의 값을 한 칸 뒤로 미룬다.
	2. 다시 그 앞 인덱스로 가서 현재 인덱스 대비 앞쪽 인덱스의 값이 더 크면 그 인덱스의 값을 한 칸 미룬다.
	3. 맨 앞으로 갈 때까지 진행한다.
	4. 현재 인덱스의 값을 마지막으로 미룬 인덱스에 넣는다.
3. 이전과 같이 swap(변경)을 매 번하는 것이 아니라. 값을 뒤로 미루는 개념이다.
4. 앞부분은 항상 정렬된 상태를 유지한다.
5. 삽입 위치를 찾기 위해서 계속 선형 탐색을 지속한다.

> ## 요약
> - 외부 순환, 내부 순환이 있다.
> - 외부의 값을 지정하고 내부의 값보다 크면 내부에서 한 단계씩 앞으로 밀어내는 식이다.
> - 결과적으로 내, 외부 값의 비교가 끝나면 외부의 지정한 값은 올바른 곳으로 삽입한다.

```kotlin
class InsertionSort {
    /**
     *
     *  ```
     *  [5, 4, 10, 2, 8, 6] : origin
     * 	[4, 5, 10, 2, 8, 6] : 1회전
     * 	[4, 5, 10, 2, 8, 6] : 2회전
     * 	[2, 4, 5, 10, 8, 6] : 3회전
     * 	[2, 4, 5, 8, 10, 6] : 4회전
     * 	[2, 4, 5, 6, 8, 10] : 5회전
     *```
     * - 배열을 왼쪽부터 차례로 순회하며, 각 원소를 앞쪽 정렬된 부분 배열에 **“삽입”**해나가는 방식의 정렬.
     * - 앞쪽은 항상 정렬되어 있다는 가정 하에, 현재 원소가 들어갈 위치를 찾아 끼워넣음.
     * - 정렬된 영역을 유지하면서 점진적으로 전체 배열을 정렬시킴.
     */
    @Test
    fun sort() {
        val list = giveMeArray()
        val expected = list.sorted().toIntArray()
        val array = list.toIntArray()



        for (i in 1 until array.size) {
            val temp = array[i]
            var j = i - 1
            //현재 인덱스 i
            //탐색 시작해야 할 인덱스 i - 1

			//j >= 0으로 인덱스 오류 방어
			//만약 현재 인덱스 값보다 탐색 인덱스의 값이 크면
            while (j >= 0 && array[j] > temp) {
                array[j + 1] = array[j]
                // 밀어낸다.(swap이 아니다.)
                j--
                //계속 탐색
            }
            
            //이 시점 j는 이미 정렬된 마지막의 인덱스 값이 된다(--)
            //현재 인덱스 값을 삽입해준다.
            array[j + 1] = temp
        }

        assertArrayEquals(expected, array)
    }
}
```
