# ì •ë ¬
- ë²„ë¸” ì •ë ¬ (Bubble Sort)
> - ê°œë…: ì¸ì ‘í•œ ë‘ ì›ì†Œë¥¼ ë¹„êµí•´ í° ê°’ì„ ë’¤ë¡œ ë³´ë‚´ëŠ” ë°©ì‹. ì—¬ëŸ¬ íšŒì „ì„ ë°˜ë³µ.
> - íŠ¹ì§•: ë‹¨ìˆœí•˜ì§€ë§Œ ëŠë¦¼ (O(nÂ²)), ê±°ì˜ ì •ë ¬ëœ ê²½ìš° íš¨ìœ¨ì .
> - ë¹„êµ ê¸°ë°˜ âœ…

- ì„ íƒ ì •ë ¬ (Selection Sort)
> - ê°œë…: ê°€ì¥ ì‘ì€(ë˜ëŠ” í°) ê°’ì„ ì°¾ì•„ ë§¨ ì•(ë˜ëŠ” ë’¤)ê³¼ êµí™˜.
> - íŠ¹ì§•: êµí™˜ íšŸìˆ˜ëŠ” ì ìœ¼ë‚˜ ë¹„êµ íšŸìˆ˜ëŠ” ë§ìŒ. (O(nÂ²))
> - ë¹„êµ ê¸°ë°˜ âœ…

- ì‚½ì… ì •ë ¬ (Insertion Sort)
> - ê°œë…: ì•ì—ì„œë¶€í„° ì •ë ¬ëœ ìƒíƒœë¥¼ ìœ ì§€í•˜ë©° ì ì ˆí•œ ìœ„ì¹˜ì— ì‚½ì….
> - íŠ¹ì§•: ê±°ì˜ ì •ë ¬ëœ ë°°ì—´ì— íš¨ìœ¨ì . (ìµœì„  O(n), í‰ê·  O(nÂ²))
> - ë¹„êµ ê¸°ë°˜ âœ…

- ì…¸ ì •ë ¬ (Shell Sort)
> - ê°œë…: ì¼ì • ê°„ê²©ìœ¼ë¡œ ë–¨ì–´ì§„ ìš”ì†Œë“¤ì„ ì‚½ì… ì •ë ¬í•˜ì—¬ ê°„ê²©ì„ ì¤„ì—¬ê°.
> - íŠ¹ì§•: ì‚½ì… ì •ë ¬ ê°œì„ . ì‹œê°„ ë³µì¡ë„ëŠ” gap ì „ëµì— ë”°ë¼ ë‹¤ë¦„.
> - n/2...: (í‰ê·  O(n^1.5), ìµœì•… O(nÂ²))
> - ë¹„êµ ê¸°ë°˜ âœ…

- ë³‘í•© ì •ë ¬ (Merge Sort)
> - ê°œë…: ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë‚˜ëˆ  ê°ê° ì •ë ¬ í›„ ë³‘í•©.
> - íŠ¹ì§•: ì•ˆì • ì •ë ¬, O(n log n), ì¶”ê°€ ê³µê°„ í•„ìš”.
> - ë¹„êµ ê¸°ë°˜ âœ…

- í€µ ì •ë ¬ (Quick Sort)
> - ê°œë…: ê¸°ì¤€ ê°’(pivot)ì„ ì •í•˜ê³ , ì‘ì€ ê°’ê³¼ í° ê°’ìœ¼ë¡œ ë¶„í•  í›„ ì¬ê·€.
> - íŠ¹ì§•: í‰ê·  O(n log n), ìµœì•… O(nÂ²), ì œìë¦¬ ì •ë ¬.
> - ë¹„êµ ê¸°ë°˜ âœ…

- í™ ì •ë ¬ (Heap Sort)
> - ê°œë…: ìµœëŒ€ í™ ë˜ëŠ” ìµœì†Œ í™ì„ êµ¬ì„± í›„ ìš”ì†Œ ì œê±°í•˜ë©° ì •ë ¬.
> - íŠ¹ì§•: O(n log n), ì•ˆì •ì ì´ì§€ ì•ŠìŒ.
> - ë¹„êµ ê¸°ë°˜ âœ…

- ê¸°ìˆ˜ ì •ë ¬ (Radix Sort)
> - ê°œë…: ê° ìë¦¿ìˆ˜ ê¸°ì¤€ìœ¼ë¡œ ì—¬ëŸ¬ ë²ˆ ì •ë ¬ (ë³´í†µ LSD ë°©ì‹).
> - íŠ¹ì§•: ìˆ«ìì— ì í•©, O(kÂ·n), ì•ˆì • ì •ë ¬.
> - ë¹„êµ ê¸°ë°˜ âŒ



> ## ì•ˆì • ì •ë ¬ vs. ë¶ˆì•ˆì • ì •ë ¬
> - ì¤‘ë³µëœ ê°’ì˜ ìˆœì„œ ë³´ì¥ ì—¬ë¶€ì— ë”°ë¼ì„œ
>   - ìˆœì„œê°€ ë³´ì¥ë˜ë©´ ì•ˆì • ì •ë ¬ì´ë‹¤.
>   - ìˆœì„œê°€ ë³´ì¥ë˜ì§€ ì•Šìœ¼ë©´ ë¶ˆì•ˆì • ì •ë ¬ì´ë‹¤.

------------------

## 1. ë²„ë¸” ì •ë ¬

â–¸ ì‹œì‘ ìƒíƒœ
[5, 4, 10, 2, 8, 6]
â¸»
ğŸ” 1íšŒì „ (ì „ì²´ ë¹„êµ)
â€¢	5 > 4 â†’ swap â†’ [4, 5, 10, 2, 8, 6]
â€¢	5 < 10 â†’ ê·¸ëŒ€ë¡œ
â€¢	10 > 2 â†’ swap â†’ [4, 5, 2, 10, 8, 6]
â€¢	10 > 8 â†’ swap â†’ [4, 5, 2, 8, 10, 6]
â€¢	10 > 6 â†’ swap â†’ [4, 5, 2, 8, 6, 10]

âœ… ê°€ì¥ í° ê°’ 10ì´ ë§¨ ë’¤ë¡œ
â¸»
ğŸ” 2íšŒì „ (ì• ~ 4ê¹Œì§€)
â€¢	4 < 5 â†’ ê·¸ëŒ€ë¡œ
â€¢	5 > 2 â†’ swap â†’ [4, 2, 5, 8, 6, 10]
â€¢	5 < 8 â†’ ê·¸ëŒ€ë¡œ
â€¢	8 > 6 â†’ swap â†’ [4, 2, 5, 6, 8, 10]

âœ… ë‘ ë²ˆì§¸ í° ê°’ 8 ì •ìœ„ì¹˜
â¸»
ğŸ” 3íšŒì „ (ì• ~ 3ê¹Œì§€)
â€¢	4 > 2 â†’ swap â†’ [2, 4, 5, 6, 8, 10]
â€¢	4 < 5 â†’ ê·¸ëŒ€ë¡œ
â€¢	5 < 6 â†’ ê·¸ëŒ€ë¡œ
â¸»
ğŸ” 4íšŒì „ (ì• ~ 2ê¹Œì§€)
â€¢	2 < 4, 4 < 5 â†’ ê·¸ëŒ€ë¡œ
â¸»
ğŸ” 5íšŒì „ (ì• ~ 1ê¹Œì§€)
â€¢	2 < 4 â†’ ê·¸ëŒ€ë¡œ
â¸»
âœ… ìµœì¢… ê²°ê³¼
[2, 4, 5, 6, 8, 10]

```kotlin
class BubbleSort {
    /**
     * 5, 4, 10, 2, 8, 6 : origin
     * 4, 5, 2, 8, 6, 10 : 1íšŒì „
     * 4, 2, 5, 6, 8, 10 : 2íšŒì „
     * 2, 4, 5, 6, 8, 10 : 3íšŒì „
     */
    @Test
    fun `sort`() {
        val list = giveMeArray()
        val expected = list.sorted().toIntArray()
        val array = list.toIntArray()

        for (i in 0 until array.size - 1) {
            for (j in 0 until array.size - 1 - i) {
                if (array[j] > array[j + 1]) {
                // í° ê°’ì„ ë’¤ë¡œ
                    val temp = array[j]
                    array[j] = array[j + 1]
                    array[j + 1] = temp
                }
            }
        }
        println("before: ${expected.contentToString()}")
        println("after: ${array.contentToString()}")
        assertArrayEquals(expected, array)
    }

}
```

-----------------------------

## 2. ì„ íƒ ì •ë ¬

â–¸ ì‹œì‘ ìƒíƒœ
[5, 4, 10, 2, 8, 6]
â¸»
ğŸ” 1íšŒì „ (i = 0)
â€¢	ì „ì²´ êµ¬ê°„: [5, 4, 10, 2, 8, 6]
â€¢	ìµœì†Œê°’: 2 at index 3
â€¢	5 <-> 2 êµí™˜
â€¢	ê²°ê³¼: [2, 4, 10, 5, 8, 6]
â¸»
ğŸ” 2íšŒì „ (i = 1)
â€¢	ë‚¨ì€ êµ¬ê°„: [4, 10, 5, 8, 6]
â€¢	ìµœì†Œê°’: 4 â†’ ìœ„ì¹˜ ê·¸ëŒ€ë¡œ
â€¢	ê²°ê³¼: [2, 4, 10, 5, 8, 6]
â¸»
ğŸ” 3íšŒì „ (i = 2)
â€¢	ë‚¨ì€ êµ¬ê°„: [10, 5, 8, 6]
â€¢	ìµœì†Œê°’: 5 at index 3
â€¢	10 <-> 5 êµí™˜
â€¢	ê²°ê³¼: [2, 4, 5, 10, 8, 6]
â¸»
ğŸ” 4íšŒì „ (i = 3)
â€¢	ë‚¨ì€ êµ¬ê°„: [10, 8, 6]
â€¢	ìµœì†Œê°’: 6 at index 5
â€¢	10 <-> 6 êµí™˜
â€¢	ê²°ê³¼: [2, 4, 5, 6, 8, 10]
â¸»
ğŸ” 5íšŒì „ (i = 4)
â€¢	ë‚¨ì€ êµ¬ê°„: [8, 10]
â€¢	ìµœì†Œê°’: 8 â†’ ìœ„ì¹˜ ê·¸ëŒ€ë¡œ
â€¢	ê²°ê³¼: [2, 4, 5, 6, 8, 10]
â¸»
ğŸ” 6íšŒì „ (i = 5)
â€¢	ë§ˆì§€ë§‰ ìš”ì†Œ â†’ ë” ì´ìƒ ë¹„êµ ì—†ìŒ
â¸»
âœ… ìµœì¢… ì •ë ¬ ì™„ë£Œ
[2, 4, 5, 6, 8, 10]

```kotlin
class SelectionSort {

    /**
     *  [5, 4, 10, 2, 8, 6] : origin
     * 	[2, 4, 10, 5, 8, 6] : 1íšŒì „
     * 	[2, 4, 10, 5, 8, 6] : 2íšŒì „
     * 	[2, 4, 5, 10, 8, 6] : 3íšŒì „
     * 	[2, 4, 5, 6, 8, 10] : 4íšŒì „
     * 	[2, 4, 5, 6, 8, 10] : 5íšŒì „
     */
    @Test
    fun sort() {
        val list = giveMeArray()
        val expected = list.sorted().toIntArray()
        val array = list.toIntArray()

        for( i in 0 until array.size - 1) {
            var minimumIndex = i
            for(j in i + 1  until array.size) {
                if(array[minimumIndex] > array[j]) {
                    minimumIndex = j
                    // ê°€ì¥ ì‘ì€ ê²ƒì„ ì•ìœ¼ë¡œ
                }
            }
            val swap = array[i]
            array[i] = array[minimumIndex]
            array[minimumIndex] = swap
        }

        assertArrayEquals(expected, array)
    }
}
```

--------------------------------

## 3. ì‚½ì… ì •ë ¬

> ì‹œê°„ ë³µì¡ë„
> - ìµœì„ :  O(n) -> ì´ë¯¸ ì •ë ¬
> - í‰ê· /ìµœì•…:  O(nÂ²)) -> ì—­ì •ë ¬ -> ê° ì›ì†Œë¥¼ ì•ìª½ ì •ë ¬ëœ ì˜ì—­ì— í•œ ì¹¸ì”© ë¹„êµí•˜ë©´ì„œ ë¼ì›Œ ë„£ìŒ

â–¸ ì‹œì‘ ìƒíƒœ
[5, 4, 10, 2, 8, 6]
(ì •ë ¬ëœ ë¶€ë¶„ ì—†ìŒ â†’ ì²« ì›ì†Œë§Œ ì •ë ¬ë˜ì—ˆë‹¤ê³  ê°€ì •í•˜ê³  ì‹œì‘)
â¸»
ğŸ” 1íšŒì „ (i = 1, ê°’: 4)
â€¢	ì •ë ¬ êµ¬ê°„: [5]
â€¢	4 < 5 â†’ 5ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë°€ê³ , 4ë¥¼ ì‚½ì…
â€¢	ê²°ê³¼: [4, 5, 10, 2, 8, 6]
â¸»
ğŸ” 2íšŒì „ (i = 2, ê°’: 10)
â€¢	ì •ë ¬ êµ¬ê°„: [4, 5]
â€¢	10 > 5 â†’ ê·¸ëŒ€ë¡œ ìœ ì§€
â€¢	ê²°ê³¼: [4, 5, 10, 2, 8, 6]
â¸»
ğŸ” 3íšŒì „ (i = 3, ê°’: 2)
â€¢	ì •ë ¬ êµ¬ê°„: [4, 5, 10]
â€¢	ë¹„êµ: 2 < 10 â†’ ë°€ê¸°, 2 < 5 â†’ ë°€ê¸°, 2 < 4 â†’ ë°€ê¸°
â€¢	ì‚½ì… ìœ„ì¹˜: ì¸ë±ìŠ¤ 0
â€¢	ê²°ê³¼: [2, 4, 5, 10, 8, 6]
â¸»
ğŸ” 4íšŒì „ (i = 4, ê°’: 8)
â€¢	ì •ë ¬ êµ¬ê°„: [2, 4, 5, 10]
â€¢	ë¹„êµ: 8 < 10 â†’ ë°€ê¸°, 8 > 5 â†’ ì‚½ì…
â€¢	ê²°ê³¼: [2, 4, 5, 8, 10, 6]
â¸»
ğŸ” 5íšŒì „ (i = 5, ê°’: 6)
â€¢	ì •ë ¬ êµ¬ê°„: [2, 4, 5, 8, 10]
â€¢	ë¹„êµ: 6 < 10 â†’ ë°€ê¸°, 6 < 8 â†’ ë°€ê¸°, 6 > 5 â†’ ì‚½ì…
â€¢	ê²°ê³¼: [2, 4, 5, 6, 8, 10]

```kotlin
class InsertionSort {
    /**
     *
     *  ```
     *  [5, 4, 10, 2, 8, 6] : origin
     * 	[4, 5, 10, 2, 8, 6] : 1íšŒì „
     * 	[4, 5, 10, 2, 8, 6] : 2íšŒì „
     * 	[2, 4, 5, 10, 8, 6] : 3íšŒì „
     * 	[2, 4, 5, 8, 10, 6] : 4íšŒì „
     * 	[2, 4, 5, 6, 8, 10] : 5íšŒì „
     *```
     * - ë°°ì—´ì„ ì™¼ìª½ë¶€í„° ì°¨ë¡€ë¡œ ìˆœíšŒí•˜ë©°, ê° ì›ì†Œë¥¼ ì•ìª½ ì •ë ¬ëœ ë¶€ë¶„ ë°°ì—´ì— **â€œì‚½ì…â€**í•´ë‚˜ê°€ëŠ” ë°©ì‹ì˜ ì •ë ¬.
     * - ì•ìª½ì€ í•­ìƒ ì •ë ¬ë˜ì–´ ìˆë‹¤ëŠ” ê°€ì • í•˜ì—, í˜„ì¬ ì›ì†Œê°€ ë“¤ì–´ê°ˆ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ë¼ì›Œë„£ìŒ.
     * - ì •ë ¬ëœ ì˜ì—­ì„ ìœ ì§€í•˜ë©´ì„œ ì ì§„ì ìœ¼ë¡œ ì „ì²´ ë°°ì—´ì„ ì •ë ¬ì‹œí‚´.
     */
    @Test
    fun sort() {
        val list = giveMeArray()
        val expected = list.sorted().toIntArray()
        val array = list.toIntArray()



        for (i in 1 until array.size) {
            val temp = array[i]
            var j = i - 1
            while (j >= 0 && array[j] > temp) {
                array[j + 1] = array[j]
                // swapì´ ì•„ë‹˜
                j--
            }
            //ì´ ì‹œì  jëŠ” ì´ë¯¸ ì •ë ¬ëœ ë§ˆì§€ë§‰ì˜ ì¸ë±ìŠ¤ ê°’ì´ ëœë‹¤(--)
            array[j + 1] = temp
        }

        assertArrayEquals(expected, array)
    }
}
```

## 4. ì…¸ ì •ë ¬

> ### ì‚½ì… ì •ë ¬ì˜ êµ¬ì¡°ì  í•œê³„
> 
> - ì‚½ì… ì •ë ¬ì€ í•œ ì¹¸ì”©ë§Œ ë¹„êµ
> - ë§Œì•½ ê°€ì¥ ì‘ì€ ê°’ì´ ë§¨ ë’¤ì— ìˆë‹¤ë©´ ëª¨ë“  ìš”ì†Œë¥¼ í•˜ë‚˜ì”© ë‹¤ ì˜®ê²¨ì•¼ í•œë‹¤.
>   [ 9, 8, 7, 6, 5]ì˜ ê²½ìš° 5ëŠ” 4ë²ˆì´ë‚˜ ì´ë™í•´ì•¼ í•œë‹¤.
>  
> ### Shell ì •ë ¬ì˜ ê°œì„  ë°©ë²•
> - ë©€ë¦¬ ë–¨ì–´ì§„ ìš”ì†Œë“¤ë¼ë¦¬ ë¨¼ì € ì •ë ¬ -> ë¹ ë¥¸ í° ì´ë™ ê°€ëŠ¥
> - ëª©ì ì€ í¬ê²Œ ì–´ê¸‹ë‚œ ê°’ì„ ë¹¨ë¦¬ ì œìë¦¬ ê·¼ì²˜ë¡œ ì˜®ê¸°ëŠ” ê²ƒì´ë‹¤.
> - ê²°ê³¼ì ìœ¼ë¡œëŠ” í•œ ì¹¸ì”© ë¹„êµ -> ì´ë¯¸ ê±°ì˜ ì •ë ¬ëœ ìƒíƒœ -> íš¨ìœ¨ â†‘
> - ë¹„êµì™€ ì´ë™ íšŸìˆ˜ê°€ ê°ì†Œ
> 	- **O(log n)** = â€œë§¤ë²ˆ ì ˆë°˜ìœ¼ë¡œ ì¤„ì´ë©´ì„œ ì²˜ë¦¬â€í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
> 	- **O(n log n)** = â€œnê°œì˜ ì›ì†Œë¥¼ log në‹¨ê³„ ë™ì•ˆ ë°˜ë³µì ìœ¼ë¡œ ì²˜ë¦¬â€í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ 
 
|   í•­ëª©   |  ì‚½ì… ì •ë ¬   |            ì…¸ ì •ë ¬            |
| :----: | :------: | :------------------------: |
| ë¹„êµ ëŒ€ìƒ  |  ì¸ì ‘í•œ ìš”ì†Œ  |      gap ê°„ê²©ë§Œí¼ ë–¨ì–´ì§„ ìš”ì†Œ       |
| ì‹œê°„ ë³µì¡ë„ |  O(nÂ²)   | í‰ê·  O(n log n), gapì— ë”°ë¼ì„œ ë³€ë™ |
| ê°œì„  ëª©í‘œ  | ëŠë¦° ì´ë™ ì†ë„ |       ë¹ ë¥¸ ì •ë ¬ -> ì‚½ì… ì •ë ¬       |

```kotlin
class ShellSort {  
  
  
    /**  
     * ```     
     *  [5, 4, 10, 2, 8, 6] : origin
     *  âœ… Gap = 3     
     *  â€¢  ê·¸ë£¹1: [5, 2] â†’ ì •ë ¬ í›„ [2, 4, 10, 5, 8, 6]    
     *  â€¢  ê·¸ë£¹2: [4, 8] â†’ ì •ë ¬ í›„ [2, 4, 10, 5, 8, 6] (ì´ë¯¸ ì •ë ¬ë¨)  
     *  â€¢  ê·¸ë£¹3: [10, 6] â†’ ì •ë ¬ í›„ [2, 4, 6, 5, 8, 10]  
     *  â†’ âœ… ê²°ê³¼ after gap=3: [2, 4, 6, 5, 8, 10]    
     *     *  âœ… Gap = 1 (ë§ˆì§€ë§‰ ì‚½ì… ì •ë ¬ ë‹¨ê³„)  
     *  â€¢  ì‚½ì… ì •ë ¬ì²˜ëŸ¼ í•œ ì¹¸ì”© ë¹„êµí•˜ë©´ì„œ ì •ë ¬  
     *  â†’ [2, 4, 6, 5, 8, 10]  
     *  â†’ [2, 4, 5, 6, 8, 10]   
     *     *  âœ… ìµœì¢… ê²°ê³¼  
     *  [2, 4, 5, 6, 8, 10]  
     *  ```     
     */
     
    @Test  
    fun sort() {  
        val list = giveMeArray()  
        val expected = list.sorted().toIntArray()  
        val array = list.toIntArray()  
        var gap = array.size / 2  
  
        while (gap > 0) {  
            for( i in gap until array.size) {  
                val temp = array[i]  
                var j = i - gap  
                while(j >= 0 && array[j] > temp) {  
                    array[j + gap] = array[j]  
                    j -= gap  
                }  
                array[j + gap] = temp  
            }  
            gap /= 2  
        }  
  
        assertArrayEquals(expected, array)  
    }  
}
```

## 5. ë³‘í•© ì •ë ¬
- ë¶„í•  ì •ë³µ(Divide and Conquer) ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜
- ë°°ì—´ì„ ë°˜ì”© ë‚˜ëˆ ì„œ ì¬ê·€ì ìœ¼ë¡œ ë¶„í• í•˜ê³ , ë‹¤ì‹œ ì •ë ¬ëœ ìƒíƒœë¡œ ë³‘í•©í•˜ì—¬ ì „ì²´ë¥¼ ì •ë ¬
- ì‹œê°„ ë³µì¡ë„ëŠ” í•­ìƒ O(n log n)
	- ë¶„í• ì€ ë‹¨ìˆœíˆ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê¸°ë§Œ í•œë‹¤. -> log n ê¹Šì´ì˜ íŠ¸ë¦¬ ìƒì„±
	- ë³‘í•©ì€ ë‘ ì •ë ¬ëœ ë°°ì—´ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸°ì— O(n)
	- ì •ë ¬ì€ ë³‘í•©ì—ì„œë§Œ ì¼ì–´ë‚œë‹¤. 
		- ì¤‘ê°„ ë°°ì—´ì— ìˆœì„œëŒ€ë¡œ ë°€ì–´ ë„£ê³  ì¤‘ê°„ ë°°ì—´ì„ ëŒ€ì¹˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì •ë ¬í•œë‹¤.

```kotlin
class MergeSort {  
    /**  
     * ``` 
     *  [5, 4, 10, 2, 8, 6] : origin
     *  [5,4,10] | [2,8,6] : ë¶„í•   
     *  [5,4] [10] | [2,8] [6] : ë¶„í•   
     *  [4,5] [10] | [2,8] [6] : ë³‘í•©1  
     *  [4,5,10] | [2,6,8] : ë³‘í•©2  
     *  [2,4,5,6,8,10] : ë³‘í•©3  
     *```
     */
       
    data class Container(  
        val start: Int,  
        val end: Int,  
        val needToMerge: Boolean  
    ) {  
  
    }  
    @Test  
    fun sortUseStack() {  
        val list = giveMeArray()  
        val expected = list.sorted().toIntArray()  
        val array = list.toIntArray()  
        val stack = Stack<Container>()  
        stack.push(Container(0, array.size - 1, false))  
  
  
        while (stack.isNotEmpty()) {  
            val (start, end, needToMerge) = stack.pop()  
  
            if (needToMerge) {  
                val mid = (start + end) / 2  
                val tempArray = mutableListOf<Int>()  
                var i = start  
                var j = mid + 1  
  
                //  â€¢  array[start..mid]ì™€ array[mid+1..end]ëŠ” ì´ë¯¸ ì •ë ¬ëœ ìƒíƒœ  
                //  â€¢  ì´ ë‘ êµ¬ê°„ì„ í•˜ë‚˜ì˜ ì •ë ¬ëœ êµ¬ê°„ [start..end]ë¡œ ë§Œë“¤ê¸° ìœ„í•¨  
                while (i <= mid && j <= end) {  
                    if (array[i] <= array[j]) tempArray.add(array[i++])  
                    else tempArray.add(array[j++])  
  
                    //  â€¢  ì™¼ìª½ í¬ì¸í„° iëŠ” startë¶€í„°, ì˜¤ë¥¸ìª½ í¬ì¸í„° jëŠ” mid+1ë¶€í„° ì‹œì‘  
                    //  â€¢  ë‘ ê°’ì„ ë¹„êµí•´ ë” ì‘ì€ ê°’ì„ temp ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€  
                    //  â€¢  ì¶”ê°€í•œ ìª½ì˜ í¬ì¸í„°ë¥¼ í•˜ë‚˜ ì¦ê°€ì‹œí‚´  
                    //  â€¢  ì´ ê³¼ì •ì„ ë‘ í¬ì¸í„° ì¤‘ í•˜ë‚˜ê°€ ëë‚  ë•Œê¹Œì§€ ë°˜ë³µ  
                }  
                while (i <= mid) tempArray.add(array[i++])  
                //  ì™¼ìª½ êµ¬ê°„ì— ê°’ì´ ë‚¨ì€ ê²½ìš°, ë‚¨ì€ ê°’ì„ ì „ë¶€ tempì— ì¶”ê°€  
                while (j <= end) tempArray.add(array[j++])  
                //ì˜¤ë¥¸ìª½ êµ¬ê°„ì— ê°’ì´ ë‚¨ì€ ê²½ìš°, ë‚¨ì€ ê°’ì„ ì „ë¶€ tempì— ì¶”ê°€  
  
                for ((key, value) in tempArray.withIndex()) {  
                    array[start + key] = value  
                }  
  
                continue  
            }  
            if (start >= end) continue  
  
            val mid = (start + end) / 2  
            //ë¶„í• ì„ ìœ„í•œ ëª¨ì§‘  
            stack.push(Container(start, end, true))  
  
            //ë‹¤ìŒ ë¶„í• ì„ ìœ„í•´ì„œ ì €ì¥  
            //ê²°êµ­ì€ ìœ„ì˜ ìŠ¤íƒì— ë“¤ì–´ê°€ë©´ì„œ ì •ë ¬í•  ê²ƒ  
            stack.push(Container(mid + 1, end, false))  
            stack.push(Container(start, mid, false))  
        }  
  
  
  
        assertArrayEquals(expected, array)  
    }  
  
    @Test  
    fun sortUseCallStack() {  
        val list = giveMeArray()  
        val expected = list.sorted().toIntArray()  
        val array = list.toIntArray()  
  
        mergeSort(array, 0, array.size - 1)  
        assertArrayEquals(expected, array)  
    }  
  
    fun merge(array: IntArray, start: Int, mid: Int, end: Int): Unit {  
        var tempArray = mutableListOf<Int>()  
        var i = start  
        var j = mid + 1  
        while (i <= mid && j <= end) {  
            if (array[i] <= array[j]) tempArray.add(array[i++])  
            else tempArray.add(array[j++])  
        }        while (i <= mid) tempArray.add(array[i++])  
        while (j <= end) tempArray.add(array[j++])  
        for ((key, value) in tempArray.withIndex()) {  
            array[start + key] = value  
        }  
    }  
  
    fun mergeSort(array: IntArray, start: Int, end: Int): Unit {  
        if (start < end) {  
            val mid = (start + end) / 2  
            mergeSort(array, start, mid)  
            mergeSort(array, mid + 1, end)  
  
            merge(array, start, mid, end)  
        }  
    }  
}
```

## 6. í€µ ì •ë ¬
- ë¶„í•  ì •ë³µ ê¸°ë°˜ì˜ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜
- ë°°ì—´ì˜ pivotì„ í•˜ë‚˜ ì„ íƒí•´ì„œ pivotë³´ë‹¤ ì‘ì€ ê°’ì€ ì™¼ìª½, í° ê°’ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë³´ë‚´ì„œ ë¶„í• 
- pivotì˜ ì„ íƒì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.
- ì´í›„ ì–‘ìª½ êµ¬ê°„ì— ëŒ€í•´ì„œ ì¬ê·€ì ìœ¼ë¡œ í€µì •ë ¬ ë°˜ë³µ
- í€µì •ë ¬ì—ì„œ â€œí€µâ€ì´ë€ ì´ë¦„ì€ **ì •ë ¬ì„ ë¹ ë¥´ê²Œ ìˆ˜í–‰**í•˜ëŠ” íŠ¹ì„±ì—ì„œ ìœ ë˜í•œ ê²ƒì…ë‹ˆë‹¤. í€µì •ë ¬ì´ **ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜ë“¤ì— ë¹„í•´ ë¹ ë¥´ê²Œ ë™ì‘**í•˜ëŠ” ì´ìœ ëŠ”, **í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ë°°ì—´ì„ ë¹ ë¥´ê²Œ ë¶„í• **í•˜ê³ , ê° ë¶„í• ëœ ë¶€ë¶„ì— ëŒ€í•´ ì¬ê·€ì ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì •ë ¬ì„ ì²˜ë¦¬í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

	- **í€µì •ë ¬ì˜ ë¹ ë¥¸ ë¶„í• **: ë°°ì—´ì„ í•œ ë²ˆë§Œ ìˆœíšŒí•˜ë©´ì„œ ì‘ì€ ê°’ë“¤ì€ ì™¼ìª½ìœ¼ë¡œ, í° ê°’ë“¤ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë¹ ë¥´ê²Œ ì´ë™ì‹œí‚µë‹ˆë‹¤. ì´ë•Œ ë°°ì—´ì„ ë¶„í• í•˜ëŠ” ë° ì†Œìš”ë˜ëŠ” ì‹œê°„ì€ O(n)ì…ë‹ˆë‹¤.
    
	- **ë¶„í•  í›„ ì •ë ¬**: ë¶„í• ëœ ë¶€ë¶„ ë°°ì—´ì— ëŒ€í•´ì„œëŠ” ì¬ê·€ì ìœ¼ë¡œ í€µì •ë ¬ì„ ì ìš©í•˜ëŠ”ë°, ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ëª¨ë“  ë°°ì—´ì´ ì •ë ¬ë©ë‹ˆë‹¤.

> - ì •ë ¬ì˜ í•µì‹¬
> 	- ì „ì²´ ë°ì´í„°ë¥¼ ì§ì ‘ ë¹„êµí•˜ê³  ìœ„ì¹˜ë¥¼ ì¡°ì •í•˜ëŠ” ê²ƒì´ ë¹„íš¨ìœ¨
> 	- ë”°ë¼ì„œ pivotì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ ëŒ€ìƒ ë²”ìœ„ë¥¼ ì¤„ì¸ë‹¤.
> - í€µì •ë ¬ ì „ëµ
> 	- pivot í•˜ë‚˜ë§Œìœ¼ë¡œ ë°°ì—´ ë‘ ë¶€ë¶„ìœ¼ë¡œ ë‚˜ëˆ„ê³ , ê°ê° ë…ë¦½ì ìœ¼ë¡œ ì²˜ë¦¬ ê°€ëŠ¥ -> ì¬ê·€ì  ì„¤ê³„ ê°€ëŠ¥
> 	- í‰ê·  ì‹œê°„ ë³µì¡ë„ O(n log n), ê³µê°„ì€ O(log n)

- ë¶„í• 
	- pivotì„ ê¸°ì¤€ìœ¼ë¡œ ì‘ì€ ê°’ì€ ì™¼ìª½, í° ê°’ì€ ì˜¤ë¥¸ìª½ì— ì˜¤ë„ë¡ swap
	- ìµœì¢…ì ìœ¼ë¡œ pivotì€ ì •ë ¬ëœ ìœ„ì¹˜ì— ë†“ì´ê²Œ ëœë‹¤.
- ì¬ê·€ ì •ë ¬
	- pivotì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ  ì™¼/ì˜¤ë¥¸ìª½ ë¶€ë¶„ ë°°ì—´ì— ëŒ€í•´ì„œ í€µì •ë ¬ì„ ì¬ê·€ì ìœ¼ë¡œ ìˆ˜í–‰
	- ë” ì´ìƒ ë‚˜ëˆŒ ìˆ˜ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ

```kotlin
class QuickSort {  
  
    data class Container (  
        val left: Int,  
        val right: Int,  
    ){}  
    
    /**  
     * ```
     *  [5, 4, 10, 2, 8, 6] : origin
     *  [4, 2, 5, 6, 8, 10] : 1íšŒì „  
     *  [2, 4, 5, 6, 8, 10] : 2íšŒì „  
     *```  
     */
     
    @Test  
    fun sortUseStack() {  
        val list = giveMeArray()  
        val expected = list.sorted().toIntArray()  
        val array = list.toIntArray()  
        val stack = Stack<Container>()  
        stack.push(Container(0, array.size - 1))  
  
        while(stack.isNotEmpty()) {  
            val (left, right) = stack.pop();  
            var leftPoint = left  
            var rightPoint = right  
            var pivotValue = array[(leftPoint + rightPoint) / 2]  
  
            do {  
            //pivotì„ ê¸°ì¤€ìœ¼ë¡œ
            //leftPointì˜ ê°’ì´ ì‘ìœ¼ë©´ skip
            //rightPointë„ ê°™ìŒ
            //pivotë³´ë‹¤ í¬ë©´ í•´ë‹¹ í¬ì¸íŠ¸ì—ì„œ ë£¨í•‘ì„ ì¢…ë£Œ
            
                while (pivotValue > array[leftPoint]) leftPoint += 1;  
                while (pivotValue < array[rightPoint]) rightPoint -= 1;  

			// pivotê³¼ ë°”ë€Œê±°ë‚˜
			// pivotë³´ë‹¤ í° ê²ƒ <-> pivotë³´ë‹¤ ì‘ì€ ê²ƒ
                if (leftPoint <= rightPoint) {  
                    val temp = array[leftPoint]  
                    array[leftPoint] = array[rightPoint]  
                    array[rightPoint] = temp  
                    leftPoint += 1  
                    rightPoint -= 1  
                }  
  
            } while (leftPoint <= rightPoint)  
  
            if(left < rightPoint) {  
                stack.push(Container(left, rightPoint))  
            }  
            if(right > leftPoint) {  
                stack.push(Container(leftPoint, right))  
            }  
  
        }  
  
        assertArrayEquals(expected, array)  
    }  
  
  
    private fun quickSort(array: IntArray, left: Int, right: Int) {  
        var leftPoint = left  
        var rightPoint = right  
        var pivotValue = array[(leftPoint + rightPoint) / 2]  
  
        do {  
            while (pivotValue > array[leftPoint]) leftPoint += 1;  
            while (pivotValue < array[rightPoint]) rightPoint -= 1;  
  
            if (leftPoint <= rightPoint) {  
                val temp = array[leftPoint]  
                array[leftPoint] = array[rightPoint]  
                array[rightPoint] = temp  
                leftPoint += 1  
                rightPoint -= 1  
            }  
  
        } while (leftPoint <= rightPoint)  
  
        if(left < rightPoint) {  
            quickSort(array, left, rightPoint)  
        }  
        if(right > leftPoint) {  
            quickSort(array, leftPoint, right)  
        }  
    }  
  
    @Test  
    fun sortUseCallStack() {  
        val list = giveMeArray()  
        val expected = list.sorted().toIntArray()  
        val array = list.toIntArray()  
  
        quickSort(array, 0, array.size - 1)  
  
  
        assertArrayEquals(expected, array)  
    }  
}
```

## í™ ì •ë ¬
- í™ ì •ë ¬(Heap Sort)ì€ **í™(Heap)** ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.
- í™ ì •ë ¬ì˜ í•µì‹¬ ì•„ì´ë””ì–´ëŠ” **í™**ì„ ì´ìš©í•˜ì—¬ ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ê²ƒìœ¼ë¡œ, **ìµœëŒ€ í™(Max Heap)**ì´ë‚˜ **ìµœì†Œ í™(Min Heap)**ì„ ì‚¬ìš©í•˜ì—¬ ìˆœì°¨ì ìœ¼ë¡œ ì •ë ¬ì„ ì§„í–‰í•©ë‹ˆë‹¤.

> ### 1. **í™(Heap) ìë£Œêµ¬ì¡°**
>   
> 
> - í™ì€ **ì™„ì „ ì´ì§„ íŠ¸ë¦¬(Complete Binary Tree)** êµ¬ì¡°
> - ê° ë…¸ë“œì˜ ê°’ì´ íŠ¹ì • ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” íŠ¸ë¦¬ì…ë‹ˆë‹¤.
> - ì´ ì¡°ê±´ì„ **í™ ì†ì„±(Heap Property)**ì´ë¼ê³  í•©ë‹ˆë‹¤.
> 	- **ìµœëŒ€ í™(Max Heap)**: ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ íŠ¸ë¦¬ì…ë‹ˆë‹¤.
> 		- ì´ì§„ íŠ¸ë¦¬ì˜ ì¼ì¢…
> 		- rootê°€ ê°€ì¥ í° ê°’ì„ ê°€ì§„ë‹¤. -> ìµœëŒ€ ê°’ì„ ë¹ ë¥´ê²Œ êº¼ë‚´ê¸° ìœ„í•´ì„œ ì„¤ê³„ëœ êµ¬ì¡°
> 		- ì™„ì „ ì´ì§„ íŠ¸ë¦¬ë¡œ êµ¬í˜„ë˜ë¯€ë¡œ, ë°°ì—´ë¡œ ì¸ë±ìŠ¤ ê¸°ë°˜ ì—°ì‚°ì´ ê°€ëŠ¥
> 	- **ìµœì†Œ í™(Min Heap)**: ë¶€ëª¨ ë…¸ë“œì˜ ê°’ì´ ìì‹ ë…¸ë“œì˜ ê°’ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ íŠ¸ë¦¬ì…ë‹ˆë‹¤.
> 	 
> ### 2. **í™ ì •ë ¬ì˜ ê¸°ë³¸ ì›ë¦¬**
>
> - heapify: ë°°ì—´ì„ í™ êµ¬ì¡°ë¡œ ë§Œë“œëŠ” ê³¼ì •, ë°°ì—´ì´ ì£¼ì–´ì¡Œì„ ë•Œ ì´ë¥¼ ìµœëŒ€ í™ì´ë‚˜ ìµœì†Œ í™ìœ¼ë¡œ ë³€í™˜
> - sorting: í™ì˜ ë£¨íŠ¸ ë…¸ë“œë¥¼ ë°°ì—´ì˜ ëê³¼ êµí™˜í•˜ê³  ë°°ì—´ì˜ í¬ê¸°ë¥¼ ì¤„ì—¬ê°€ë©´ ì´ ê³¼ì •ì„ ë°˜ë³µ
> 
> ### **4.**Â **í™ ì •ë ¬ì˜ ì¥ë‹¨ì **
>
>#### **ì¥ì :**
> - **ì‹œê°„ ë³µì¡ë„**: ìµœì•…ì˜ ê²½ìš°ì—ë„ O(n log n)ìœ¼ë¡œ ì•ˆì •ì ì…ë‹ˆë‹¤.
> - **ê³µê°„ íš¨ìœ¨ì„±**: ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ ê³µê°„ì„ ê±°ì˜ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©° O(1)ì˜ ê³µê°„ ë³µì¡ë„ë¥¼ ê°€ì§‘ë‹ˆë‹¤.
> - **ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥ì„±**: í™ ì •ë ¬ì€ ë³‘ë ¬ ì²˜ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤.
>
>#### **ë‹¨ì :**
>- **ë¶ˆì•ˆì • ì •ë ¬(Unstable Sort)**: í™ ì •ë ¬ì€ ë™ì¼í•œ ê°’ì˜ ìƒëŒ€ì  ìˆœì„œë¥¼ ë³´ì¥í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë¶ˆì•ˆì • ì •ë ¬ì…ë‹ˆë‹¤.
>- **ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼**: í™ ì •ë ¬ì€ ë‹¤ë¥¸ ì•Œê³ ë¦¬ì¦˜(ì˜ˆ: í€µì •ë ¬, ë³‘í•©ì •ë ¬)ì— ë¹„í•´ ìƒëŒ€ì ìœ¼ë¡œ êµ¬í˜„ì´ ë³µì¡í•˜ê³ , ì¼ë¶€ ê²½ìš°ì—ëŠ” ì„±ëŠ¥ì´ ë” ë‚˜ì  ìˆ˜ ìˆìŠµë‹ˆë‹¤.