# 아이디어 
> A -> B의 최단 거리를 구할 때, 직접 가는 것이 최단이 아닐 수도 있다.
### 경유가 더 빠를 수도 있다!
> A -> C -> B가 더 짧을 수 있다.
### 전략?
> 1. 모든 지점을 중간 경유지로 시도
> 2. 경유했을 때 vs. 직접 갔을 때 비교
> 3. 더 짧은 거리로 갱신
### 3중 루프 구조
```text
for k (경유지)
	for i (출발지)
		for j (도착지)
			"i -> j" vs. "i -> k -> j" 중 짧은 것
 
```



# 정의
- 모든 정점 쌍 간의 최단 거리를 구하는 알고리즘
- DP 기반 3중 루프
- 음수 가중치 허용(음수 사이클이 없다는 가정 하에)

# 특징
- **시간 복잡도**: O(V<sup>3</sup>)
- **공간 복잡도**: O(V<sup>2</sup>)-2 차원 배열 사용
- **점화식**: `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])`

# 다익스트라 vs 플로이드-워셜

- **다익스트라**: 한 정점 → 모든 정점 (V번 실행하면 전체)
- **플로이드-워셜**: 모든 정점 → 모든 정점 (한 번에)

# 언제 사용하나?

- 모든 쌍 최단 거리가 필요할 때
- 정점 수가 적을 때 (보통 V ≤ 400)
- 중간 경유지를 고려한 경로 찾기


# 구현 예시
```kotlin
  
class FloydWarshall {  
  
    fun floydWarshall(n: Int, edges: Array<IntArray>): Array<IntArray> {  
        //1. 거리 테이블 & 자기 자신은 0으로 초기화  
        val dist = Array(n) { outer -> IntArray(n) { inner -> if (outer == inner) 0 else Int.MAX_VALUE } }  
  
  
        //2.초기 간선 정보 입력  
        for (edge in edges) {  
            val (a, b, cost) = edge  
            dist[a][b] = cost  
            //양방향이면 dist[b][a] = cost        }  
  
        //3. floyd-warshall  
        for (k in 0 until n) { //경유  
            for (i in 0 until n) { //시작  
                for (j in 0 until n) { //끝  
  
                    //중간에 가본 적이 있으면  
                    if (dist[i][k] != Int.MAX_VALUE && dist[k][j] != Int.MAX_VALUE) {  
                        dist[i][j] = minOf(dist[i][j], dist[i][k] + dist[k][j]) //비교해서 변경  
                    }  
  
                }  
            }  
        }  
  
        return dist  
    }  
}
```

# 예시 문제
## 1. 최단거리
```kotlin
class ShortestPath {  
    /**  
     * 플로이드-워셜 기본 문제 1: 최단 경로 행렬  
     * 문제 설명  
     * 정점 n개와 간선 정보가 주어질 때, 모든 정점 쌍 간의 최단 거리를 구하는 프로그램을 작성하세요.  
     * 입력  
     *  
     * n: 정점의 개수 (1 ≤ n ≤ 100)   
     * edges: 간선 정보 [출발, 도착, 비용] 형태의 배열  
     *  
     * 출력  
     *  
     * 모든 정점 쌍 간의 최단 거리를 담은 2차원 배열  
     * 경로가 없으면 Int.MAX_VALUE    
     *     
     * 예시  
     * 입력:  
     * n = 4     
     * edges = [     
     *   [0, 1, 5],     
     *   [0, 3, 10],     
     *   [1, 2, 3],     
     *   [2, 3, 1]    
     * ]     
     *     
     * 출력:  
     * [    
     *   [0, 5, 8, 9],    
     *   [INF, 0, 3, 4],    
     *   [INF, INF, 0, 1],    
     *   [INF, INF, INF, 0]     
     * ]     
     *    
     * 제한 사항  
     * - 모든 간선의 가중치는 양수  
     * - 자기 자신으로 가는 거리는 0     
     * - 갈 수 없는 경우 Int.MAX_VALUE    
     * */  
    
    
    @Test  
    fun solution() {  
        val n = 4  
        val edges = arrayOf(  
            intArrayOf(0, 1, 5),  
            intArrayOf(0, 3, 10),  
            intArrayOf(1, 2, 3),  
            intArrayOf(2, 3, 1)  
        )  
        val expected = arrayOf(  
            intArrayOf(0, 5, 8, 9),  
            intArrayOf(Int.MAX_VALUE, 0, 3, 4),  
            intArrayOf(Int.MAX_VALUE, Int.MAX_VALUE, 0, 1),  
            intArrayOf(Int.MAX_VALUE, Int.MAX_VALUE, Int.MAX_VALUE, 0)  
        )  
  
        assertArrayEquals(expected, floydWarshall(n, edges))  
    }  
  
    private fun floydWarshall(n: Int, edges: Array<IntArray>): Array<IntArray> {  
        val graph = Array(n) { outer -> IntArray(n) { inner -> if (outer == inner) 0 else Int.MAX_VALUE } }  
  
        for (edge in edges) {  
            val (a, b, cost) = edge  
            graph[a][b] = cost  
//            graph[b][a] = cost  
        }  
  
        for (k in 0 until n) {  
            for (i in 0 until n) {  
                for (j in 0 until n) {  
                    if (graph[i][k] == Int.MAX_VALUE || graph[k][j] == Int.MAX_VALUE) continue  
                    graph[i][j] = minOf(graph[i][j], graph[i][k] + graph[k][j])  
                }  
            }  
        }  
  
        return graph  
    }  
}
```

### 2. 최단거리-2
```kotlin
class ShortestPath2 {  
    /**  
     * 플로이드-워셜 기본 문제 2: 경로  
     * 문제 설명  
     * n개의 도시가 있고, 한 도시에서 출발하여 다른 도시에 도착하는 m개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.  
     * 모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.  
     * 입력  
     *  
     * n: 도시의 개수 (2 ≤ n ≤ 100)  
     * buses: 버스 정보 [시작도시, 도착도시, 비용] 형태의 배열  
     * 시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.  
     *    
     * 출력  
     *  
     * n×n 크기의 배열에서 i번째 줄의 j번째 숫자는 도시 i에서 j로 가는데 필요한 비용의 최솟값  
     * i에서 j로 갈 수 없는 경우에는 0을 출력한다.  
     *    
     * 예시  
     * 입력  
     * n = 5  
     * buses = [   
     *   [1, 2, 2],    
     *   [1, 3, 3],    
     *   [1, 4, 1],    
     *   [1, 5, 10],    
     *   [2, 4, 2],    
     *   [3, 4, 1],    
     *   [3, 5, 1],     
     *   [4, 5, 3],     
     *   [3, 5, 10],  // 중복 경로 (더 비쌈)  
     *   [3, 1, 8]    // 역방향  
     * ]  
     * 출력  
     * [  
     *   [0, 2, 3, 1, 4],     
     *   [0, 0, 0, 2, 5],     
     *   [8, 0, 0, 1, 1],     
     *   [0, 0, 0, 0, 3],    
     *   [0, 0, 0, 0, 0]    
     * ]    
     * */  
   

	@Test  
    fun solution() {  
        val n = 5  
        val buses = arrayOf(  
            intArrayOf(1, 2, 2),  
            intArrayOf(1, 3, 3),  
            intArrayOf(1, 4, 1),  
            intArrayOf(1, 5, 10),  
            intArrayOf(2, 4, 2),  
            intArrayOf(3, 4, 1),  
            intArrayOf(3, 5, 1),  
            intArrayOf(4, 5, 3),  
            intArrayOf(3, 5, 10),  
            intArrayOf(3, 1, 8)  
        )  
  
        val expected = arrayOf(  
            intArrayOf(0, 2, 3, 1, 4),  
            intArrayOf(0, 0, 0, 2, 5),  
            intArrayOf(8, 10, 0, 1, 1),  
            intArrayOf(0, 0, 0, 0, 3),  
            intArrayOf(0, 0, 0, 0, 0)  
        )  
  
  
        assertArrayEquals(expected, floydWarshall(n, buses))  
    }  
  
    private fun floydWarshall(n: Int, buses: Array<IntArray>): Array<IntArray> {  
        val graph = Array(n) { outer -> IntArray(n) { inner -> if (outer == inner) 0 else Int.MAX_VALUE } }  
        for (bus in buses) {  
            val (a, b, cost) = bus  
            graph[a - 1][b - 1] = minOf(cost, graph[a - 1][b - 1])  
        }  
  
        for (k in 0 until n) {  
            for (i in 0 until n) {  
                for (j in 0 until n) {  
                    if (graph[i][k] == Int.MAX_VALUE || graph[k][j] == Int.MAX_VALUE) continue  
                    graph[i][j] = minOf(graph[i][j], graph[i][k] + graph[k][j])  
                }  
            }  
        }  
  
  
        graph.forEach {  
            println(it.contentToString().replace(Int.MAX_VALUE.toString(), "0"))  
        }  
        return graph.map { it.map { element -> if (element == Int.MAX_VALUE) 0 else element }.toIntArray() }  
            .toTypedArray()  
    }  
}
```