# 핵심 아이디어
- **탐욕적 선택**: 항상 현재까지 발견된 가장 가까운 정점부터 방문
- **최적 부분 구조**: 최단 경로의 부분 경로도 최단 경로

# 알고리즘 원리
- 시작점에서 각 정점까지 최단 거리를 점진적으로 확정
- 확정된 정점을 통해 인접 정점들의 거리를 갱신
- 우선 순위 큐로 가장 가까운 미확정 정점을 선택

# 핵심 자리 구조
- 거리 배열(`dist[]`) : 시작점부터 각 정점까지의 최단거리
- 우선 순위 큐: (`거리, 정점`) 쌍을 거리 기준 최소 힙으로 관리
- 그래프: 인접리스트로(정점, 가중치) 저장

# **알고리즘 단계**

1. 거리 배열을 INF로 초기화, 시작점은 0
2. 우선순위큐에 (0, 시작점) 삽입
3. 큐에서 최소 거리 정점 꺼내기
4. 해당 정점의 인접 정점들 거리 갱신
5. 갱신된 정점을 큐에 삽입
6. 큐가 빌 때까지 반복


# 구현
### 1. 최단 거리
```kotlin
  
class ShortestPath {  
    /**  
     * 문제: 최단경로  
     * 문제 설명  
     * 방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.  
     * 제약사항  
     *  
     * 1 ≤ V ≤ 20,000 (정점의 개수)  
     * 1 ≤ E ≤ 300,000 (간선의 개수)  
     * 1 ≤ start ≤ V (시작 정점)  
     * 모든 가중치는 10 이하의 자연수  
     *  
     * 입출력 예  
     * 입력:  
     * V=5, E=6, start=1 
     * edges = [   
     *   [1,2,2],   
     *   [1,3,3],   
     *   [1,4,1],
     *   [1,5,10],  
     *   [2,4,2],
     *   [3,4,1]   
     * ]    
     * 출력:  
     * [0, 2, 3, 1, 10]  // 1번부터 각 정점까지의 최단거리  
     */  
  
  
    @Test  
    fun solution() {  
        val V = 5  
        val E = 6  
        val start = 1  
        val edges = arrayOf(  
            intArrayOf(1, 2, 2),  
            intArrayOf(1, 3, 3),  
            intArrayOf(1, 4, 1),  
            intArrayOf(1, 5, 10),  
            intArrayOf(2, 4, 2),  
            intArrayOf(3, 4, 1),  
        )  
  
        val expected = intArrayOf(0, 2, 3, 1, 10)  
  
  
        assertArrayEquals(expected, dijkstra(V, E, start, edges))  
    }  
  
    private fun dijkstra(V: Int, E: Int, start: Int, edges: Array<IntArray>): IntArray {  
        val graph: Map<Int, List<Pair<Int, Int>>> = edges  
            .groupBy { it[0] }  
            .mapValues { it.value.map { array -> array[1] to array[2] } }  
        val scoreBoard = IntArray(V + 1) { if (it == start) 0 else Int.MAX_VALUE }  
        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })  
        pq.offer(start to 0)  
  
        while (pq.isNotEmpty()) {  
            val (current, currentScore) = pq.poll()  
  
            if (currentScore > scoreBoard[current]) continue  
            graph[current]?.forEach { (next, weight) ->  
                val newDistance = weight + currentScore  
                if (newDistance < scoreBoard[next]) {  
                    scoreBoard[next] = newDistance  
                    pq.offer(next to newDistance)  
                }  
            }  
        }  
  
  
        return scoreBoard.sliceArray(1 until scoreBoard.size)  
    }  
}
```