# 핵심 아이디어
- **탐욕적 선택**: 항상 현재까지 발견된 가장 가까운 정점부터 방문
- **최적 부분 구조**: 최단 경로의 부분 경로도 최단 경로

# 알고리즘 원리
- 시작점에서 각 정점까지 최단 거리를 점진적으로 확정
- 확정된 정점을 통해 인접 정점들의 거리를 갱신
- 우선 순위 큐로 가장 가까운 미확정 정점을 선택

# 핵심 자리 구조
- 거리 배열(`dist[]`) : 시작점부터 각 정점까지의 최단거리
- 우선 순위 큐: (`거리, 정점`) 쌍을 거리 기준 최소 힙으로 관리
- 그래프: 인접리스트로(정점, 가중치) 저장

# **알고리즘 단계**

1. 거리 배열을 INF로 초기화, 시작점은 0
2. 우선순위큐에 (0, 시작점) 삽입
3. 큐에서 최소 거리 정점 꺼내기
4. 해당 정점의 인접 정점들 거리 갱신
5. 갱신된 정점을 큐에 삽입
6. 큐가 빌 때까지 반복


# 구현
### 1. 최단 거리
```kotlin
  
class ShortestPath {  
    /**  
     * 문제: 최단경로  
     * 문제 설명  
     * 방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.  
     * 제약사항  
     *  
     * 1 ≤ V ≤ 20,000 (정점의 개수)  
     * 1 ≤ E ≤ 300,000 (간선의 개수)  
     * 1 ≤ start ≤ V (시작 정점)  
     * 모든 가중치는 10 이하의 자연수  
     *  
     * 입출력 예  
     * 입력:  
     * V=5, E=6, start=1 
     * edges = [   
     *   [1,2,2],   
     *   [1,3,3],   
     *   [1,4,1],
     *   [1,5,10],  
     *   [2,4,2],
     *   [3,4,1]   
     * ]    
     * 출력:  
     * [0, 2, 3, 1, 10]  // 1번부터 각 정점까지의 최단거리  
     */  
  
  
    @Test  
    fun solution() {  
        val V = 5  
        val E = 6  
        val start = 1  
        val edges = arrayOf(  
            intArrayOf(1, 2, 2),  
            intArrayOf(1, 3, 3),  
            intArrayOf(1, 4, 1),  
            intArrayOf(1, 5, 10),  
            intArrayOf(2, 4, 2),  
            intArrayOf(3, 4, 1),  
        )  
  
        val expected = intArrayOf(0, 2, 3, 1, 10)  
  
  
        assertArrayEquals(expected, dijkstra(V, E, start, edges))  
    }  
  
    private fun dijkstra(V: Int, E: Int, start: Int, edges: Array<IntArray>): IntArray {  
        val graph: Map<Int, List<Pair<Int, Int>>> = edges  
            .groupBy { it[0] }  
            .mapValues { it.value.map { array -> array[1] to array[2] } }  
        val scoreBoard = IntArray(V + 1) { if (it == start) 0 else Int.MAX_VALUE }  
        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })  
        pq.offer(start to 0)  
  
        while (pq.isNotEmpty()) {  
            val (current, currentScore) = pq.poll()  
  
            if (currentScore > scoreBoard[current]) continue  
            graph[current]?.forEach { (next, weight) ->  
                val newDistance = weight + currentScore  
                if (newDistance < scoreBoard[next]) {  
                    scoreBoard[next] = newDistance  
                    pq.offer(next to newDistance)  
                }  
            }  
        }  
  
  
        return scoreBoard.sliceArray(1 until scoreBoard.size)  
    }  
}
```

### 2. 특정 거리의 도시 찾기
```kotlin
  
class FindCity {  
    /**  
     * 다익스트라 응용 문제: 특정 거리의 도시 찾기  
     * 문제 설명  
     * 어떤 나라에는 N개의 도시가 있다. 그리고 각 도시는 M개의 단방향 도로로 연결되어 있다.
     * 각 도로는 특정한 거리를 가지고 있다.  
     * 특정한 도시 X에서 출발하여 도달할 수 있는 도시 중에서, 
     * 최단 거리가 정확히 K인 모든 도시들의 번호를 오름차순으로 출력하는 프로그램을 작성하시오.      *
     * 제약사항  
     *  
     * 2 ≤ N ≤ 300,000 (도시의 개수)  
     * 1 ≤ M ≤ 1,000,000 (도로의 개수)  
     * 1 ≤ K ≤ 300,000 (거리)  
     * 1 ≤ X ≤ N (출발 도시)  
     *     * 입출력 예  
     * 입력:  
     * N=4, M=4, K=2, X=1    
     * roads = [[1,2,1], [1,3,1], [2,3,1], [2,4,1]]  
     * 출력:  
     * [4]  // 1번 도시에서 정확히 거리 2로 갈 수 있는 도시  
     */  
  
    @Test  
    fun solution() {  
        val N = 4  
        val M = 4  
        val K = 2  
        val X = 1  
        val roads = arrayOf(  
            intArrayOf(1, 2, 1),  
            intArrayOf(1, 3, 1),  
            intArrayOf(2, 3, 1),  
            intArrayOf(2, 4, 1)  
        )  
        val expected = intArrayOf(4)  
  
        assertArrayEquals(expected, dijkstra(N, M, K, X, roads))  
    }  
  
    private fun dijkstra(N: Int, M: Int, K: Int, X: Int, roads: Array<IntArray>): IntArray {  
        val graph = roads  
            .groupBy { it[0] }  
            .mapValues { it.value.map { array -> array[1] to array[2] } }  
        val scoreBoard = IntArray(N + 1) { if (it == X) 0 else Int.MAX_VALUE }  
        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })  
  
        pq.offer(X to 0)  
  
        while(pq.isNotEmpty()) {  
            val (current, currentScore) = pq.poll()  
            if(currentScore > scoreBoard[current]) continue  
  
            graph[current]?.forEach { (next, weight) ->  
                val nextScore = currentScore + weight  
                if(nextScore < scoreBoard[next]) {  
                    scoreBoard[next] = nextScore  
                    pq.offer(next to nextScore)  
                }  
            }  
        }  
  
        val result = mutableListOf<Int>()  
        for((index, value) in scoreBoard.withIndex()) {  
            if(value == K) result.add(index)  
        }  
        return result.sorted().toIntArray()  
    }  
}
```