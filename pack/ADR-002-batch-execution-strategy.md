# ADR-002: Batch Execution Strategy Selection

## Status
Accepted

## Context

예약 시스템에서 TimeTable 생성을 위한 장시간 실행 배치 작업의 실행 방식을 결정해야 한다.

### 배치 작업의 특성
- **대용량 데이터 처리**: Schedule 엔티티 기반으로 TimeTable 엔티티 생성
- **장시간 실행**: 데이터량에 따라 수십 분에서 수 시간 소요 예상
- **정기 실행**: 일정 주기로 실행되어야 하며, 필요시 수동 실행도 가능해야 함
- **신뢰성 요구**: 실패 시 재시도 가능하고, 실행 상태 추적이 필요

### 프로젝트 현황
- **개발 단계**: 프로토타입에서 MVP로 전환하는 시점
- **팀 규모**: 소규모 개발팀으로 복잡한 인프라 관리 부담 최소화 필요
- **기존 구현**: 이미 Spring Batch 기반 배치 모듈과 REST API 컨트롤러 구현 완료
- **인프라**: 현재 단일 서버 환경, 향후 확장 가능성 고려 필요

## Options Considered

### Option A: Spring @Scheduled 애노테이션

Spring의 내장 스케줄링 기능을 사용하여 배치 작업을 정기적으로 실행하는 방식.

**장점**:
- 구현이 매우 간단하며 별도 인프라나 의존성이 불필요
- Spring 생태계와 완전히 통합되어 설정 관리가 용이

**단점**:
- 애플리케이션 생명주기와 강하게 결합되어 배치 실행 중 서버 재시작 시 작업 중단
- 장시간 실행되는 배치가 애플리케이션의 다른 기능에 영향을 줄 수 있음
- 실행 상태 모니터링이나 수동 제어가 제한적
- 실패 시 전체 애플리케이션 재시작이 필요할 수 있음

### Option B: Quartz Scheduler 내장

애플리케이션 내부에 Quartz 스케줄러를 내장하여 배치 작업을 관리하는 방식.

**장점**:
- 강력하고 유연한 스케줄링 기능 제공
- 클러스터 환경에서 job 분산 실행 지원
- 동적 스케줄 변경 및 관리 가능

**단점**:
- 상당한 설정 복잡도와 학습 곡선 존재
- 관리용 웹 UI는 별도로 구축해야 함
- 현재 단순한 배치 요구사항 대비 과도한 복잡성

### Option C: 외부 스케줄러 (Jenkins/Cron)

외부 스케줄링 시스템에서 배치 애플리케이션을 호출하는 방식.

**장점**:
- 배치 실행과 애플리케이션 생명주기 완전 분리
- 강력한 모니터링, 로깅, 알림 기능
- 배치 실패가 메인 애플리케이션에 영향 주지 않음

**단점**:
- 별도 인프라 관리 복잡성
- 네트워크 장애 등 외부 의존성 리스크

### Option D: REST API 기반 수동 실행 (현재 구현)

배치 작업을 REST API로 노출하여 필요시 수동으로 실행하는 방식.

**장점**:
- 개발 단계에서 최대한의 제어와 디버깅 편의성
- 다양한 스케줄링 시스템과 유연하게 연동 가능
- 구현이 단순하고 직관적

**단점**:
- 정기 실행을 위해서는 별도 스케줄링 메커니즘 필요
- 수동 실행에 의존하므로 운영 단계에서는 추가 자동화 필요

## Decision

**단계적 접근법**을 채택하여 REST API 기반 실행에서 시작하여 외부 스케줄러로 진화시킨다.

**구체적 계획**:
1. **Phase 1 (현재)**: REST API 기반 수동 실행으로 개발/테스트 진행
2. **Phase 2 (운영)**: 외부 스케줄러(Jenkins/Cron)에서 REST API 호출
3. **Phase 3 (필요시)**: 복잡한 스케줄링 요구사항 발생 시 Quartz 도입 검토

## Rationale

### @Scheduled 배제 이유

장시간 실행되는 배치 작업의 특성상 @Scheduled는 부적절하다고 판단했다:

- **애플리케이션 결합도**: 배치 실행 중 서버 재시작 시 작업이 중단되며, 재시작 후 다음 스케줄까지 대기해야 함
- **리소스 간섭**: 장시간 배치가 웹 애플리케이션 성능에 영향을 줄 수 있음
- **제어 한계**: 실행 중인 배치를 중단하거나 상태를 확인하기 어려움
- **운영 복잡성**: 배치 문제로 인한 전체 애플리케이션 재시작 위험

### REST API 기반 시작 이유

현재 프로젝트 단계에서 REST API 방식이 최적이라고 판단했다:

- **개발 효율성**: 이미 구현되어 있으며, 배치 로직 개발에 집중 가능
- **디버깅 편의성**: 수동 실행으로 로그 확인과 문제 분석이 용이
- **유연성**: 다양한 파라미터로 테스트 실행 가능
- **확장성**: 향후 어떤 스케줄러와도 연동 가능한 표준 인터페이스

### 단계적 접근법 선택 이유

프로토타입 단계에서 복잡한 인프라를 도입하는 것은 premature optimization이라고 판단했다:

- **현재 우선순위**: 배치 로직의 안정성과 성능 확보가 스케줄링보다 중요
- **팀 역량 집중**: 소규모 팀이 여러 기술 영역에 분산되는 것보다 핵심 로직에 집중
- **자연스러운 진화**: MVP 출시 후 운영 요구사항이 명확해지면 적절한 스케줄러 선택

### Quartz 도입 연기 이유

현재 상황에서 Quartz는 over-engineering이라고 판단했다:

- **요구사항 단순성**: 현재는 단일 배치 작업만 존재
- **학습 비용**: 새로운 라이브러리 도입에 따른 학습과 설정 복잡성
- **UI 구축 부담**: 배치 관리 UI를 별도로 구축해야 하는 추가 작업

## Consequences

### Positive

- **즉시 개발 가능**: 추가 인프라 구축 없이 바로 배치 개발 진행 가능
- **디버깅 효율성**: 수동 실행으로 실시간 로그 확인과 문제 분석 용이
- **점진적 안정성**: 각 단계에서 검증 후 다음 단계로 진행하여 리스크 최소화
- **기술 부채 방지**: 현재 단계에 적합한 솔루션 선택으로 불필요한 복잡성 배제

### Negative

- **운영 자동화 지연**: Phase 1에서는 수동 실행에 의존하여 정기 실행 자동화 부재
- **단계별 마이그레이션**: Phase 전환 시 설정 변경과 테스트 작업 필요
- **임시적 해결책**: Phase 1은 최종 운영 환경이 아닌 과도기적 솔루션

### Trade-offs

이 결정으로 인한 주요 trade-off들:

- **개발 속도 vs 운영 완성도**: 초기 개발 속도를 우선시하고 운영 자동화는 후순위로 배치
- **단순성 vs 확장성**: 당장의 단순함보다 향후 확장 가능성을 고려한 API 기반 설계
- **즉시 완성 vs 점진적 발전**: 한 번에 완벽한 솔루션보다 단계별 개선 경로 선택

### Risks

**Phase 1 수동 실행 의존성**
- 개발 기간 중 정기 배치 실행이 누락될 가능성
- 완화 방안: 개발팀 체크리스트와 임시 스크립트 활용

**Phase 전환 시점 판단**
- 너무 이른 전환으로 인한 불안정성 또는 늦은 전환으로 인한 비효율성
- 완화 방안: 명확한 전환 기준 설정 (예: MVP 출시 시점)

**API 인터페이스 안정성**
- Phase 2 전환 시 API 변경으로 인한 호환성 문제
- 완화 방안: API 설계 시 하위 호환성 고려 및 버전 관리

## Implementation Plan

### Phase 1: REST API 기반 수동 실행 (현재)
- ✅ TimeTableBatchController 구현 완료
- ✅ Spring Batch Job과 연동 완료
- 현재 단계에서 배치 로직 안정화 집중

### Phase 2: 외부 스케줄러 연동 (운영 준비 시)
- MVP 출시 준비 시점에 외부 스케줄러 도입
- 배치 모니터링 및 알림 체계 구축
- API 호출 기반 자동화 구현

### Phase 3: 고도화 검토 (필요시)
- 다중 배치 작업 증가 시 Quartz 등 검토
- 복잡한 스케줄링 요구사항 발생 시 솔루션 평가

## Related Decisions
- ADR-001: Batch Module Architecture Design

## Notes
이 결정은 현재 프로토타입 단계의 실용적 요구사항에 기반하며, 시스템과 팀의 성숙도에 따라 자연스럽게 진화할 예정이다.