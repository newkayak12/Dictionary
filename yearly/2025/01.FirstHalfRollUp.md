# 상반기 내용 정리

> - [cleanArchitecture](../../clean/architecture/01.Introduce.md)
> - [DDD](../../architecture/domain-driven-design/01.Introduce.md)
> - [hexagonal](../../architecture/hexagonal/01.Introduce.md)
> - [oop](../../paradigm/oop/01.Intro.md)
> - [designPattern](../../java/designPattern/2025/00.Index.md)
> - [antiPattern](../../java/anti-pattern/00.Index.md)

## 구성


## 아키텍쳐? 설계?

> 보통 아키텍쳐를 구성한다. 설계한다를 구분 없이 혼용해서 사용하는 경우가 있다. 물론 헷깔리긴 한다.

- 아키텍쳐: 저수준의 세부 사항('외부에서 어떤 프로토콜로 호출하는가?', '어떻게 기록할지?')과는 별개의 코드 상의 고수준의 무엇인가를 의미한다.
- 설계: 저수준의 구조 혹은 결정 사항 등을 의미한다.

<pre>
개발자가 SW를 만들면서 마주하는 두 가치가 있다. 
첫 번째는 행위(behavior)다. SW는 수익을 창출하거나 비용을 절약하도록 만들기 위해서 만든다.  프로그래머는 이를 위해서 이해관계자가 기능 명세서나 
요구 사항 문서를 구체화할 수 있도록 돕는다. 더 나아가 요구사항을 만족하도록 코드를 작성한다.

두 번째는 아키텍쳐다. 문제를 해결하기 위해서 형태다. SW 개발 비용의 증가를 결정짓는 주된 요인이 되기도 한다. 아키텍쳐가 특정 형태에 치우치면 변화에 대응하기
어려워진다.

이 둘은 모두 중요하다. 예를 들어 완벽하게 동작하는데 기능 추가가 어려워도 힘들다. 반대로 동작하지 않고 변경에 쉽다고 해도 굉장히 부담이 된다. 만약 이 둘 중에
고르라면 그나마 후자가 낫다. 노력 여하에 따라서 변경할 수 있음을 의미하기 떄문이다. 결과적으로 결과물도 중요하지만 아키텍쳐가 중요하다.

개발자는 개발을 하는 것뿐만 아니라 SW를 안전하게 보호하는 역할을 하기도 한다. 따라서 그 역할에 최선을 다해야 한다.
</pre>  

## 패러다임

아키텍쳐를 살펴보면서 빼놓을 수 없는 것이 **패러다임**이다. 기초 체력이 있어야 뼈대를 만든다. 프로그래밍 패러다임은 무엇인가를 **제한**하는 내용을 담고 있다.

### 1. 구조적 프로그래밍
- 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있고 기능적으로 분해할 수 있음을 의미한다.
- 모든 프로그램은 sequence, selection, iteration이 세 가지로 이뤄짐을 증명한다.
- 제어 흐름의 직접적인 전환에 제한에 두는 패러다임이다.
- 
### 2. 객체 지향
- 여러 가지가 있지만 가장 설득력 있는 것은 **다형성**이다.
- 다른 것들도 가진 것들을 소거하면 남는 특징이다.
- DIP는 다형성을 기반으로 구현할 수 있으며 이를 통해서 의존성과 제어 흐름을 역전시킬 수 있다.
- 이를 통해서 전체 시스템의 모든 소스 코드 의존성에 대한 절대적을 제어 권한을 갖을 수 있다.
- 이를 통해서 제어 흐름을 간접적으로 제한하는 것에 방점을 두는 패러다임이다.

> 더 깊히 들어가보자.<br/>
> 객체지향은 단순히 클래스를 만드는 것이 아니다.
> 
> - 할 일을 정의하고 필요한 데이터 구조를 정의하고 만들 클래스를 저의
> - 공통적인 행동과 상태를 공유하는 객체를 추상화하는 과정
> - 객체 간의 컨텍스트 내에서 협력을 통해서 이뤄내는 것이다.
> 
> ### 구현
> - 내부, 외부를 구분 짓는다. 
> - 어떤 역할로 어떤 모습으로 협업할지를 그리는 것이다.
> - 내, 외부 구분은 어떤 것을 공개하고 감출지를 결정하는 것이다.
> - 경계를 명확하게 두면서 객체의 역할과 한계를 정해서 오히려 자율성을 보장한다.
> 
> ### 자율성
> - 경계를 그어주고 그 내부에서 스스로 판단하고 행동하는 존재다.
> - 이를 캡슐화라고 한다.
> - 흔들리지 않기 위해서 접근을 통제하고 이 선을 기준으로 협업을 한다.
> 
> ### 협력
> - 객체 간 컨텍스트 내에서 서로가 서로에 요청을 해서 의사소통을 한다.
> - 요청을 해도 실패는 할 수 있다. 
> - 이러한 요청을 '메시지를 전송한다.'라고 한다.
> - 객체 간 협력, 메시지 수발신은 다형성에 의해서 '누가 수행할 것인가'를 정하게 할 수 있다. OOP의 특성이기도 하다.
> - 다형성은 상속, 인터페이스 구현으로 할 수 있다. 이를 지연 바인딩, 동적 바인딩이라고 한다.
>
> #### ＞ 구현 상속, 인터페이스 상속
> - 구현 상속은 서브 클래싱이며 서브 클래싱이라고 한다. 순수한 재사용을 목적으로 한다.
> - 인터페이스 상속은 서브 타이핑이다. 다형적인 협력을 위해서 부모-자식 간의 인터페이스 공유를 목적으로 한다.
> - 보통 상속을 재사용을 위해서 사용한다고 생각한다. 음. 반은 맞고 반은 틀리다.
    >   - 일단 상속은 부모 자식 간 강결합이 생긴다. => 설계에서 유연성이 떨어진다.
>   - 서로 너무 많이 알게 된다. => 캡슐화 위반
>   - 서브 타이밍을 위해서 한다면 문제는 없다.
> - 만약 재사용을 위한 거라면 composition이 나을 수 있다.
> 
> #### ＞ 메시지
> 1. 메시지: 객체가 다른 객체와 협력하기 위해서 사용하는 의사소통 메커니즘
> 2. 오퍼레이션: 객체가 다른 객체에 제공하는 추상적인 서비스, 메시지를 수신하는 객체의 인터페이스를 강조
> 3. 메소드: 메시지에 응답하기 위해서 실행되는 코드 블록
> 4. 퍼블릭 인터페이스: 객체가 협력에 참여하기 위해서 외부에서 수신할 수 있는 메시지 묶음
> 5. 시그니쳐: 오버레이션, 메소드의 명세
> 
> #### ＞ 디미터 법칙
> - '인접한 이웃과만 의사소통하라'를 기치로 한다.
> 1. 묻지 말고 시켜라: 내부에 대해서 파헤치지 말고 바깥에 물어보도록 한다.
> 2. 의도를 드러내는 인터페이스: 메소드가 어떻게가 아니라 무엇을 하는지를 나타내도록 한다.
> 3. 함께 모으기: ISP를 준수하면 된다. 내부 구조를 묻는 대신 직접 자신의 책임을 수행하도록 시킨다.
> - 이를 바탕으로 메시지를 보낼 수 있는 대상을 좁힌다. 
> - 추가로 체이닝을 막도록 한다. (알 필요가 없는 경우를 밖으로 내보내지 말고 안에서 처리할 수 있도록 한다.)
> 
> ### 책임
> - 협력에 참여하기 위해서 객체가 수행하는 행동을 책임이라고 한다.
> - 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합니다.
> - 목표는 필요한 정보를 가장 잘 아는 전문가에 책임을 할당하는 것이다.
>
> #### 책임을 할당하는 방법 
> - GRASP(General Responsibility Assignment Software Pattern)이 있다.
> 
> 1. InformationExpert: 책임에 걸맞는 객체에 데이터와 처리 로직을 묶는 것. 이를 통해서 스스로 처리하는 자율적인 존재가 된다.
> 2. Creator: A,B 간 결합도가 높으면 서로의 생성을 책임지는 것
> 3. Controller: 시스템 이벤틀를 처리할 객체를 만드는 것, antiCorruption과 유사하다. (물론 약간의 차이가 있긴 하다.)
> 4. LowCoupling: 객체들간, 서브 시스템들간의 상호의존도가 낮게 책임을 부여
> 5. HighCohesion: 각 객체가 밀접하게 연관된 책임들만 가지도록 구성
> 6. Polymorphism: 객체 종류 역할 개념을 부여하여 다른 일을 하도록 하는 것이다. 동적 바인딩을 이용한다.
> 7. PureFabrication: 도메인 관련이 아니면 책임을 별도로 한 곳으로 관리하는 객체를 만드는 것이다. 
> 8. Indriection: 두 객체 사이의 직접적인 커플링을 피하기 위해서 중간에 하나의 층을 두는 것이다. 보통 interface가 그 역할을 한다.
> 9. ProtectedVariations: 변경될 여지가 있는 것과 아닌 것을 분리하고 변하는 개념을 캡슐화하는 것이다.
> 
> - 이를 바탕으로 '책임 주도 설계'가 있다.
>   - 데이터보다 행동을 먼저 정하고 그에 필요한 데이터를 지정
>   - 협력이라는 문맥 안에서 책임을 결정
> 
> ### 역할
> - 협력아래서 만들어진 책임들을 모으면 역할이 된다.
> - 역할이 생기면 유연하고 재사용 가능한 협력을 할 수 있다.
> 
> 
> ### 추상화
> - 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 것을 의미한다.
> - 프로시저 추상화: 내부 상세 구현을 몰라도 인터페이스만 알면 프로시저를 사용할 수 있게 한다.
> - 데이터 추상화: 시스템의 상태를 저장할 데이터를 표현한다. 
>   
> ### 의존성
> - 협력을 하기 위해서 다른 객체를 필요로 하면 생긴다.
> - 삼단논법과 유사하게 A->B B->C ==> A -> C 와 같이 전이 될 수 있다.
> - 의존성은 의존 자체가 문제가 아니라 얼마만큼 의존하는가가 주용하다.
> - 


### 3. 함수형 프로그래밍
- 가변 변수를 상정하지 않는다. 한 번 초기화하면 절대로 변경하지 않는다.
- 이를 통해서 아키텍쳐에서 변수의 가변성을 배제한다. 이로써 경합, 교착, 동시성 문제에서 자유로와 진다.
- 함수형 프로그래밍은 변수 할당에 대한 규칙을 부과한다.

## 설계 원칙
- 패러다임을 바탕으로 몇 가지 설계 원칙을 잡을 수 있다.
- 그 중에 살펴보면 SOLID를 볼 수 있다.


> ### SRP
> - 하나의 모듈이 하나의 일만 하는 것이 아니다.
> - 단일 모듈의 변경의 이유가 하나, 오직 하나뿐이어야 한다는 것이다.
> - 즉, 하나의 모듈은 하나의 actor에 대해서만 책임져야 한다.
> - 이는 변경되는 상황에서의 전파도를 낮출 수 있어야 한다는 것, 변경될 것과 아닌 것을 분리해야 한다는 의미로까지 해석할 수 있다.
> - 이 원칙을 위반하는 징후들은 아래와 같다.
> ### OCP
> - 개채의 행위는 확장할 수 있어야 하지만, 이 때 개체를 변경하면 안 된다는 원칙이다.
> - 작은 수정에 기존이 흔들이면 연쇄적으로 이에 의존하고 있는 부분도 흔들리게 될 것이다.
> - 이를 위해서는 책임에 대한 분리, 의존성 역전 등을 해둬야 한다.
> - 이는 아키텍쳐를 떠받치는 원동력으로 작용하며, 시스템을 확장하기 쉬운 동시에 변경에 대한 파급력이 적을 수 있는 방향으로 유도해준다.
> ### LSP
> - 'S 타입의 객체와 T 타입에 대응하는 객체가 있을 때 S 타입에 대응하는 객체 O1이 T 타입의 객체 O2 대신 놓였을 때도 행위가 변하지 않는다면 S는 T의 하위 타입이다.'는 의미다.
> - 자주 나오는 주제로 상속, 구현이 있다. 결론부터 말하면 서브 타이핑이 필요하며, 서브 클래싱을 위한 상속은 큰 의미가 없다는 것이다.
> - 처음에는 LSP는 상속을 사용하도록 유도하는 장치 정도로 간주됐었다.
> - LSP는 시간이 지남에 따라서 인터페이스와 구현체에도 적용되는 설계원칙으로 변모됐다.
> - LSP를 준수하도록 만들어져 있다면 서브타이핑 하나로 새로운 기능을 추가할 수 있지만 아니라면 새롭게 코드를 작성해야 하는 안타까운 경우가 발생할 수도 있다.
> - LSP는 아키텍쳐 레벨까지 확장해야만 한다. 그게 아니라면 아키텍쳐가 오염되어 위의 언급과 같이 별도 메커니즘을 추가해야 할 수 있기 때문이다.
> ### ISP
> - 정적 타입 언어는 `import` 등의 타입 선언문을 강제한다.
> - 소스코드에 선언된 선언문으로 소스 코드 의존성이 발생하고, 이로 인해 재컴파일, 재배포가 강제되는 상황이 무조건 초래된다.
> - ISP를 사용하는 근본적인 동기는 필요 이상으로 많은 것을 포함하는 모듈에 의존하는 것에 대한 인지로부터 시작된다.
> - 불필요한 재컴파일, 재배포를 강제하기 때문이다.
> ### DIP
> - '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
> - 의존에서 피하고자 하는 것은 변동성이 큰 구체적 요소다. 이는 인터페이스보다 변동성이 높다.
> - 인터페이스를 변경하지 않고 구현체를 수정할 수 있으며, 외부에서는 인터페이스에 의존하면 안정된 아키텍쳐를 얻을 수 있다.


## 컴포넌트 원칙
- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 배포 단위다.
- SW의 재사용성의 중요성, 필요성을 위해서 나온 개념이다.

### 응집도
- 재사용/릴리즈 등가 원칙: 재사용 단위는 릴리즈 단위와 같다. -> 포함 원칙
- 공통 폐쇄 원칙(OCP의 연장): 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶는다. -> 포함 원칙
- 공통 재사용 원칙: 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라 -> 배제 원칙

### 결합
- 의존성 비순환 원칙
- 안정된 의존성 원칙: 안정된 방향으로 의존하라
- 안정된 추상 원칙: 컴포너틑는 안정된 정도만큼만 추상화되어야 한다.


## 아키텍쳐
- 시스템 생명 주기를 지원하는 것이다.
- 시스템을 쉽게 이해할 수 있게 해주고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포하게 해준다.
- 시스템의 비용을 줄이고 생산성을 끌어올리는 것에 있다.
- 제약 사항의 모음이다. 처음에는 모래주머니 같지만 시간이 지나면서 진가를 발휘한다.
- 정책과 세부 사항으로 나뉜다.
- 정책을 공고히 할 수 있게 하는 것이 목표다.
- 세부사항은 열어두고 최후에 결정해도 문제가 없을 수 있도록 하는데 있다.

> - UseCase는 시스템의 의도를 표현한다.
> - 세부 사항을 열어 놓는다.
> - 계층간 분리해서 단일 책임, 공통 폐쇄 원칙을 적용해서 다른 이유로 변경되는 것을 분리한다.
> - 중복이 생기는 경우 '의도된 것'인지 '그냥 중복'인지 고민해봐야 한다.

### 경계
- 아키텍쳐는 선을 긋는다.
- 핵심 업무 로직을 오염되는 것을 방지한다.
- 세부 사항 결정을 늦출 수 있게 한다.
- 선과 선 사이는 추상화를 통해서 DIP를 한다.
- plugInArchitecture를 할 수 있다.
- 변경의 축이 있는 지점에 그어진다.

### 정책 
- SW는 정책의 모음이다.
- 하나의 정책, 이를 구성하는 다수의 정책으로 이뤄진다.
- 변경되는 시점에 따라서 포함되는 정책은 동일 수준에 둔다.

### 수준
- 입-출력 간 거리다.
- 시스템의 입-출력에서 멀수록 정책 수준이 높다.
- 시스템의 입-출력에서 멀수록 덜 변경되고 변경되면 크리티컬하다.

### 업무 규칙 
- 규칙을 자동화하는 핵심 업무를 의미한다.
- 보통 데이터를 필요로 한다. 
- UseCase로 애플리케이션에 특화된 업무 규칙을 설명한다.


## Hexagonal
- 위의 아키텍쳐에서 필요한 것들을 준수하면 나오는 결과물이다.
- 