## 4. Topic이란?

### 개념

- 메시지의 **논리적 분류** (카테고리)
- 실제로는 **여러 Partition의 집합**
- Producer/Consumer가 메시지를 주고받는 **채널**

### Topic과 Partition의 관계

- 하나의 Topic = N개의 Partition
- Topic 생성 시 Partition 수 지정 필수
- Partition은 여러 Broker에 분산 배치

### Topic 네이밍

- **명확한 의미**: `user-events`, `order-created`
- **환경 구분**: `prod.user-events`, `dev.user-events`
- **버전 관리**: `user-events-v1`, `user-events-v2`

---
### **1. Topic 분할 기준**

- **도메인별**: `user`, `order`, `payment` 각각 분리
- **이벤트 타입별**: `created`, `updated`, `deleted` 분리
- **처리 특성별**: 실시간/배치, 중요도에 따라 분리

### **2. Schema 설계**

- **Backward Compatibility**: 기존 Consumer 호환성 유지
- **Schema Registry**: Avro/JSON Schema로 스키마 관리
- **Versioning**: 스키마 변경 시 버전 정책

### **3. Retention 정책**

- **Time-based**: `log.retention.hours=168` (7일)
- **Size-based**: `log.retention.bytes=1073741824` (1GB)
- **Compaction**: Key별 최신 값만 유지

### **4. Error Handling Topic 설계**

1. **DLQ (Dead Letter Queue) 개념**
- **실패한 메시지를 보관하는 별도 Topic**
- Consumer에서 처리 불가능한 메시지 임시 저장소
- 무한 재시도 방지 및 실패 원인 분석 용도

2. **Error Topic 패턴들**
- **DLQ Topic**: `order-events-dlq` (최종 실패 메시지)
- **Retry Topic**: `order-events-retry` (재시도 대기)
- **Poison Message Topic**: 독성 메시지 격리
- **Error Topic**: `order-events-error` (오류 정보 포함)

3. **DLQ 설계 고려사항**
- **Partition 수**: Main Topic 대비 적게 (처리량 낮음)
- **Retention**: 긴 보관 기간 (분석/복구용)
- **Schema**: 원본 + 오류 정보 (error_reason, retry_count, timestamp)
- **Consumer**: 별도 Error Handler나 Manual Processing

4. **기타 특수 Topic 패턴**
- **Changelog Topic**: 상태 변경 이력 저장
- **Compacted Topic**: Key별 최신 상태만 유지
- **Temporary Topic**: 일시적 데이터 교환용
### **5. Topic 생명주기 관리**

- **생성 정책**: 자동 vs 수동 생성
- **삭제 정책**: `delete.topic.enable=true`
- **Migration**: 기존 Topic에서 새 Topic으로 이관

### **6. Performance 고려사항**

- **Throughput**: 높은 처리량 Topic은 Partition 수 증가
- **Latency**: 낮은 지연시간 필요 시 별도 Topic 분리
- **Consumer Pattern**: 다양한 Consumer 패턴 고려한 설계

### **7. 보안 설정**

- **ACL**: Topic별 읽기/쓰기 권한 관리
- **SSL/SASL**: 암호화 및 인증 설정
- **Network Segmentation**: 민감한 데이터 Topic 격리