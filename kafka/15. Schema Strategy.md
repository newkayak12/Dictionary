### 스키마란?
- **이벤트 메시지 구조 정의**: 어떤 필드가 어떤 타입인지
- **Producer/Consumer 간의 계약**: 주고받을 데이터 형식 약속
- **Language Agnostic**: Java, Python, Node.js 등 모든 언어에서 동일하게 해석

### 스키마 호환성 전략
#### 1. Backward Compatibility
```json
// 기존 스키마
{
  "userId": "string",
  "email": "string"
}

// 새 스키마 (안전한 변경)
{
  "userId": "string", 
  "email": "string",
  "phoneNumber": "string" // Optional 추가
}
```
- **새 필드는 Optional**로만 추가
- 기존 Consumer 영향 없음
- Producer 먼저 배포, Consumer 이후 배포
#### 2. Forward Compatibility
```json
// 기존 스키마
{
  "userId": "string",
  "email": "string"
}

// 새 스키마 (안전한 변경)
{
  "userId": "string", 
  "email": "string",
  "phoneNumber": "string" // Default 추가
}
```
- 새 Consumer가 기존 이벤트 처리 가능
- Optional 필드에 Default 값 처리 로직
- Consumer 먼저 배포, Producer 나중 배포
#### 3. Breaking Change
- 필드 타입 변경: string → number
- 필수 필드 추가: 기존 이벤트에 없는 필드 
- 해결책: 새 이벤트 타입 생성 (~V2)


#### 필드 제거 전략
1. 기존 필드를 Optional로 지정
2. Producer에서 Optional 필드 제거
3. Consumer에서 Optional 필드 대응 중지 
4. 버전 정보 관리

#### 버전 정보 관리
1. 따로 Event, Version 별 스키마를 명시적으로 관리
2. Git으로 관리하면 변경 이력을 추적할 수 있다.
3. Version에 맞춰 스키마 검증을 자동화할 수도 있다.
4. 