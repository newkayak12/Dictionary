## 왜 Kafka Consumer에서 병렬 처리를 지원하지 않는가?

### 1. Offset 관리의 근본적 문제

#### 현재 Kafka 전제조건
- **Sequential Commit**: offset은 순차적으로만 commit 가능
- **Gap 없는 진행**: offset 100이 commit되면 0~99는 모두 처리 완료 의미
- **단순한 로직**: consumer restart 시 마지막 commit된 offset부터 재시작

#### 병렬 처리 시 발생하는 문제
- **처리 완료 순서 불일치**: 메시지 1,2,3을 병렬 처리 → 2,3 완료, 1 아직 처리 중
- **Commit 불가능**: offset 3을 commit하려면 1,2가 완료되어야 함
- **복잡한 State 관리**: 어떤 offset이 완료되었는지 bitmap/map으로 추적 필요
- **Restart 복잡성**: 재시작 시 어디서부터 처리해야 할지 계산 복잡

### 2. Kafka 설계 철학과 충돌

#### "Simple and Fast" 원칙
- **단순함 우선**: Kafka는 단순하고 빠른 메시징에 집중
- **복잡성 외부화**: 고급 기능은 클라이언트 라이브러리에서 처리
- **Core 기능 집중**: Produce, Consume, Replicate에만 집중

#### "One Size Doesn't Fit All"
- **다양한 병렬 전략**: Key 기반, 완전 병렬, 파티션 내 순서 등
- **성능 트레이드오프**: 병렬 처리 오버헤드 vs 처리량 증가
- **사용자별 요구사항**: 순서 보장 수준이 케이스마다 다름

### 3. 구현 복잡성의 구체적 예시

#### Error Handling 복잡성
- **부분 실패**: 병렬 처리 중 일부 메시지만 실패 시 처리 방법
- **Retry 전략**: 실패한 메시지의 재시도가 순서에 미치는 영향
- **Dead Letter Queue**: 실패 메시지 처리를 위한 추가 인프라 필요

#### Resource Management
- **Thread Pool 관리**: 적정 스레드 수 결정 알고리즘
- **Memory 사용량**: 처리 중인 메시지들의 버퍼 관리
- **Backpressure**: 처리 속도 < 유입 속도일 때 제어 메커니즘

### 4. 현실적인 대안의 존재

#### 기존 확장 방법들
- **Partition 증가**: 가장 자연스러운 확장 방법
- **Consumer Group 확장**: 인스턴스 추가로 해결
- **외부 라이브러리**: Parallel Consumer 같은 전문 라이브러리

---

## Parallel Consumer: 문제 해결 전략

### 1. Offset 관리 문제 해결

#### Completion Tracking 메커니즘

- **Bitmap/Map 기반**: 각 offset의 완료 상태를 별도 자료구조로 추적
- **Gap 관리**: offset 100, 102 완료되어도 101 대기 중이면 99까지만 commit
- **Sequential Commit**: 연속된 완료 offset까지만 안전하게 commit
- **Memory Overhead**: 처리 중인 메시지 상태를 메모리에 보관

#### 1. 상태 추적 자료구조

##### Completion Map 방식
- **Key**: Offset 번호
- **Value**: 완료 상태 (PROCESSING, COMPLETED, FAILED)
- **Memory 사용량**: 처리 중인 메시지 수 × (8 byte offset + 상태 정보)
- **조회 성능**: O(1) 상태 확인 및 업데이트

##### Bitmap 최적화
- **Bit per Offset**: 1bit = 1 offset 완료 상태
- **Memory 효율성**: Map 대비 1/64 메모리 사용 (64bit 기준)
- **연속 범위 검색**: bit manipulation으로 빠른 연속 완료 구간 탐지
- **제약사항**: Offset 범위가 너무 크면 비효율적

#### 2. Commit 시점 결정 알고리즘

##### Sequential Completion Detection
- **Gap 없는 최대 Offset 탐지**: 0번부터 연속으로 완료된 최대 offset 찾기
- **예시**: [완료: 0,1,2,4,5] → commit할 수 있는 offset = 2
- **Sliding Window**: 새 완료가 생길 때마다 commit 가능 offset 재계산

##### Periodic vs Immediate Commit
- **Periodic**: 일정 주기마다 commit (배치 처리 효율성)
- **Immediate**: 완료 즉시 commit 시도 (지연시간 최소화)
- **Hybrid**: Gap 상황에 따라 동적 선택

#### 3. Memory Management 전략

##### Max In-Flight 제한
- **동시 처리 제한**: 메모리 사용량 상한선 설정
- **Backpressure**: 제한 도달 시 새 메시지 fetch 중단
- **Adaptive Sizing**: 가용 메모리에 따른 동적 조정
##### Memory 회수 전략
- **Commit 후 정리**: offset commit 성공 시 해당 상태 정보 삭제
- **Sliding Window**: 오래된 완료 상태부터 순차적 회수
- **Emergency Cleanup**: 메모리 부족 시 강제 commit 및 정리
#### 4. 성능 영향도 분석

##### CPU 오버헤드
- **상태 업데이트**: 메시지 처리마다 completion map 업데이트
- **Commit 계산**: 연속 완료 구간 탐지를 위한 연산
- **Trade-off**: 병렬 처리 이득 >> 상태 관리 오버헤드
##### Memory 오버헤드
- **기본 사용량**: 메시지당 16~32 byte (offset + 상태 + metadata)
- **최대 사용량**: max_in_flight × 32 byte (대략적 추정)
- **실제 영향**: 10K in-flight → 약 320KB 추가 메모리
##### Latency 영향
- **Processing Latency**: 병렬 처리로 대폭 개선
- **Commit Latency**: Gap 발생 시 commit 지연 가능
- **Overall**: 대부분 케이스에서 전체 지연시간 감소
##### 재시작 시 안전성
- **Last Committed 기준**: 일반 Consumer와 동일하게 마지막 commit부터 재시작
- **중복 처리 허용**: 처리 완료되었지만 commit 안 된 메시지는 재처리
- **At-least-once 보장**: 메시지 손실 없이 최소 1회 처리 보장


### 2. 순서 보장 전략 선택권

#### Key-Level Parallelism

- **같은 Key는 순서 보장**: 동일 키 메시지는 동일 스레드에서 순차 처리
- **다른 Key는 병렬**: 키별로 독립적인 처리 흐름 제공
- **Hash 기반 라우팅**: Key hash로 스레드 할당 결정
##### 상세 동작

 **핵심 메커니즘**
- **Key Hash 기반 라우팅**: `key.hashCode() % threadPoolSize`로 스레드 결정
- **Per-Key 순서 보장**: 동일 키는 항상 같은 스레드에서 순차 처리
- **Cross-Key 병렬성**: 서로 다른 키는 완전 병렬로 동시 처리

 **성능 특성**
- **Hot Key 문제**: 특정 키에 메시지 집중 시 해당 스레드만 바쁨
- **Key 분산도**: 키 분산이 고르지 않으면 스레드 활용도 불균등
- **Load Balancing**: 키 분포에 따라 성능이 크게 좌우됨

#### Unordered Parallelism

- **완전 병렬**: 모든 메시지를 순서 무관하게 병렬 처리
- **최대 성능**: 순서 제약 없이 최대 처리량 달성
- **Offset Gap 최대화**: 완료 순서와 메시지 순서 완전 무관
##### 상세 동작

 **완전 병렬 처리**
- **순서 무시**: 메시지 도착 순서와 처리 완료 순서 완전 무관
- **Round-Robin 배정**: 들어오는 순서대로 Available Thread에 할당
- **최대 처리량**: 순서 제약 없이 CPU/IO 자원 최대 활용
 **주의사항**
- **Offset Gap 최대화**: 완료 순서 불규칙으로 Gap 많이 발생
- **Memory 사용량 증가**: 대기 중인 완료 상태를 모두 메모리에 보관
- **Rebalancing 영향**: Gap이 클수록 재시작 시 중복 처리량 증가

#### Partition-Level (기본)

- **기존과 동일**: 파티션 내 완전 순서 보장
- **리소스 최적화**: Consumer Group보다 효율적인 리소스 사용
##### 상세 동작

 **핵심 메커니즘**
- **Ordered Processing Within Partition**: 파티션 내 메시지를 순서대로 하나씩 처리
- **Multi-Thread Pool per Partition**: 각 파티션별로 독립적인 스레드풀 운영
- **Sequential Ordering**: 파티션 내에서는 완전한 순서 보장 (기존 Consumer와 동일)

**내부 동작 방식**
- **FIFO Queue per Partition**: 각 파티션별로 메시지 큐 관리
- **Worker Thread Assignment**: 파티션당 여러 스레드 할당하되 순차 처리
- **Completion 순서 보장**: offset N+1은 offset N 완료 후에만 commit

**리소스 최적화 포인트**
- **Connection Reuse**: 파티션별 Consumer 대신 1개 Consumer로 모든 파티션 처리
- **Memory Sharing**: 공통 스레드풀과 메모리 버퍼 공유
- **Reduced Coordination**: Rebalancing 오버헤드 최소화
- **Efficient Polling**: 단일 poll()로 모든 파티션 데이터 가져오기

### 3. Error Handling 및 복원력

#### Individual Message ACK

- **메시지별 처리**: 각 메시지 성공/실패를 독립적으로 관리
- **선택적 Retry**: 실패한 메시지만 골라서 재시도 가능
- **DLQ 연동**: 재시도 한계 초과 시 Dead Letter Queue로 전송

#### Backpressure 제어

- **Max In-Flight**: 동시 처리 중인 메시지 수 제한
- **Memory Protection**: OOM 방지를 위한 버퍼 크기 제한
- **Flow Control**: 처리 속도에 맞춰 fetch 속도 조절

### 4. 성능 최적화 전략

#### Thread Pool 최적화

- **I/O vs CPU 구분**: 작업 특성에 맞는 스레드풀 크기 설정
- **Non-blocking 지원**: Vert.x, Reactor 같은 비동기 프레임워크 연동
- **Resource Pooling**: 스레드 생성/소멸 오버헤드 최소화

#### Batch 처리 지원

- **Micro-batching**: 여러 메시지를 묶어서 효율적 처리
- **Transaction 최적화**: 배치 단위로 DB transaction 처리
- **Network 효율성**: API 호출을 배치로 묶어서 처리