### Event-driven MicroServices 특징 

**느슨한 결합 (Loose Coupling)**
- **서비스 간 직접 의존성 제거**: 서비스끼리 서로 모름 
- **이벤트만 알면 됨**: 누가 발행하는지, 누가 소비하는지 몰라도 됨 
- **독립적 배포**: 한 서비스 변경이 다른 서비스에 영향 없음 **비동기 통신** 
- **Non-blocking**: 이벤트 발행 후 즉시 다음 작업 
- **높은 처리량**: 동기 대기 없이 병렬 처리 
- **장애 격리**: 한 서비스 장애가 다른 서비스 차단 안함


-----
### 1. 서비스 경계 설정

**Domain-driven Design 기반** 
- **Bounded Context**: 도메인별 명확한 경계 
- **단일 책임**: 하나의 비즈니스 기능에 집중
- **데이터 소유권**: 각 서비스가 자신의 데이터만 소유


### 2. Event 설계 패턴 Domain Events 

- **비즈니스 의미**: 도메인 전문가가 이해할 수 있는 이벤트 
- **과거형 명명**: OrderCreated, PaymentCompleted 
- **Rich Events vs Thin Events**: 필요한 모든 정보 포함 vs 최소 정보만


### 3. 통신 패턴 Publish-Subscribe 

- **1:N 통신**: 하나의 이벤트를 여러 서비스가 구독 
- **새 구독자 추가 용이**: 기존 발행자 변경 없이 새 소비자 
- **Event Catalog**: 어떤 이벤트가 있는지 중앙 관리 **Event Streaming** 
- **연속적 이벤트**: 무한한 이벤트 스트림 처리 
- **Stateful Processing**: 이벤트 간 상태 유지하며 처리 
- **Real-time Analytics**: 실시간 집계 및 분석

### 4. 데이터 일관성 관리 Eventually Consistent 

- **로컬 일관성**: 각 서비스 내부는 강한 일관성 
- **글로벌 일관성**: 서비스 간은 최종 일관성 
- **Compensation**: 불일치 발생 시 보정 메커니즘


### 5. 장애 처리 및 복원력 Circuit Breaker for Events 

- **이벤트 발행 실패**: Event Bus 장애 시 처리 
- **Dead Letter Queue**: 처리 실패한 이벤트 격리 
- **Retry with Backoff**: 일시적 장애 대응 **Event Replay** 
- **서비스 복구**: 장애 후 누락된 이벤트 재처리 
- **새 서비스 Bootstrap**: 기존 이벤트로 초기 상태 구성 
- **Bug Fix**: 잘못 처리된 이벤트 재처리