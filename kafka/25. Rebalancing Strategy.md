참고: [[11. Rebalancing]]

## Rebalancing
1. 파티션 소유권 재분배: Consumer 간 Partition 할당 재조정
2. 목적: Consumer Group의 확장성, 가용성 확보
3. 단점: Rebalancing 중 메시지 처리 중단, LAG 증가 가능

## Condition
1. Consumer 추가·제거·장애
2. Partition 수 변경
3. 구독 Topic 변경
4. heart beat timeout(`session.timeout.ms` 초과)

## Risks
1. 메시지 처리 중단
2. Consumer Lag 급증
3. 중복 처리

## 방식

### 1. Eager Rebalance
- Range, RoundRobin, Sticky
- 모든 Consumer가 Partition 포기(Stop-the-world)
- 전체 중단 후 재할당
- Kafka 2.4 이전 기본 값

### 2. Co-operative/ Incremental Rebalance
1. CooperativeSticky 적용
2. 필요한 파티션만 점진적 이동
3. 나머지 Consumer는 계속 작업
4. Kafka 2.4+ 기본 값

---

## Eager
### 1. Range
1. 동작
	1. **Topic 별로 독립적으로 처리**
	2. Partition 번호 순으로 정렬
	3. Consumer 이름 순으로 정렬
	4. 각 Topic 마다 (`Partition 수 / Consumer 수`) 계산
	5. 나머지 Partition은 앞쪽 Consumer에 추가 할당
2. 장점
	1. 동일 Partition 번호가 같은 Consumer로 할당 
	2. 연관 데이터 처리에 유리
	3. 구현 자체가 간단
3. 단점
	1. Topic 수가 많으면 불균등 심화
	2. Rebalancing 많은 Partition 이동
4. UseCase
	1. 동일 키의 데이터가 여러 Topic에 분산된 경우
	2. Topic 간 Join이 필요한 경우

```
Topic A: 6 partitions (A0, A1, A2, A3, A4, A5)
Topic B: 6 partitions (B0, B1, B2, B3, B4, B5) 
Consumers: 3 (C1, C2, C3) 

할당 결과:
C1: A0, A1 | B0, B1 (4개) 
C2: A2, A3 | B2, B3 (4개)
C3: A4, A5 | B4, B5 (4개)

> 리밸런싱 (C3 제거)
할당 결과:
C1: A0, A1, A2 | B0, B1, B2 (6개)
C2: A3, A4, A5 | B3, B4, B5 (6개)
```

### 2. RoundRobin
1. 동작
	1. **모든 Topic-Partition을 하나의 List로**
	2. Topic-Partition을 `Topic name, Partition name` 순으로 정렬
	3. Consumer를 이름 순으로 정렬
	4. Partition을 순회하며 Consumer에 RoundRobin으로 할당
2. 장점
	1. 균등 분배 보장
	2. 모든 Consumer 활용
	3. 간단한 로직
3. 단점
	1. Rebalancing 시 Partition 대규모 이동
	2. 기존 할당 정보 무시
	3. 연관 데이터 처리 불리
4. UseCase
	1. Topic 간 연관성 없는 경우
	2. 균등 부하 분산이 최우선인 경우
	3. Rebalancing 빈도가 낮은 경우
	4. 

```
Topic A: 3 partitions (A0, A1, A2)
Topic B: 3 partitions (B0, B1, B2)
Consumers: 3 (C1, C2, C3)

할당 결과: 
C1: A0, B0 (2개) 
C2: A1, B1 (2개)
C3: A2, B2 (2개)

> 리밸런싱 (C3 제거)
할당 결과:
C1: A0, A2, B1 (3개)
C2: A1, B0, B2 (3개)
```

### 3. Sticky
1. 동작
	1. **기존 할당 정보를 최대한 유지**
	2. 균등 분배 목표(max - min <= 1)
	3. Rebalancing 발생 시:
		1. 제거된 Consumer의 Partition만 재분배
		2. 기존 Consumer는 Partition 유지
		3. 균등성 유지하며 최소 이동
2. 장점
	1. Rebalancing 시 Partition 이동 최소화
	2. Consumer 상태/ 캐시 유지 가능
	3. 균등 분배도 보장
	4. Rebalancing 시간 단축
3. 단점
	1. 계산 복잡도가 높음
	2. 초기 할당은 RoundRobin과 유사
	3. 여전히 Eager
4. UseCase
	1. Consumer가 Partition 상태 유지
	2. Rebalancing 빈도가 높은 환경
	3. Rebalancing 비용 최소화 필요


```
Topic A: 3 partitions 
Topic B: 3 partitions
Consumers: 3 (C1, C2, C3)

할당 결과 (RoundRobin과 유사): 
C1: A0, B0 
C2: A1, B1 
C3: A2, B2

> 리밸런싱 (C3 제거)
할당 결과:
C1: A0, B0, A2 ← A2만 추가 
C2: A1, B1, B2 ← B2만 추가
```

## Co-operative/ Incremental Rebalance
### 1. CooperativeSticky
1. 동작
	1. Sticky의 할당 로직 + Cooperative Rebalance 방식
2. 핵심 프로토콜
	1. Sticky: 할당은 유지하지만 전체 중단(Eager)
	2. CooperativeSticky: 할당 유지 + 부분 중단
3. 장점
	1. 가용성 극대화
	2. Sticky의 할당 최적화 유지
	3. 대규모 Consumer Group에 적합
	4. LAG 급증 방지
4. 단점
	1. 여러 라운드 필요
	2. 구현 복잡도 높음
	3. Kafka 2.4+ 필요
5. UseCase
	1. 일반 Production 환경
	2. 대규모 Consumer Group (50 개 이상)
	3. 실시간 처리 시스템
	4. Rebalancing이 잦은 환경

```
Topic A: 3 partitions (A0, A1, A2)
Topic B: 3 partitions (B0, B1, B2)
Consumers: 3 (C1, C2, C3)

할당:
C1: A0, B0
C2: A1, B1
C3: A2, B2

> 리밸런싱 (C3 제거)
1차: 
C1: [A0, B0]
C2: [A1, B1]
(C3는 응답 없음) -> A2, B2 중단

2차: 균등 분배 → C1에 A2, C2에 B2
C1: [A0, B0, A2] ← A2 추가 
C2: [A1, B1, B2] ← B2 추가

> 리밸런싱 (C3 추가)
1차:
C1: [A0, A1, B0] 
C2: [A2, B1, B2]
C3: [] (신규)

목표: 각 2개씩 (6개 / 3 = 2) 
C1에서 A1 철회
C2에서 B2 철회

2차: 
C1: [A0, B0] (변경 없음) 
C2: [A2, B1] (변경 없음) 
C3: [A1, B2] ← 새로 할당

```


| \            | Range          | RoundRobin     | Sticky         | CooperativeSticky |
| ------------ | -------------- | -------------- | -------------- | ----------------- |
| **균등성**      | △ (토픽 많으면 불균등) | ◎              | ◎              | ◎                 |
| **파티션 이동**   | 많음             | 많음             | 가장 적음          | 가장 적음             |
| **가용성**      | 낮음             | 낮음             | 낮음             | 최고                |
| **중단 시간**    | Stop-the-world | Stop-the-world | Stop-the-world | **부분만**           |
| **연관 데이터**   | ◎ (같은 번호)      | ×              | ×              | ×                 |
| **계산 복잡도**   | 낮음             | 낮음             | 높음             | 가장 높음             |
| **Kafka 버전** | All            | All            | 0.11+          | **2.4+**          |


## Consumer Group Coordinator
### 정의
- GroupCoordinator: 특정 Consumer Group을 관리하는 브로커
- Consumer Group 마다 담당 Broker가 배정
- `__consumer_offsets` 토픽의 Partition leader broker가 담당
- 백그라운드 프로스세스 실행

### 역할
1. 멤버십 관리
	1. Consumer 추가
		1. Consumer ➡️ JoinGroup Request ➡️ [GroupCoordinator] ➡️ 멤버 추가 + Rebalancing 트리거
	2. Consumer 제거
		1. Consumer ➡️ Heartbeat 중단 ➡️ [GroupCoordinator] ➡️ session.timeout 감지 -> 멤버 제거 +Rebalancing 트리거
2. Heartbeat 모니터링
	1. 마지막 수신 시간을 갱신하면서 '정상' 여부 판단
	2. 만약 `session.timout.ms` 충족하지 못하면 '응답 없음'
3. Rebalancing 조율
	1. JoinGroup 요청 수집
	2. Group leader 선출
	3. Leader에게 메타데이터 전달
	4. Leader 할당 결과 수신 및 멤버에 통보
4. offsets 커밋 및 조회