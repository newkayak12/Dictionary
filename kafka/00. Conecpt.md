## 1. Kafka 기본 개념과 아키텍처

### 핵심 컴포넌트

- **Kafka 클러스터**: 여러 Broker로 구성된 분산 시스템
- **Broker**: Kafka 서버 인스턴스. 메시지 저장/전달 담당
- **Topic**: 메시지 카테고리. 논리적 메시지 분류 단위
- **Partition**: Topic의 물리적 분할 단위. 병렬 처리와 확장성 제공
- **Producer**: 메시지 발행자. Topic에 메시지 전송
- **Consumer**: 메시지 구독자. Topic에서 메시지 소비
- **Consumer Group**: 동일 Topic을 병렬로 소비하는 Consumer들의 집합

### 근본 철학
#### 왜 메모리가 아닌 디스크에 저장하는가?
1. 대용량 데이터 처리
	- **메모리 한계**: GB 단위 메모리 vs TB 단위 디스크
	- **비용 효율성**: 디스크가 메모리보다 GB당 비용 월등히 저렴
	- **데이터 영속성**: 서버 재시작해도 데이터 보존
2. 예측 가능한 성능
	- **메모리**: GC, 메모리 압박 시 성능 급락
	- **디스크**: Sequential I/O로 일정한 성능 보장
	- **Linear Scale**: 디스크 용량에 비례한 처리량 확장
#### 디스크인데 왜 이렇게 빠른가?
1. Sequential I/O 활용 (헤드의 물리적 이동 최적화)
	- **Random I/O**: HDD 100 IOPS, SSD 10K IOPS
	- **Sequential I/O**: HDD 100MB/s+, SSD 500MB/s+
	- **Kafka 방식**: 파일 끝에만 Append, 순차 읽기
2. OS Page Cache 극대화 (JVM을 우회하는 방식으로 최적화)
	- **JVM Heap 최소화**: GC 부담 제거
	- **OS가 메모리 관리**: 더 효율적인 캐싱
	- **Double Caching 방지**: JVM + OS 중복 캐싱 제거
3. Batch 처리
	- **작은 메시지 묶기**: 디스크 I/O 횟수 최소화
	- **Network Batch**: 네트워크 라운드트립 감소
#### Log-structured Storage의 원리
0. Log 구조?
	1. 시간순 기록
	2. 수정 불가
	3. 순차 접근
1. Append-Only 구조
2. 순차 쓰기의 장점
	- **No Random Access**: 파일 중간 수정 없음
	- **Simple Structure**: 복잡한 인덱스 불필요
	- **High Throughput**: 디스크의 최대 성능 활용
3. 시간 기반 삭제
	- **Old Segment 삭제**: retention 시간 지나면 파일 단위 삭제
	- **No Garbage Collection**: 개별 메시지 삭제 없음
#### OS Page Cache 활용
1. 메모리 계층 최적화
```
Producer → OS Page Cache → Disk
Consumer ← OS Page Cache ← Disk (캐시 히트 시)
```

2. JVM Heap 우회
	- **Direct I/O**: JVM 메모리 거치지 않음
	- **GC 압박 제거**: 대용량 데이터도 GC 영향 없음
	- **OS 최적화**: OS가 더 잘 아는 메모리 관리

3. Warm-up 효과
	- **Recent Data**: 최근 데이터는 페이지 캐시에 상주
	- **Producer-Consumer 지연**: 짧은 지연으로 메모리에서 직접 읽기
#### Zero-Copy 최적화
1. 전통적인 데이터 복사
```
Disk → Kernel Buffer → User Space → Kernel Buffer → Network
(4번 복사, 2번 컨텍스트 스위치)
```

2. Zero-Copy (sendfile)
```
Disk → Kernel Buffer → Network
(1번 복사, 컨텍스트 스위치 최소화)
```

3. 성능 영향
- **CPU 사용량**: 70% 이상 감소
- **처리량**: 2-3배 향상
- **지연시간**: 현저한 감소

4. Kafka 적용
- **Consumer**: 디스크에서 네트워크로 직접 전송
- **Replication**: Follower로의 복제도 Zero-Copy


### 분산 아키텍처 원리

**왜 분산인가?**

- 대용량 데이터 처리를 위한 수평 확장성
- 단일 장애점 제거를 통한 고가용성
- 지리적 분산을 통한 지연시간 최적화

**Partition의 존재 이유**

- **병렬성**: 여러 Consumer가 동시에 다른 Partition 처리
- **순서 보장**: Partition 내에서만 메시지 순서 보장
- **확장성**: Partition 수 = 최대 Consumer 수

### 메시지 저장 구조

```
Topic: user-events
├── Partition 0: [msg0, msg3, msg6, ...]
├── Partition 1: [msg1, msg4, msg7, ...]
└── Partition 2: [msg2, msg5, msg8, ...]
```

**Offset 메커니즘**

- 각 Partition 내 메시지의 고유 순번
- Consumer가 읽을 위치 추적
- 불변성: 한 번 할당되면 변경 불가

**Replication Factor**

- 데이터 복제본 수 (일반적으로 3)
- Leader Partition: 읽기/쓰기 담당
- Follower Partition: Leader 복제본 유지

**Log Retention**

- 시간 기반: 7일 후 삭제
- 크기 기반: 1GB 초과 시 삭제
- Compaction: 키별 최신 메시지만 유지

### 메시지 순서 보장 전략

- **Partition 레벨**: 같은 Partition 내 순서 보장
- **Key 기반 라우팅**: 동일 키 → 동일 Partition
- **Global 순서**: 전체 Topic에서 순서 필요 시 Partition 1개 사용