### 개념

- Kafka에서 **메시지를 읽어오는** 클라이언트
- Topic의 Partition에서 **순차적으로 메시지 소비**
- **Pull 방식**으로 자신의 속도에 맞춰 메시지 요청

### Pull vs Push 모델

- **Pull (Kafka)**: Consumer가 능동적으로 메시지 요청
- **Push (RabbitMQ)**: Broker가 Consumer에게 메시지 전송
- **Pull의 장점**: Consumer 처리 속도에 맞춤, 백프레셔 자연스럽게 해결

### 메시지 소비 과정

- **Subscribe**: 소비할 Topic 지정
- **Poll**: Broker에게 메시지 요청
- **Process**: 받은 메시지 처리
- **Commit**: 처리 완료 위치(Offset) 기록

### Fetch 동작

- **fetch.min.bytes**: 최소 가져올 데이터 크기
- **fetch.max.wait.ms**: 데이터 부족 시 대기 시간
- **max.poll.records**: 한 번에 가져올 최대 레코드 수

---
### **1. 처리 패턴별 최적화**

- **실시간 처리**: fetch.max.wait.ms=0, 즉시 반환
- **배치 처리**: fetch.min.bytes 크게, 묶어서 처리
- **고처리량**: max.poll.records 증가, 병렬 처리

### **2. Back Pressure 관리**

- **Consumer Lag**: 처리 속도 < 생산 속도 시 지연 누적
- **max.poll.interval.ms**: 처리 시간 한계 설정
- **Pause/Resume**: 일시적으로 특정 Partition 소비 중단

### **3. 오류 처리 전략**

- **Skip**: 문제 메시지 건너뛰기 (로그 남기고)
- **Retry**: 재시도 로직 (Dead Letter Queue 활용)
- **Stop**: 처리 중단 후 수동 개입

**4. 성능 튜닝**

- **Session Timeout**: heartbeat 주기와 장애 감지 시간
- **Poll Timeout**: poll() 호출 시 대기 시간
- **Processing Time**: 메시지 처리 시간 최적화

### **5. Offset 관리 전략**

- **Auto Commit**: 편리하지만 중복/손실 위험
- **Manual Commit**: 안전하지만 복잡성 증가
- **Batch Commit**: 성능과 안정성의 균형

### **6. 멀티스레드 처리**

- **Thread per Partition**: Partition별 독립 처리
- **Worker Thread Pool**: 메시지 처리만 별도 스레드
- **동시성 고려사항**: Offset 커밋 순서, 예외 처리