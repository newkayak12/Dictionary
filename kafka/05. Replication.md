## 5. Replication이란?

### 개념

- Partition의 **복제본을 여러 Broker에 저장**
- 데이터 손실 방지와 **고가용성** 보장
- **Replication Factor**로 복제본 수 설정 (보통 3)

### Leader/Follower 구조

- **Leader Partition**: 모든 읽기/쓰기 요청 처리
- **Follower Partition**: Leader의 데이터를 지속적으로 복제
- Leader 장애 시 Follower 중 하나가 새 Leader로 선출

### 복제 과정

- **Pull-based**: Follower가 Leader에서 데이터 가져옴
- **비동기 복제**: Leader가 즉시 응답, Follower는 나중에 동기화
- **Fetch Request**: Follower가 주기적으로 Leader에게 요청


---
### **1. Replication Factor 설정**

- **RF=1**: 복제 없음, 성능 최고/안정성 최악
- **RF=3**: 일반적 권장값, 2개 Broker 장애까지 허용
- **RF=5**: 금융권 등 초고가용성 요구 환경

### **2. Leader Election 전략**

- **Clean Leader Election**: ISR 내에서만 Leader 선출 (데이터 안전)
- **Unclean Leader Election**: ISR 밖에서도 선출 (가용성 우선)
- **Preferred Leader**: 원래 Leader로 복구 시도

### **3. 일관성 수준**

- **Eventual Consistency**: 결국 모든 Replica 동일해짐
- **Strong Consistency**: acks=all로 모든 ISR 동기화 대기
- **Read Your Writes**: Producer가 쓴 데이터는 즉시 읽기 가능

### **4. Split-Brain 방지**

- **Controller Election**: ZooKeeper/KRaft로 단일 Controller 보장
- **Quorum**: 과반수 Broker가 살아있어야 동작
- **Fencing**: 이전 Leader의 쓰기 차단

### **5. Cross-AZ Replication**

- **Rack Awareness**: 동일 랙 장애 대비 분산 배치
- **Availability Zone**: 물리적 격리를 통한 장애 허용
- **Network Latency**: AZ 간 지연시간이 성능에 미치는 영향

### **6. 복제 성능 최적화**

- **replica.fetch.max.bytes**: Follower가 한 번에 가져올 데이터 크기
- **replica.lag.time.max.ms**: ISR 제외 기준 시간
- **num.replica.fetchers**: 병렬 복제 스레드 수

⚠️ ISR?