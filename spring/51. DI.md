# 1. 전략
1. **Constructor Injection (권장)**

- **불변성 보장**: final 필드 사용 가능
- **순환 참조 조기 발견**: 객체 생성 시점에 즉시 감지
- **필수 의존성 명시**: null 불가능한 의존성 표현

2. **Setter Injection**

- **선택적 의존성**: @Autowired(required=false) 지원
- **재구성 가능**: 런타임에 의존성 변경 가능
- **순환 참조 허용**: 3단계 캐시로 해결

3. **Field Injection (비권장)**

- **테스트 어려움**: 리플렉션 기반, 모킹 복잡
- **DI 컨테이너 결합**: 순수 자바 객체 생성 불가

# 2. 생성자 선택 방식
```java
// org.springframework.beans.factory.support.ConstructorResolver
public class ConstructorResolver {

    /**
     * 생성자 자동 와이어링 메인 로직
     * Spring이 어떤 생성자를 선택할지 결정하는 핵심 메서드
     */
    public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
            @Nullable Constructor<?>[] ctors, @Nullable Object[] explicitArgs) {
        
        BeanWrapperImpl bw = new BeanWrapperImpl();
        this.beanFactory.initBeanWrapper(bw);

        Constructor<?> constructorToUse = null;
        ArgumentsHolder argsHolderToUse = null;
        Object[] argsToUse = null;

        // 1. 명시적 인수가 주어진 경우 (프로그래밍 방식)
        if (explicitArgs != null) {
            argsToUse = explicitArgs;
        }
        else {
            // 2. 캐시된 생성자 정보 확인
            Object[] argsToResolve = null;
            synchronized (mbd.constructorArgumentLock) {
                constructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;
                if (constructorToUse != null && mbd.constructorArgumentsResolved) {
                    // 이미 해결된 생성자가 있으면 재사용
                    argsToUse = mbd.resolvedConstructorArguments;
                    if (argsToUse == null) {
                        argsToResolve = mbd.preparedConstructorArguments;
                    }
                }
            }
            // 캐시된 인수 해결
            if (argsToResolve != null) {
                argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
            }
        }

        // 3. 생성자 후보군 결정
        if (constructorToUse == null || argsToUse == null) {
            Constructor<?>[] candidates = ctors;
            if (candidates == null) {
                Class<?> beanClass = mbd.getBeanClass();
                try {
                    // @Autowired가 없으면 public 생성자만, 있으면 모든 생성자 고려
                    candidates = (mbd.isNonPublicAccessAllowed() ?
                            beanClass.getDeclaredConstructors() : beanClass.getConstructors());
                }
                catch (Throwable ex) {
                    throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                            "Resolution of declared constructors on bean Class [" + beanClass.getName() +
                            "] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);
                }
            }

            // 4. 생성자가 하나뿐이고 인수도 없는 경우 (기본 생성자)
            if (candidates.length == 1 && explicitArgs == null && !mbd.hasConstructorArgumentValues()) {
                Constructor<?> uniqueCandidate = candidates[0];
                if (uniqueCandidate.getParameterCount() == 0) {
                    // 기본 생성자 사용 - 가장 빠른 경로
                    synchronized (mbd.constructorArgumentLock) {
                        mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;
                        mbd.constructorArgumentsResolved = true;
                        mbd.resolvedConstructorArguments = EMPTY_ARGS;
                    }
                    bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));
                    return bw;
                }
            }

            // 5. @Autowired 어노테이션 확인
            boolean autowiring = (chosenCtors != null ||
                    mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
            ConstructorArgumentValues resolvedValues = null;

            int minNrOfArgs;
            if (explicitArgs != null) {
                minNrOfArgs = explicitArgs.length;
            }
            else {
                // 생성자 인수 값 추출
                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                resolvedValues = new ConstructorArgumentValues();
                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
            }

            // 6. 생성자 정렬 - 매개변수 개수 순 (많은 것부터)
            AutowireUtils.sortConstructors(candidates);
            int minTypeDiffWeight = Integer.MAX_VALUE;
            Set<Constructor<?>> ambiguousConstructors = null;
            Deque<UnsatisfiedDependencyException> causes = null;

            // 7. 각 생성자 후보 평가
            for (Constructor<?> candidate : candidates) {
                int parameterCount = candidate.getParameterCount();

                // 이미 더 적은 인수로 만족하는 생성자를 찾았다면 중단
                if (constructorToUse != null && argsToUse != null && argsToUse.length > parameterCount) {
                    break;
                }
                // 최소 인수 개수보다 적으면 스킵
                if (parameterCount < minNrOfArgs) {
                    continue;
                }

                ArgumentsHolder argsHolder;
                Class<?>[] paramTypes = candidate.getParameterTypes();
                if (resolvedValues != null) {
                    try {
                        // 매개변수 이름 확인 (@ConstructorProperties 또는 디버그 정보)
                        String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);
                        if (paramNames == null) {
                            ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                            if (pnd != null) {
                                paramNames = pnd.getParameterNames(candidate);
                            }
                        }
                        // 인수 해결 시도
                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                                getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);
                    }
                    catch (UnsatisfiedDependencyException ex) {
                        // 의존성 해결 실패 - 다음 생성자 시도
                        if (logger.isTraceEnabled()) {
                            logger.trace("Ignoring constructor [" + candidate + "] of bean '" + beanName + "': " + ex);
                        }
                        if (causes == null) {
                            causes = new ArrayDeque<>(1);
                        }
                        causes.add(ex);
                        continue;
                    }
                }
                else {
                    // 명시적 인수 사용
                    if (parameterCount != explicitArgs.length) {
                        continue;
                    }
                    argsHolder = new ArgumentsHolder(explicitArgs);
                }

                // 8. 타입 차이 가중치 계산 (가장 적은 변환이 필요한 생성자 선택)
                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                        argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                
                // 더 적은 타입 차이를 가진 생성자 선택
                if (typeDiffWeight < minTypeDiffWeight) {
                    constructorToUse = candidate;
                    argsHolderToUse = argsHolder;
                    argsToUse = argsHolder.arguments;
                    minTypeDiffWeight = typeDiffWeight;
                    ambiguousConstructors = null;
                }
                else if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {
                    // 동일한 가중치를 가진 생성자가 여러 개면 모호성 표시
                    if (ambiguousConstructors == null) {
                        ambiguousConstructors = new LinkedHashSet<>();
                        ambiguousConstructors.add(constructorToUse);
                    }
                    ambiguousConstructors.add(candidate);
                }
            }

            // 9. 최종 검증 및 캐싱
            if (constructorToUse == null) {
                if (causes != null) {
                    UnsatisfiedDependencyException ex = causes.removeLast();
                    for (Exception cause : causes) {
                        this.beanFactory.onSuppressedException(cause);
                    }
                    throw ex;
                }
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        "Could not resolve matching constructor " +
                        "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");
            }
            else if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                        "Ambiguous constructor matches found in bean '" + beanName + "' " +
                        "(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " +
                        ambiguousConstructors);
            }

            // 결과 캐싱
            if (explicitArgs == null && argsHolderToUse != null) {
                argsHolderToUse.storeCache(mbd, constructorToUse);
            }
        }

        Assert.state(argsToUse != null, "Unresolved constructor arguments");
        // 최종 인스턴스 생성
        bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));
        return bw;
    }
}
```
- **생성자 선택 우선순위:**

	- **단일 생성자**: 무조건 선택 (매개변수 유무 무관)
	- **@Autowired 명시**: 해당 생성자 우선
	- **매개변수 개수**: 많은 것부터 평가
	- **타입 매칭**: 가장 적은 타입 변환 필요한 것 선택

# 3. 생성 타이밍 전략
```java
// org.springframework.beans.factory.support.DefaultListableBeanFactory
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory {

    /**
     * 모든 싱글톤 빈의 미리 인스턴스화 (Eager 초기화)
     * ApplicationContext 시작 시 호출됨
     */
    public void preInstantiateSingletons() throws BeansException {
        if (logger.isTraceEnabled()) {
            logger.trace("Pre-instantiating singletons in " + this);
        }

        // 모든 빈 정의 이름 리스트 복사 (동시성 문제 방지)
        List<String> beanNames = new ArrayList<>(this.beanDefinitionNames);

        // 1단계: 일반 싱글톤 빈들 생성
        for (String beanName : beanNames) {
            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            
            // Lazy가 아니고, 싱글톤이며, 추상 클래스가 아닌 경우에만 미리 생성
            if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
                if (isFactoryBean(beanName)) {
                    // FactoryBean의 경우 "&" 접두사로 FactoryBean 자체를 먼저 생성
                    Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    if (bean instanceof FactoryBean) {
                        FactoryBean<?> factory = (FactoryBean<?>) bean;
                        boolean isEagerInit;
                        if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                            isEagerInit = AccessController.doPrivileged(
                                    (PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
                                    getAccessControlContext());
                        }
                        else {
                            isEagerInit = (factory instanceof SmartFactoryBean &&
                                    ((SmartFactoryBean<?>) factory).isEagerInit());
                        }
                        if (isEagerInit) {
                            // SmartFactoryBean이고 eager 설정이면 실제 객체도 미리 생성
                            getBean(beanName);
                        }
                    }
                }
                else {
                    // 일반 빈은 바로 생성
                    getBean(beanName);
                }
            }
        }

        // 2단계: SmartInitializingSingleton 콜백 실행
        // 모든 싱글톤 생성 완료 후 실행되는 초기화 로직
        for (String beanName : beanNames) {
            Object singletonInstance = getSingleton(beanName);
            if (singletonInstance instanceof SmartInitializingSingleton) {
                StartupStep smartInitialize = this.getApplicationStartup().start("spring.beans.smart-initialize")
                        .tag("beanName", beanName);
                SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
                if (System.getSecurityManager() != null) {
                    AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
                        smartSingleton.afterSingletonsInstantiated();
                        return null;
                    }, getAccessControlContext());
                }
                else {
                    // 모든 싱글톤 생성 후 실행되는 콜백
                    smartSingleton.afterSingletonsInstantiated();
                }
                smartInitialize.end();
            }
        }
    }

    /**
     * Lazy 빈 생성 - 실제 요청 시점에 생성
     */
    @Override
    protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
            throws BeanCreationException {

        if (logger.isTraceEnabled()) {
            logger.trace("Creating instance of bean '" + beanName + "'");
        }
        RootBeanDefinition mbdToUse = mbd;

        // 1. 클래스 해결 (Lazy 로딩 시점에 클래스 로드 가능)
        Class<?> resolvedClass = resolveBeanClass(mbd, beanName);
        if (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {
            mbdToUse = new RootBeanDefinition(mbd);
            mbdToUse.setBeanClass(resolvedClass);
        }

        // 2. 메서드 오버라이드 검증
        try {
            mbdToUse.prepareMethodOverrides();
        }
        catch (BeanDefinitionValidationException ex) {
            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),
                    beanName, "Validation of method overrides failed", ex);
        }

        try {
            // 3. InstantiationAwareBeanPostProcessor에게 프록시 생성 기회 제공
            Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
            if (bean != null) {
                return bean; // 프록시가 생성되면 바로 반환
            }
        }
        catch (Throwable ex) {
            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                    "BeanPostProcessor before instantiation of bean failed", ex);
        }

        try {
            // 4. 실제 빈 인스턴스 생성 (Lazy 초기화의 핵심)
            Object beanInstance = doCreateBean(beanName, mbdToUse, args);
            if (logger.isTraceEnabled()) {
                logger.trace("Finished creating instance of bean '" + beanName + "'");
            }
            return beanInstance;
        }
        catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(
                    mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
        }
    }
}
```
- **Eager vs Lazy 성능 비교:**
	- **Eager (기본)**: 애플리케이션 시작 시간 증가, 런타임 성능 우수
	- **Lazy**: 시작 시간 단축, 메모리 절약, 첫 사용 시 지연 발생
	- **권장 시나리오**: 조건부 사용, 무거운 초기화, 순환 참조 해결
-  Eager vs Lazy 사용 이유
	-  Eager (기본값) 사용 이유
		- **안정성 우선**
			- **Fail-fast**: 애플리케이션 시작 시 모든 설정 오류 조기 발견
			- **의존성 검증**: DI 문제를 배포 전에 감지
			- **메모리 사용량 예측**: 시작 후 메모리 사용량이 일정하게 유지
		- **런타임 성능 최적화**
			- **첫 요청 응답 속도**: 이미 생성된 객체 바로 사용
			- **GC 부담 감소**: 초기화 시점에 메모리 할당 완료
			- **예측 가능한 성능**: 런타임 중 갑작스러운 지연 없음

	-  Lazy 사용 이유
		- **시작 시간 최적화 (MSA 핵심)**
			- **빠른 스케일링**: Kubernetes 환경에서 Pod 빠른 시작
			- **개발 효율성**: 로컬 개발 시 빠른 재시작
			- **CI/CD 파이프라인**: 테스트 환경 빠른 구성
		- **메모리 효율성**
			- **조건부 사용**: 특정 프로파일에서만 필요한 빈
			- **리소스 절약**: 사용하지 않는 기능의 메모리 절약
			- **컨테이너 최적화**: 제한된 메모리 환경에서 유리
		- **문제 해결 도구**
			- **순환 참조 해결**: Constructor Injection 순환 참조 우회
			- **외부 의존성**: 네트워크, DB 연결이 필요한 빈의 지연 초기화
			- **무거운 초기화**: 대용량 데이터 로딩, 복잡한 계산 지연

# 3. 순환 참조 해결
```java
// org.springframework.beans.factory.support.DefaultSingletonBeanRegistry
public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry {

    /**
     * 3단계 캐시로 순환 참조 해결
     * 
     * 1단계: singletonObjects - 완전히 초기화된 싱글톤 객체들
     * 2단계: earlySingletonObjects - 조기 노출된 싱글톤 객체들 (아직 초기화 중)
     * 3단계: singletonFactories - 싱글톤 객체를 생성할 수 있는 팩토리들
     */
    
    // 1단계 캐시: 완전히 초기화된 싱글톤 빈들
    private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    // 2단계 캐시: 조기 노출된 싱글톤 빈들 (생성됐지만 아직 초기화 중)
    private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);

    // 3단계 캐시: 싱글톤 팩토리들 (ObjectFactory)
    private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

    // 현재 생성 중인 빈들 추적 (순환 참조 감지용)
    private final Set<String> singletonsCurrentlyInCreation =
            Collections.newSetFromMap(new ConcurrentHashMap<>(16));

    /**
     * 싱글톤 빈 조회 - 3단계 캐시 순차 검색
     */
    @Override
    @Nullable
    public Object getSingleton(String beanName) {
        return getSingleton(beanName, true);
    }

    @Nullable
    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        // 1단계: 완성된 싱글톤 객체 확인
        Object singletonObject = this.singletonObjects.get(beanName);
        
        if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
            // 현재 생성 중인 빈이라면 조기 참조 허용 여부 확인
            
            // 2단계: 조기 노출된 싱글톤 객체 확인
            singletonObject = this.earlySingletonObjects.get(beanName);
            
            if (singletonObject == null && allowEarlyReference) {
                synchronized (this.singletonObjects) {
                    // Double-checked locking
                    singletonObject = this.singletonObjects.get(beanName);
                    if (singletonObject == null) {
                        singletonObject = this.earlySingletonObjects.get(beanName);
                        if (singletonObject == null) {
                            // 3단계: 싱글톤 팩토리에서 객체 생성
                            ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                            if (singletonFactory != null) {
                                // 팩토리에서 조기 참조 객체 생성 (주로 프록시)
                                singletonObject = singletonFactory.getObject();
                                
                                // 3단계 → 2단계로 승격 (캐시 최적화)
                                this.earlySingletonObjects.put(beanName, singletonObject);
                                this.singletonFactories.remove(beanName);
                            }
                        }
                    }
                }
            }
        }
        return singletonObject;
    }

    /**
     * 조기 싱글톤 참조 추가 - 순환 참조 해결의 핵심
     */
    protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
        Assert.notNull(singletonFactory, "Singleton factory must not be null");
        synchronized (this.singletonObjects) {
            if (!this.singletonObjects.containsKey(beanName)) {
                // 3단계 캐시에 팩토리 등록
                this.singletonFactories.put(beanName, singletonFactory);
                this.earlySingletonObjects.remove(beanName);
                this.registeredSingletons.add(beanName);
            }
        }
    }

    /**
     * 싱글톤 빈 등록 완료 - 최종 단계
     */
    protected void addSingleton(String beanName, Object singletonObject) {
        synchronized (this.singletonObjects) {
            // 1단계 캐시에 완성된 객체 등록
            this.singletonObjects.put(beanName, singletonObject);
            
            // 하위 단계 캐시들은 모두 제거 (완성된 객체가 있으니 불필요)
            this.singletonFactories.remove(beanName);
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }
    }
}
```
- ex)
>**3단계 캐시 순환 참조 해결 절차:**
> 
> **A → B → A 순환 참조 시나리오**
> 
> - **1단계: A 빈 생성 시작**
>     - `singletonsCurrentlyInCreation`에 "beanA" 추가
>     - A 인스턴스 생성 (생성자 호출, 아직 의존성 주입 전)
>     - 3단계 캐시에 A 팩토리 등록: `singletonFactories.put("beanA", factory)`
> - **2단계: A의 의존성 주입 → B 요청**
>     - `populateBean()` 실행 중 B 빈 필요
>     - `getBean("beanB")` 호출
> - **3단계: B 빈 생성 시작**
>     - `singletonsCurrentlyInCreation`에 "beanB" 추가
>     - B 인스턴스 생성
>     - 3단계 캐시에 B 팩토리 등록
> - **4단계: B의 의존성 주입 → A 요청 (순환 참조 발생)**
>     - `getBean("beanA")` 호출
>     - `getSingleton("beanA", true)` 실행
> - **5단계: 3단계 캐시 검색 과정**
>     - 1단계 캐시 확인: `singletonObjects.get("beanA")` → **null**
>     - 생성 중 확인: `isSingletonCurrentlyInCreation("beanA")` → **true**
>     - 2단계 캐시 확인: `earlySingletonObjects.get("beanA")` → **null**
>     - 3단계 캐시 확인: `singletonFactories.get("beanA")` → **factory 발견!**
> - **6단계: 조기 참조 생성**
>     - `factory.getObject()` 호출 → A의 조기 참조 생성
>     - 3단계 → 2단계 승격: `earlySingletonObjects.put("beanA", earlyA)`
>     - 3단계 캐시에서 제거: `singletonFactories.remove("beanA")`
> - **7단계: B 초기화 완료**
>     - B에게 A의 조기 참조 주입
>     - B 초기화 완료 → 1단계 캐시 등록: `singletonObjects.put("beanB", beanB)`
> - **8단계: A 초기화 완료**
>     - A에게 완성된 B 주입
>     - A 초기화 완료 → 1단계 캐시 등록: `singletonObjects.put("beanA", beanA)`
>     - 2단계 캐시에서 제거: `earlySingletonObjects.remove("beanA")`
> 
> **결과**: A와 B가 서로 완전히 초기화된 상태로 참조 관계 성립> 


# 4. `@Autowired` 내부 동작


```java
// org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter
        implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware {

    /**
     * @Autowired 처리의 진입점
     * populateBean() 중에 호출됨
     */
    @Override
    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
        // 1. @Autowired 메타데이터 조회 (캐싱됨)
        InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);
        try {
            // 2. 실제 의존성 주입 실행
            metadata.inject(bean, beanName, pvs);
        }
        catch (BeanCreationException ex) {
            throw ex;
        }
        catch (Throwable ex) {
            throw new BeanCreationException(beanName, "Injection of autowired dependencies failed", ex);
        }
        return pvs;
    }

    /**
     * @Autowired 메타데이터 수집 및 캐싱
     */
    private InjectionMetadata findAutowiringMetadata(String beanName, Class<?> clazz, @Nullable PropertyValues pvs) {
        // 클래스 이름을 캐시 키로 사용
        String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());
        
        // 캐시에서 메타데이터 조회
        InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey);
        if (InjectionMetadata.needsRefresh(metadata, clazz)) {
            synchronized (this.injectionMetadataCache) {
                metadata = this.injectionMetadataCache.get(cacheKey);
                if (InjectionMetadata.needsRefresh(metadata, clazz)) {
                    if (metadata != null) {
                        metadata.clear(pvs);
                    }
                    // @Autowired 어노테이션 스캔 및 메타데이터 생성
                    metadata = buildAutowiringMetadata(clazz);
                    this.injectionMetadataCache.put(cacheKey, metadata);
                }
            }
        }
        return metadata;
    }

    /**
     * 클래스에서 @Autowired 어노테이션 스캔
     */
    private InjectionMetadata buildAutowiringMetadata(final Class<?> clazz) {
        if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) {
            return InjectionMetadata.EMPTY;
        }

        List<InjectionMetadata.InjectedElement> elements = new ArrayList<>();
        Class<?> targetClass = clazz;

        do {
            final List<InjectionMetadata.InjectedElement> currElements = new ArrayList<>();

            // === 필드에서 @Autowired 검색 ===
            ReflectionUtils.doWithLocalFields(targetClass, field -> {
                // @Autowired, @Value, @Inject 어노테이션 확인
                MergedAnnotation<?> ann = findAutowiredAnnotation(field);
                if (ann != null) {
                    // static 필드는 지원하지 않음
                    if (Modifier.isStatic(field.getModifiers())) {
                        if (logger.isInfoEnabled()) {
                            logger.info("Autowired annotation is not supported on static fields: " + field);
                        }
                        return;
                    }
                    // required 속성 추출
                    boolean required = determineRequiredStatus(ann);
                    currElements.add(new AutowiredFieldElement(field, required));
                }
            });

            // === 메서드에서 @Autowired 검색 ===
            ReflectionUtils.doWithLocalMethods(targetClass, method -> {
                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);
                if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) {
                    return;
                }
                MergedAnnotation<?> ann = findAutowiredAnnotation(bridgedMethod);
                if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) {
                    // static 메서드는 지원하지 않음
                    if (Modifier.isStatic(method.getModifiers())) {
                        if (logger.isInfoEnabled()) {
                            logger.info("Autowired annotation is not supported on static methods: " + method);
                        }
                        return;
                    }
                    // 매개변수가 없는 메서드는 스킵
                    if (method.getParameterCount() == 0) {
                        if (logger.isInfoEnabled()) {
                            logger.info("Autowired annotation should only be used on methods with parameters: " + method);
                        }
                    }
                    boolean required = determineRequiredStatus(ann);
                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);
                    currElements.add(new AutowiredMethodElement(method, required, pd));
                }
            });

            elements.addAll(0, currElements);
            targetClass = targetClass.getSuperclass();
        }
        while (targetClass != null && targetClass != Object.class);

        return InjectionMetadata.forElements(elements, clazz);
    }

    /**
     * 필드 주입 구현체
     */
    private class AutowiredFieldElement extends InjectionMetadata.InjectedElement {
        private final boolean required;

        public AutowiredFieldElement(Field field, boolean required) {
            super(field, null);
            this.required = required;
        }

        @Override
        protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {
            Field field = (Field) this.member;
            Object value;
            if (this.cached) {
                // 캐시된 의존성 사용 (성능 최적화)
                try {
                    value = resolvedCachedArgument(beanName, this.cachedFieldValue);
                }
                catch (NoSuchBeanDefinitionException ex) {
                    // 캐시된 빈이 더 이상 존재하지 않음 - 재해결 필요
                    value = resolveFieldValue(field, bean, beanName);
                }
            }
            else {
                // 새로운 의존성 해결
                value = resolveFieldValue(field, bean, beanName);
            }
            
            if (value != null) {
                // 필드 접근 가능하게 설정
                ReflectionUtils.makeAccessible(field);
                // 실제 값 설정
                field.set(bean, value);
            }
        }

        @Nullable
        private Object resolveFieldValue(Field field, Object bean, @Nullable String beanName) {
            // 의존성 디스크립터 생성
            DependencyDescriptor desc = new DependencyDescriptor(field, this.required);
            desc.setContainingClass(bean.getClass());
            
            Set<String> autowiredBeanNames = new LinkedHashSet<>(1);
            Assert.state(beanFactory != null, "No BeanFactory available");
            TypeConverter typeConverter = beanFactory.getTypeConverter();
            Object value;
            try {
                // === 핵심: 의존성 해결 ===
                value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);
            }
            catch (BeansException ex) {
                throw new UnsatisfiedDependencyException(null, beanName, new InjectionPoint(field), ex);
            }
            
            synchronized (this) {
                if (!this.cached) {
                    Object cachedFieldValue = null;
                    if (value != null || this.required) {
                        cachedFieldValue = desc;
                        // 의존성 관계 등록
                        registerDependentBeans(beanName, autowiredBeanNames);
                        if (autowiredBeanNames.size() == 1) {
                            String autowiredBeanName = autowiredBeanNames.iterator().next();
                            if (beanFactory.containsBean(autowiredBeanName) &&
                                    beanFactory.isTypeMatch(autowiredBeanName, field.getType())) {
                                // 단일 빈인 경우 이름을 캐시하여 성능 최적화
                                cachedFieldValue = new ShortcutDependencyDescriptor(
                                        desc, autowiredBeanName, field.getType());
                            }
                        }
                    }
                    this.cachedFieldValue = cachedFieldValue;
                    this.cached = true;
                }
            }
            return value;
        }
    }
}
```
```java
// org.springframework.beans.factory.support.DefaultListableBeanFactory
public class DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory {

    /**
     * @Autowired 의존성 해결의 핵심 메서드
     */
    @Override
    @Nullable
    public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
            @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

        descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
        
        if (Optional.class == descriptor.getDependencyType()) {
            // Optional<T> 타입 처리
            return createOptionalDependency(descriptor, requestingBeanName);
        }
        else if (ObjectFactory.class == descriptor.getDependencyType() ||
                ObjectProvider.class == descriptor.getDependencyType()) {
            // ObjectFactory<T>, ObjectProvider<T> 타입 처리
            return new DependencyObjectProvider(descriptor, requestingBeanName);
        }
        else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
            // javax.inject.Provider<T> 타입 처리
            return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
        }
        else {
            // 일반적인 타입 - 지연 프록시 먼저 시도
            Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                    descriptor, requestingBeanName);
            if (result == null) {
                // === 실제 의존성 해결 ===
                result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
            }
            return result;
        }
    }

    /**
     * 의존성 해결 핵심 로직
     */
    @Nullable
    public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,
            @Nullable Set<String> autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

        InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
        try {
            // 1. 빠른 단축 경로 시도 (ShortcutDependencyDescriptor)
            Object shortcut = descriptor.resolveShortcut(this);
            if (shortcut != null) {
                return shortcut;
            }

            // 2. @Value 처리
            Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
            if (value != null) {
                if (value instanceof String) {
                    String strVal = resolveEmbeddedValue((String) value);
                    BeanDefinition bd = (beanName != null && containsBean(beanName) ?
                            getMergedBeanDefinition(beanName) : null);
                    value = evaluateBeanDefinitionString(strVal, bd);
                }
                TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
                try {
                    return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
                }
                catch (UnsupportedOperationException ex) {
                    return (descriptor.getField() != null ?
                            converter.convertIfNecessary(value, type, descriptor.getField()) :
                            converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
                }
            }

            // 3. 다중값 의존성 해결 (Array, Collection, Map)
            Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
            if (multipleBeans != null) {
                return multipleBeans;
            }

            // 4. === 단일 빈 후보 검색 (핵심) ===
            Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
            if (matchingBeans.isEmpty()) {
                if (isRequired(descriptor)) {
                    // 필수 의존성인데 후보가 없으면 예외
                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
                }
                return null;
            }

            String autowiredBeanName;
            Object instanceCandidate;

            if (matchingBeans.size() > 1) {
                // 5. === 다중 후보에서 최적 후보 선택 ===
                autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
                if (autowiredBeanName == null) {
                    if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
                        // @Primary, @Qualifier로도 해결되지 않으면 예외
                        return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
                    }
                    else {
                        return null;
                    }
                }
                instanceCandidate = matchingBeans.get(autowiredBeanName);
            }
            else {
                // 단일 후보
                Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
                autowiredBeanName = entry.getKey();
                instanceCandidate = entry.getValue();
            }

            // 6. 의존성 관계 등록 및 빈 생성
            if (autowiredBeanNames != null) {
                autowiredBeanNames.add(autowiredBeanName);
            }
            if (instanceCandidate instanceof Class) {
                instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
            }
            Object result = instanceCandidate;
            if (result instanceof NullBean) {
                if (isRequired(descriptor)) {
                    raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
                }
                result = null;
            }
            if (!ClassUtils.isAssignableValue(type, result)) {
                throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
            }
            return result;
        }
        finally {
            ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
        }
    }

    /**
     * @Primary, @Qualifier를 사용한 최적 후보 선택
     */
    @Nullable
    protected String determineAutowireCandidate(Map<String, Object> candidates, DependencyDescriptor descriptor) {
        Class<?> requiredType = descriptor.getDependencyType();
        
        // 1. @Primary 빈 검색
        String primaryCandidate = determinePrimaryCandidate(candidates, requiredType);
        if (primaryCandidate != null) {
            return primaryCandidate;
        }
        
        // 2. @Priority 높은 빈 검색 (JSR-250)
        String priorityCandidate = determineHighestPriorityCandidate(candidates, requiredType);
        if (priorityCandidate != null) {
            return priorityCandidate;
        }
        
        // 3. 이름 매칭 (필드명/매개변수명과 빈 이름 일치)
        for (Map.Entry<String, Object> entry : candidates.entrySet()) {
            String candidateName = entry.getKey();
            Object beanInstance = entry.getValue();
            if ((beanInstance != null && this.resolvableDependencies.containsValue(beanInstance)) ||
                    matchesBeanName(candidateName, descriptor.getDependencyName())) {
                return candidateName;
            }
        }
        return null;
    }
}
```

- **@Autowired 내부 동작 흐름:**
	
	- **1단계: 메타데이터 수집**
	    - 클래스 스캔하여 @Autowired 필드/메서드 찾기
	    - 캐싱으로 성능 최적화
	- **2단계: 의존성 해결**
	    - `resolveDependency()` → `doResolveDependency()` 호출
	    - @Value 먼저 처리, 그 다음 타입 기반 검색
	- **3단계: 후보 검색**
	    - `findAutowireCandidates()`: 타입으로 1차 필터링
	    - 제네릭, 상속 관계까지 고려한 정교한 매칭
	- **4단계: 최적 후보 선택**
	    - 후보 1개: 바로 사용
	    - 후보 여러 개: @Primary → @Priority → 이름 매칭 순
	- **5단계: 캐싱 최적화**
	    - `ShortcutDependencyDescriptor`: 단일 빈은 이름 캐싱
	    - 다음 주입 시 빠른 경로 사용