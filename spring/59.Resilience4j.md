## 3가지 상태
### 1. CLOSED
- 모든 요청 정상 통과
- 실패율 모니터링
- 임계 값 초과 시 ->  OPEN

### 2. OPEN
- 모든 요청 즉시 차단
- fallback 응답 반환
- timeout 후 -> HALF_OPEN

### 3. HALF_OPEN
- 제한된 요청만 허용
- 성공 시 -> CLOSED
- 실패 시 -> OPEN


## Resilience4J

| 설정 | 기본값 | 설명 | 예시 | 주의사항 |
|------|------|------|------|----------|
| **failureRateThreshold** | 50.0f | OPEN 상태로 전환되는 실패율 임계값 (%) | 30.0f = 30% 이상 실패 시 OPEN | 0.0~100.0 범위 |
| **minimumNumberOfCalls** | 100 | 실패율 계산을 시작하는 최소 호출 수 | 5 = 5번 호출 후부터 실패율 계산 | 이 수치 미달 시 항상 CLOSED |
| **waitDurationInOpenState** | 60초 | OPEN 상태 유지 시간 (HALF-OPEN 전환 대기) | 10초 = 10초 후 HALF-OPEN 시도 | 너무 짧으면 장애 서비스 부하 |
| **permittedNumberOfCallsInHalfOpenState** | 10 | HALF-OPEN에서 허용되는 테스트 호출 수 | 2 = 2번 테스트 후 상태 결정 | 이 수만큼 성공해야 CLOSED |
| **slidingWindowSize** | 100 | 통계 계산 윈도우 크기 (최근 N번 호출) | 10 = 최근 10번 호출 기준 | minimumNumberOfCalls ≤ slidingWindowSize |
| **recordExceptions** | 모든 Exception | 실패로 기록할 예외 타입들 | `RuntimeException.class` | 지정 안 하면 모든 예외가 실패 |

- 목표: 경량화된 CircuitBreaker 패턴 구현
- 지원하지 않는 것: Global하게 상태 값을 공유하는 CircuitBreaker
- 대안: A/B 구성, FeatureFlag


## 내부 구현
- CircuitBreakerAspect
```java
@Aspect  
public class CircuitBreakerAspect {
	@Pointcut(  
	    value = "@within(circuitBreaker) || @annotation(circuitBreaker)",  
	    argNames = "circuitBreaker"  
	)  
	public void matchAnnotatedClassOrMethod(CircuitBreaker circuitBreaker) {  
	}  
	  
	@Around(  
	    value = "matchAnnotatedClassOrMethod(circuitBreakerAnnotation)",  
	    argNames = "proceedingJoinPoint, circuitBreakerAnnotation"  
	)  
	public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, @Nullable CircuitBreaker circuitBreakerAnnotation) throws Throwable {  
	    Method method = ((MethodSignature)proceedingJoinPoint.getSignature()).getMethod();  
	    String var10000 = method.getDeclaringClass().getName();  
	    String methodName = var10000 + "#" + method.getName();  
	    if (circuitBreakerAnnotation == null) {  
	        circuitBreakerAnnotation = this.getCircuitBreakerAnnotation(proceedingJoinPoint);  
	    }  
	  
	    if (circuitBreakerAnnotation == null) {  
	        return proceedingJoinPoint.proceed();  // annotation이 없으면 기존 메소드 실행
	    } else {  
	        String backend = this.spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.name());  
	        io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = this.getOrCreateCircuitBreaker(methodName, backend);  
	        Class<?> returnType = method.getReturnType();  
	        CheckedSupplier<Object> circuitBreakerExecution = () -> {  
	            return this.proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType);  
	        };  
	        return this.fallbackExecutor.execute(proceedingJoinPoint, method, circuitBreakerAnnotation.fallbackMethod(), circuitBreakerExecution);  // Fallback 실행
	    }  
	}
	
	private Object defaultHandling(ProceedingJoinPoint proceedingJoinPoint, io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker) throws Throwable {  
	    Objects.requireNonNull(proceedingJoinPoint);  
	    return circuitBreaker.executeCheckedSupplier(proceedingJoinPoint::proceed);  
	}
}
```

- CircuitBreaker
```java
public interface CircuitBreaker {  
    static <T> CheckedSupplier<T> decorateCheckedSupplier(CircuitBreaker circuitBreaker, CheckedSupplier<T> supplier) {  
        return () -> {  
            circuitBreaker.acquirePermission();  
            long start = circuitBreaker.getCurrentTimestamp();  
  
            long duration;  
            try {  
                T result = supplier.get();  
                duration = circuitBreaker.getCurrentTimestamp() - start;  
                circuitBreaker.onResult(duration, circuitBreaker.getTimestampUnit(), result);  
                return result;  
            } catch (Exception var7) {  
                Exception exception = var7;  
                duration = circuitBreaker.getCurrentTimestamp() - start;  
                circuitBreaker.onError(duration, circuitBreaker.getTimestampUnit(), exception);  
                throw exception;  
            }  
        };  
    }
    
}
```

- CircuitBreakerStateMachine
```public final class CircuitBreakerStateMachine implements CircuitBreaker {

	  
	public void onError(long duration, TimeUnit durationUnit, Throwable throwable) {  
	    if (!(throwable instanceof CompletionException) && !(throwable instanceof ExecutionException)) {  
	        this.handleThrowable(duration, durationUnit, throwable);  
	    } else {  
	        Throwable cause = throwable.getCause();  
	        this.handleThrowable(duration, durationUnit, cause);  
	    }  
	  
	}  
	  
	private void handleThrowable(long duration, TimeUnit durationUnit, Throwable throwable) {  
	    if (this.circuitBreakerConfig.getIgnoreExceptionPredicate().test(throwable)) {  
	        LOG.debug("CircuitBreaker '{}' ignored an exception:", this.name, throwable);  
	        this.releasePermission();  
	        this.publishCircuitIgnoredErrorEvent(this.name, duration, durationUnit, throwable);  
	    } else {  
	        if (this.circuitBreakerConfig.getRecordExceptionPredicate().test(throwable)) {  
	            LOG.debug("CircuitBreaker '{}' recorded an exception as failure:", this.name, throwable);  
	            this.publishCircuitErrorEvent(this.name, duration, durationUnit, throwable);  
	            ((CircuitBreakerState)this.stateReference.get()).onError(duration, durationUnit, throwable);  
	        } else {  
	            LOG.debug("CircuitBreaker '{}' recorded an exception as success:", this.name, throwable);  
	            this.publishSuccessEvent(duration, durationUnit);  
	            ((CircuitBreakerState)this.stateReference.get()).onSuccess(duration, durationUnit);  
	        }  
	  
	        this.handlePossibleTransition(Either.right(throwable));  
	    }  
	}  
	  
	public void onSuccess(long duration, TimeUnit durationUnit) {  
	    LOG.debug("CircuitBreaker '{}' succeeded:", this.name);  
	    this.publishSuccessEvent(duration, durationUnit);  
	    ((CircuitBreakerState)this.stateReference.get()).onSuccess(duration, durationUnit);  
	}  
	  
	public void onResult(long duration, TimeUnit durationUnit, @Nullable Object result) {  
	    if (result != null && this.circuitBreakerConfig.getRecordResultPredicate().test(result)) {  
	        LOG.debug("CircuitBreaker '{}' recorded a result type '{}' as failure:", this.name, result.getClass());  
	        ResultRecordedAsFailureException failure = new ResultRecordedAsFailureException(this.name, result);  
	        this.publishCircuitErrorEvent(this.name, duration, durationUnit, failure);  
	        ((CircuitBreakerState)this.stateReference.get()).onError(duration, durationUnit, failure);  
	    } else {  
	        this.onSuccess(duration, durationUnit);  
	        if (result != null) {  
	            this.handlePossibleTransition(Either.left(result));  
	        }  
	    }  
	  
	}


}
```