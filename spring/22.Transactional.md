## 코드
```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {
    Propagation propagation() default Propagation.REQUIRED;
    Isolation isolation() default Isolation.DEFAULT;
    int timeout() default -1;
    boolean readOnly() default false;
    Class<? extends Throwable>[] rollbackFor() default {};
    String value() default "";
}
```

## 정의
1. `@Transactional`은 선언적으로 트랜잭션 관리를 가능하게 해주는 annotation 기반 메타데이터다.
2. 트랜잭션 경계(begin/ commit/ rollback)을 자동으로 설정하는 **AOP annotation**이다. 
3. 메소드, 클래스 선두에 붙일 수 있다. `@Target({ElementType.METHOD, ElementType.TYPE})`
4. 정상 종료 시 commit, 비정상 종료 시 rollback을 자동으로 수행한다.
5. 트랜잭션 제어 코드를 매 번 작성하지 않더라도 **일관적인 트랜잭션 처리**를 보장받을 수 있게 해준다.

## 선언적?
- spring은 transaction 관리에 대해서 두 가지 방법을 제시한다.
	1. 프로그래밍 방식: 코드 내 직접 트랜잭션 경계를 설정
	2. 선언적 방식 : `@Transactional`로 Spring이 AOP를 통해서 자동 적용

## 동작
1. client 호출
2. AOP Proxy 객체가 가로챈다.
	1. JDK Dynamic Proxy(Interface 기반)
	2. CGLIB (bytecode 조작)
3. TransactionInterceptor advisor 등록
	1. invoke로 처리한다.
```java
package org.springframework.transaction.interceptor;  
    
import org.aopalliance.intercept.MethodInterceptor;  
import org.aopalliance.intercept.MethodInvocation;  
  
import org.springframework.aop.support.AopUtils;  
import org.springframework.beans.factory.BeanFactory;  
import org.springframework.lang.Nullable;  
import org.springframework.transaction.PlatformTransactionManager;  
import org.springframework.transaction.TransactionManager;  

@SuppressWarnings("serial")  
public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable {  

 
    @Override  
    @Nullable
	public Object invoke(MethodInvocation invocation) throws Throwable {  
    
       return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);  
    }  
  
  //후략
}
```
```java
public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean {

	@Nullable  
	protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,  
	       final InvocationCallback invocation) throws Throwable {  
	  
	    // If the transaction attribute is null, the method is non-transactional.  
	    TransactionAttributeSource tas = getTransactionAttributeSource();  
	    final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);  
	    final TransactionManager tm = determineTransactionManager(txAttr);  
	
	
	// Reactive 관련
	    if (this.reactiveAdapterRegistry != null && tm instanceof ReactiveTransactionManager rtm) {  
	       boolean isSuspendingFunction = KotlinDetector.isSuspendingFunction(method);  
	       boolean hasSuspendingFlowReturnType = isSuspendingFunction &&  
	             COROUTINES_FLOW_CLASS_NAME.equals(new MethodParameter(method, -1).getParameterType().getName());  
	  
	       ReactiveTransactionSupport txSupport = this.transactionSupportCache.computeIfAbsent(method, key -> {  
	          Class<?> reactiveType =  
	                (isSuspendingFunction ? (hasSuspendingFlowReturnType ? Flux.class : Mono.class) : method.getReturnType());  
	          ReactiveAdapter adapter = this.reactiveAdapterRegistry.getAdapter(reactiveType);  
	          if (adapter == null) {  
	             throw new IllegalStateException("Cannot apply reactive transaction to non-reactive return type [" +  
	                   method.getReturnType() + "] with specified transaction manager: " + tm);  
	          }  
	          return new ReactiveTransactionSupport(adapter);  
	       });  
	  
	       return txSupport.invokeWithinTransaction(method, targetClass, invocation, txAttr, rtm);  
	    }  


//PlatformTransactionManager를 설정한다.
	  
	    PlatformTransactionManager ptm = asPlatformTransactionManager(tm);  
	    final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);  

// 동기식 트랜잭션 처리 (get/commit/rollback)
	    if (txAttr == null || !(ptm instanceof CallbackPreferringPlatformTransactionManager cpptm)) {  
	       // Standard transaction demarcation with getTransaction and commit/rollback calls.  
	       TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);  
	  
	       Object retVal;  
	       try {  
	          // This is an around advice: Invoke the next interceptor in the chain.  
	          // This will normally result in a target object being invoked.          retVal = invocation.proceedWithInvocation();  
	       }  
	       catch (Throwable ex) {  
	          // target invocation exception  
	          completeTransactionAfterThrowing(txInfo, ex);  
	          throw ex;  
	       }  
	       finally {  
	          cleanupTransactionInfo(txInfo);  
	       }  
	  
	       if (retVal != null && txAttr != null) {  
	          TransactionStatus status = txInfo.getTransactionStatus();  
	          if (status != null) {  

// Future, Vavr 타입 처리 (비동기 완료 검사)
	             if (retVal instanceof Future<?> future && future.isDone()) {  
	                try {  
	                   future.get();  
	                }  
	                catch (ExecutionException ex) {  
	                   if (txAttr.rollbackOn(ex.getCause())) {  
	                      status.setRollbackOnly();  
	                   }  
	                }  
	                catch (InterruptedException ex) {  
	                   Thread.currentThread().interrupt();  
	                }  
	             }  
	             else if (vavrPresent && VavrDelegate.isVavrTry(retVal)) {  
	                // Set rollback-only in case of Vavr failure matching our rollback rules...  
	                retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);  
	             }  
	          }  
	       }  
	  
	       commitTransactionAfterReturning(txInfo);  
	       return retVal;  
	    }  
	//
	    else {  
	       Object result;  
	       final ThrowableHolder throwableHolder = new ThrowableHolder();  
	  
	       // It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.  
	       try {  
	          result = cpptm.execute(txAttr, status -> {  
	             TransactionInfo txInfo = prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);  
	             try {  
	                Object retVal = invocation.proceedWithInvocation();  
	                if (retVal != null && vavrPresent && VavrDelegate.isVavrTry(retVal)) {  
	                   // Set rollback-only in case of Vavr failure matching our rollback rules...  
	                   retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);  
	                }  
	                return retVal;  
	             }  
	             catch (Throwable ex) {  
	                if (txAttr.rollbackOn(ex)) {  
	                   // A RuntimeException: will lead to a rollback.  
	                   if (ex instanceof RuntimeException runtimeException) {  
	                      throw runtimeException;  
	                   }  
	                   else {  
	                      throw new ThrowableHolderException(ex);  
	                   }  
	                }  
	                else {  
	                   // A normal return value: will lead to a commit.  
	                   throwableHolder.throwable = ex;  
	                   return null;  
	                }  
	             }  
	             finally {  
	                cleanupTransactionInfo(txInfo);  
	             }  
	          });  
	       }  
	       catch (ThrowableHolderException ex) {  
	          throw ex.getCause();  
	       }  
	       catch (TransactionSystemException ex2) {  
	          if (throwableHolder.throwable != null) {  
	             logger.error("Application exception overridden by commit exception", throwableHolder.throwable);  
	             ex2.initApplicationException(throwableHolder.throwable);  
	          }  
	          throw ex2;  
	       }  
	       catch (Throwable ex2) {  
	          if (throwableHolder.throwable != null) {  
	             logger.error("Application exception overridden by commit exception", throwableHolder.throwable);  
	          }  
	          throw ex2;  
	       }  
	  
	       // Check result state: It might indicate a Throwable to rethrow.  
	       if (throwableHolder.throwable != null) {  
	          throw throwableHolder.throwable;  
	       }  
	       return result;  
	    }  
	}

}
```
- **PlatformTransactionManager**가 직접 트랜잭션을 열고/ 닫고/ 롤백


## PlatformTransactionManager?
- Spring의 tx 처리 전략을 추상화한 인터페이스 

| **구현체 이름**                   | **대상 기술 스택**      | **주요 특징**                                | **비고**                                 |
| ---------------------------- | ----------------- | ---------------------------------------- | -------------------------------------- |
| DataSourceTransactionManager | JDBC              | 순수 JDBC용 트랜잭션 매니저, Connection 직접 제어      | 가장 단순, autoCommit=false 직접             |
| JpaTransactionManager        | JPA (Hibernate 등) | EntityManager 기반 트랜잭션, JPA flush 연동      | JPA 전용, 스프링 부트에서 기본 선택                 |
| HibernateTransactionManager  | Hibernate Native  | Hibernate Session 기반 직접 제어               | JPA 미사용 시 사용, Spring 6에서 deprecated 예정 |
| JtaTransactionManager        | JTA (분산 트랜잭션)     | XA 트랜잭션, 2PC 지원, Atomikos/Narayana 연동 가능 | Java EE, 대규모 분산 시스템용                   |
| ChainedTransactionManager    | 다중 데이터소스          | 여러 TransactionManager 묶어서 순차 처리          | best-effort 1PC, 완전한 원자성 없음            |
| ReactiveTransactionManager   | WebFlux + R2DBC   | 논블로킹 트랜잭션, Mono/Flux 전파                  | JDBC와 완전 별개                            |
