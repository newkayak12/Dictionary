# Jasypt?
- Java Simplified Encryption의 약자이다.

> Jasypt is a java library which allows the developer to add basic encryption capabilities to his/her projects with minimum effort, and without the need of having deep knowledge on how cryptography works
>
>[출처: Japsypt 공식 홈페이지](http://www.jasypt.org/index.html)

- 프로젝트에 민감한 정보를 직접적으로 노출시키지 않는 방법 중 하나

# 의존성

```kotlin
implementation("com.github.ulisesbocchio:jasypt-spring-boot-starter:3.0.5")
```

- 위 의존성은 `jasypt-spring-boot-starter` -> `jaspt-spring-boot` -> `jasypt` 의 의존성을 갖는다.

# 사용
- 기본적으로 auto-configure 설정이 되어 있다.
```factory
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ulisesbocchio.jasyptspringbootstarter.JasyptSpringBootAutoConfiguration  
  
org.springframework.cloud.bootstrap.BootstrapConfiguration=com.ulisesbocchio.jasyptspringbootstarter.JasyptSpringCloudBootstrapConfiguration
```
com.github.ulisesbocchio:jaspyt-spring-boot-starter/META-INF/spring.factories

- `@JasyptSpringBootAutoConfiguration`를 선언으로 명시적으로 선언할 수 있다.
- 덧붙여서 String에 대해서 Encrypt할 경우 `StringEncryptor`를 선언하면 설정한 StringEncryptor를 바탕으로 encrypt, decrypt를 진행한다.
- .yaml, .yaml에 `ENC(암호문)`와 같은 형식으로 작성하면 Spring의 Bean 등록하는 과정에 Property에 대한 복호화를 진행한다.


```java
package com.ulisesbocchio.jasyptspringboot.annotation;  
  
import com.ulisesbocchio.jasyptspringboot.configuration.EnableEncryptablePropertiesConfiguration;  
import java.lang.annotation.ElementType;  
import java.lang.annotation.Retention;  
import java.lang.annotation.RetentionPolicy;  
import java.lang.annotation.Target;  
import org.springframework.context.annotation.Import;  
  
@Target({ElementType.TYPE})  
@Retention(RetentionPolicy.RUNTIME)  
@Import({EnableEncryptablePropertiesConfiguration.class})  
public @interface EnableEncryptableProperties {  
}
```
- 위와 같이 `EnableEncryptablePropertiesConfiguration`를 포함하고 주입하고 있다.

```java
@Configuration  
@Import({EncryptablePropertyResolverConfiguration.class, CachingConfiguration.class})  
public class EnableEncryptablePropertiesConfiguration {  
    private static final Logger log = LoggerFactory.getLogger(EnableEncryptablePropertiesConfiguration.class);  
  
    public EnableEncryptablePropertiesConfiguration() {  
    }  
  
    @Bean  
    public static EnableEncryptablePropertiesBeanFactoryPostProcessor enableEncryptablePropertySourcesPostProcessor(ConfigurableEnvironment environment, EncryptablePropertySourceConverter converter) {  
        return new EnableEncryptablePropertiesBeanFactoryPostProcessor(environment, converter);  
    }  
}
```
- `EncryptablePropertyResolverConfiguration`는 실질적으로 resolve 하는 구현에 대한 내용을 담고 있다.
- `CachingConfiguration`는  Spring Cloud에서 RefreshScope가 갱신될 때 복호화가 깨지지 않도록 재작업할 때에 대한 처리를 가지고 있다.

```java
@Configuration  
public class EncryptablePropertyResolverConfiguration {  
    private static final String ENCRYPTOR_BEAN_PROPERTY = "jasypt.encryptor.bean";  
    private static final String ENCRYPTOR_BEAN_PLACEHOLDER = String.format("${%s:jasyptStringEncryptor}", "jasypt.encryptor.bean");  
    private static final String DETECTOR_BEAN_PROPERTY = "jasypt.encryptor.property.detector-bean";  
    private static final String DETECTOR_BEAN_PLACEHOLDER = String.format("${%s:encryptablePropertyDetector}", "jasypt.encryptor.property.detector-bean");  
    private static final String RESOLVER_BEAN_PROPERTY = "jasypt.encryptor.property.resolver-bean";  
    private static final String RESOLVER_BEAN_PLACEHOLDER = String.format("${%s:encryptablePropertyResolver}", "jasypt.encryptor.property.resolver-bean");  
    private static final String FILTER_BEAN_PROPERTY = "jasypt.encryptor.property.filter-bean";  
    private static final String FILTER_BEAN_PLACEHOLDER = String.format("${%s:encryptablePropertyFilter}", "jasypt.encryptor.property.filter-bean");  
    private static final String ENCRYPTOR_BEAN_NAME = "lazyJasyptStringEncryptor";  
    private static final String DETECTOR_BEAN_NAME = "lazyEncryptablePropertyDetector";  
    private static final String CONFIG_SINGLETON = "configPropsSingleton";  
    public static final String RESOLVER_BEAN_NAME = "lazyEncryptablePropertyResolver";  
    public static final String FILTER_BEAN_NAME = "lazyEncryptablePropertyFilter";  
  
    public EncryptablePropertyResolverConfiguration() {  
    }  
/*
 * EnableEncryptablePropertiesBeanFactoryPostProcessor의
 * postProcessBeanFactory에서 사용하는  EncryptablePropertySourceConverter가
 * 여기에서 생성됩니다.
 */
  
    @Bean  
    public static EncryptablePropertySourceConverter encryptablePropertySourceConverter(ConfigurableEnvironment environment, @Qualifier("lazyEncryptablePropertyResolver") EncryptablePropertyResolver propertyResolver, @Qualifier("lazyEncryptablePropertyFilter") EncryptablePropertyFilter propertyFilter) {  
        boolean proxyPropertySources = (Boolean)environment.getProperty("jasypt.encryptor.proxy-property-sources", Boolean.TYPE, false);  
        List<String> skipPropertySources = (List)environment.getProperty("jasypt.encryptor.skip-property-sources", List.class, Collections.EMPTY_LIST);  
        List<Class<PropertySource<?>>> skipPropertySourceClasses = (List)skipPropertySources.stream().map(EncryptablePropertySourceConverter::getPropertiesClass).collect(Collectors.toList());  
        InterceptionMode interceptionMode = proxyPropertySources ? InterceptionMode.PROXY : InterceptionMode.WRAPPER;  
        return new EncryptablePropertySourceConverter(interceptionMode, skipPropertySourceClasses, propertyResolver, propertyFilter);  
    }

	@Bean(  
	    name = {"lazyJasyptStringEncryptor"}  
	)  
	public StringEncryptor stringEncryptor(EnvCopy envCopy, BeanFactory bf) {  
	    String customEncryptorBeanName = envCopy.get().resolveRequiredPlaceholders(ENCRYPTOR_BEAN_PLACEHOLDER);  
	    //우리가 Bean으로 등록한 jasyptStringEncryptor가 여기에서 쓰인다.
	    boolean isCustom = envCopy.get().containsProperty("jasypt.encryptor.bean");  
	    return new DefaultLazyEncryptor(envCopy.get(), customEncryptorBeanName, isCustom, bf);  
	}
}
```
