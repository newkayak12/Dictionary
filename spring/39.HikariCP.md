
## 정의
1. HikariCP는 Java application의 JDBC Connection의 객체를 **Pooling** 방식으로 관리하며 성능, 자원 효율성을 극대화하는 고성능 경량 커넥션 풀 라이브러리


### 왜 필요한가?
1. Connection 생성 비용이 크다.
	1. DB 연결은 TCP 연결 -> 인증 -> 세션 수립 과정을 거친다.
	2. 이 과정에서 드는 리소스가 크다.
2. 요청마다 Connection을 닫는다면?
	1. 커넥션 누수가 발생할 수 있다.
	2. TPS가 늘면 늘수록 비효율적이다.

### 어떻게 동작하는가?
1. 애플리케이션이 기동되면서 **HikariCP**가 커넥션 n개를 생성한다.
2. 사용할 때마다 `getConnection()`으로 Pool에 있는 커넥션을 빌린다.
3. 반환할 때 `Close()` 없이 Pool로 반환한다.
4. 일정 유휴 시간이 지나면 Connection을 정리한다.

#### HikariDataSource에서 벌어지는 일들

```java
public class HikariDataSource extends HikariConfig implements DataSource, Closeable {

//SpringInitialize 할 떄 getConnection을 실행시켜서 Pool을 만들어 놓는다.
//@Bean으로 등록된 DataSource가 주입될 떄 
//JPA/Hibernate가 bootstrapping할 때
	public Connection getConnection() throws SQLException {  
	    if (this.isClosed()) {  
	        throw new SQLException("HikariDataSource " + this + " has been closed.");  
	    } else if (this.fastPathPool != null) {  
	        return this.fastPathPool.getConnection();  
	    } else {  
	        HikariPool result = this.pool;  


	        if (result == null) {  
	            synchronized(this) {  
	                result = this.pool;  
	                if (result == null) {  
	                    this.validate();  
	                    LOGGER.info("{} - Starting...", this.getPoolName());  
	  
	                    try {  
	                        this.pool = result = new HikariPool(this);  
	                        this.seal();  
	                    } catch (HikariPool.PoolInitializationException pie) {  
	                        if (pie.getCause() instanceof SQLException) {  
	                            throw (SQLException)pie.getCause();  
	                        }  
	  
	                        throw pie;  
	                    }  
	  
	                    LOGGER.info("{} - Start completed.", this.getPoolName());  
	                }  
	            }  
	        }  
	  
	        return result.getConnection();  
	    }  
	}  
}
```
HikariDataSource

#### HikariPool에서 벌어지는 일들

```java
public final class HikariPool extends PoolBase implements HikariPoolMXBean, ConcurrentBag.IBagStateListener {

	public static final int POOL_NORMAL = 0;  
	public static final int POOL_SUSPENDED = 1;  
	public static final int POOL_SHUTDOWN = 2;  
	public volatile int poolState;  
	private final long aliveBypassWindowMs;  
	private final long housekeepingPeriodMs;  
	private static final String EVICTED_CONNECTION_MESSAGE = "(connection was evicted)";  
	private static final String DEAD_CONNECTION_MESSAGE = "(connection is dead)";  
	private final PoolEntryCreator poolEntryCreator;  
	private final PoolEntryCreator postFillPoolEntryCreator;  
	private final ThreadPoolExecutor addConnectionExecutor;  
	private final ThreadPoolExecutor closeConnectionExecutor;  
	private final ConcurrentBag<PoolEntry> connectionBag; //커넥션 저장소
	private final ProxyLeakTaskFactory leakTaskFactory;  
	private final SuspendResumeLock suspendResumeLock;  
	private final ScheduledExecutorService houseKeepingExecutorService; //백그라운드 하우스키퍼 실행 서비스 
	private ScheduledFuture<?> houseKeeperTask; // 유휴 커넥션 정리 및 풀 유지


	public HikariPool(HikariConfig config) {  
	    super(config);  
	    this.aliveBypassWindowMs = Long.getLong("com.zaxxer.hikari.aliveBypassWindowMs", TimeUnit.MILLISECONDS.toMillis(500L));  
	    this.housekeepingPeriodMs = Long.getLong("com.zaxxer.hikari.housekeeping.periodMs", TimeUnit.SECONDS.toMillis(30L));  
	    this.poolEntryCreator = new PoolEntryCreator();  
	    this.postFillPoolEntryCreator = new PoolEntryCreator("After adding ");  
	    this.connectionBag = new ConcurrentBag(this); 
	    this.suspendResumeLock = config.isAllowPoolSuspension() ? new SuspendResumeLock() : SuspendResumeLock.FAUX_LOCK;  
	    this.houseKeepingExecutorService = this.initializeHouseKeepingExecutorService();  
	    this.checkFailFast();  
	    if (config.getMetricsTrackerFactory() != null) {  
	        this.setMetricsTrackerFactory(config.getMetricsTrackerFactory());  
	    } else {  
	        this.setMetricRegistry(config.getMetricRegistry());  
	    }  
	  
	    this.setHealthCheckRegistry(config.getHealthCheckRegistry());  
	    this.handleMBeans(this, true);  
	    ThreadFactory threadFactory = config.getThreadFactory();  
	    int maxPoolSize = config.getMaximumPoolSize();  
	    LinkedBlockingQueue<Runnable> addConnectionQueue = new LinkedBlockingQueue(maxPoolSize);  
	    this.addConnectionExecutor = UtilityElf.createThreadPoolExecutor(addConnectionQueue, this.poolName + " connection adder", threadFactory, new UtilityElf.CustomDiscardPolicy());  
	    this.closeConnectionExecutor = UtilityElf.createThreadPoolExecutor(maxPoolSize, this.poolName + " connection closer", threadFactory, new ThreadPoolExecutor.CallerRunsPolicy());  
	    this.leakTaskFactory = new ProxyLeakTaskFactory(config.getLeakDetectionThreshold(), this.houseKeepingExecutorService);  
	    this.houseKeeperTask = this.houseKeepingExecutorService.scheduleWithFixedDelay(new HouseKeeper(), 100L, this.housekeepingPeriodMs, TimeUnit.MILLISECONDS);  
	    if (Boolean.getBoolean("com.zaxxer.hikari.blockUntilFilled") && config.getInitializationFailTimeout() > 1L) {  
	        this.addConnectionExecutor.setMaximumPoolSize(Math.min(16, Runtime.getRuntime().availableProcessors()));  
	        this.addConnectionExecutor.setCorePoolSize(Math.min(16, Runtime.getRuntime().availableProcessors()));  
	        long startTime = ClockSource.currentTime();  
	  
	        while(ClockSource.elapsedMillis(startTime) < config.getInitializationFailTimeout() && this.getTotalConnections() < config.getMinimumIdle()) {  
	            UtilityElf.quietlySleep(TimeUnit.MILLISECONDS.toMillis(100L));  
	        }  
	  
	        this.addConnectionExecutor.setCorePoolSize(1);  
	        this.addConnectionExecutor.setMaximumPoolSize(1);  
	    }  
	  
	}

	
	public Connection getConnection(long hardTimeout) throws SQLException {  
	    this.suspendResumeLock.acquire();  
	    long startTime = ClockSource.currentTime();  
	  
	    try {  
	        long timeout = hardTimeout;  
	  
	        do {   //커넥션이 죽었다면 다시 빌려줘야 하기 때문에 do-while
	            PoolEntry poolEntry = (PoolEntry)this.connectionBag.borrow(timeout, TimeUnit.MILLISECONDS);  
	            //풀에서 커넥션을 빌려온다.
	            if (poolEntry == null) {  
	                break;  
	            }  
	  
	            long now = ClockSource.currentTime();  
	            // 살아 있는지 확인
	            if (!poolEntry.isMarkedEvicted() && (ClockSource.elapsedMillis(poolEntry.lastAccessed, now) <= this.aliveBypassWindowMs || !this.isConnectionDead(poolEntry.connection))) {  
	                this.metricsTracker.recordBorrowStats(poolEntry, startTime);  
	                Connection var10 = poolEntry.createProxyConnection(this.leakTaskFactory.schedule(poolEntry));  
	                return var10;  
		            //ProxyConnection으로 감싸서 사용자에게 던진다.
	            }  
	//커넥션 실패하면 정리
	            this.closeConnection(poolEntry, poolEntry.isMarkedEvicted() ? "(connection was evicted)" : "(connection is dead)");  
	            timeout = hardTimeout - ClockSource.elapsedMillis(startTime);  
	        } while(timeout > 0L);  
	  
	        this.metricsTracker.recordBorrowTimeoutStats(startTime);  
	        throw this.createTimeoutException(startTime);  
	    } catch (InterruptedException e) {  
	        Thread.currentThread().interrupt();  
	        throw new SQLException(this.poolName + " - Interrupted during connection acquisition", e);  
	    } finally {  
	        this.suspendResumeLock.release();  
	    }  
	}

}
```
HikariPool

- `ConcurrentBag<PoolEntry> connectionBag` : 사용 가능/ 사용 중 커넥션 목록을 관리하는 핵심 데이터 구조(lock-free)
- `ThreadPoolExecutor addConnectionExecutor` : 커넥션을 비동기적으로 생성하는 Executor (커넥션이 부족할 때)
- `ScheduledExecutorService houseKeepingExecutorService` : HouseKeeper 백그라운드 정리 작업 스케쥴러