## 1. JavaBean 규약
- 정의: Java에서 재사용 가능한 컴포넌트를 만들기 위한 규약
- 요건: 
	- 기본 생성자가 있어야 한다.
	- private field, public getter/setter를 갖는 POJO여야 한다.
	- 직렬화 가능
- 상태 저장 객체를 외부 라이브러리, 컨테이너, 프레임워크가 자동으로 생성, 초기화, 주입할 수 있게 하는 형식
- 과거 JSP/Servlet, EJB, Spring XML DI 등 모두 JavaBean 규약으로 동작

## 2. Spring BeaDefinition/BeanFactory
- 모든 Bean은 JavaBean 규약을 준수
- BeanDefinition
	- 해당 객체의 타입, 생성자, 프로퍼티, 라이프사이클 등을 추상적으로 기술한 메타 정보
	- BeanFactory/ApplicationContext가 BeanDefinition을 참고해서 Bean 생성
- DI
	- 초기 XML -> Setter로 DI
	- `@Component`, `@Autowired` 등 annotation 기반으로 변경
	- 생성자, 필드 주입 등 유연성 확장
## 3. JavaConfig
- XML이 아닌 Java 코드로 DI 설정/ Bean 등록을 선언하는 방법
- 기존 XML 설정 방식이 가독성/ 유지보수성이 낮았음
	- 타입 안정성 부족, 자동완성/ 리팩토링 지원이 어려움
- 애플리케이션 로직과 설정의 결합 필요성 증가
	- 빈 생성 과정에서 조건식이 필요한 경우
	- 동적 환경 프로퍼티, 외부 연동, 컨텍스트 기반 구성 등
- 테스트 용이성/모듈화 강화
	- 여러 설정 클래스를 조합/상속 가능
	- 코드 기반 DI 환경에서 다양한 테스트/Mocking 가능
## 4. 동작
- JavaConfig -> ConfigurationClassPostProcessor
	- Spring 컨테이너가 @Configuration 클래스 스캔/파싱
	- 내부적으로 BeanDefinition 등록
	- @Bean은 CGLIB 기반 프록시로 싱글톤 보장

### 1.ConfigurationClassPostProcessor
- Spring 컨테이너가 refresh()
	- invokeBeanFactoryPostProcessor(beanFactory)
		- postProcessBeanDefinitionRegistry(registry)
			- ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry()


```java

public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, BeanRegistrationAotProcessor, BeanFactoryInitializationAotProcessor, PriorityOrdered, ResourceLoaderAware, ApplicationStartupAware, BeanClassLoaderAware, EnvironmentAware {
	
	public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {  
	    List<BeanDefinitionHolder> configCandidates = new ArrayList();  
	    String[] candidateNames = registry.getBeanDefinitionNames();  
	
	//BeanDefinition 중에서 @Configuration/@Component/@Import/@ImportResource 등 붙은 것만 
	    for(String beanName : candidateNames) {  
	        BeanDefinition beanDef = registry.getBeanDefinition(beanName);  
	        if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) {  
	        //이미 처리된 경우
	            if (this.logger.isDebugEnabled()) {  
	                this.logger.debug("Bean definition has already been processed as a configuration class: " + beanDef);  
	            }  
	        }
	        
			 else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {  
			 //후보인 경우
	            configCandidates.add(new BeanDefinitionHolder(beanDef, beanName));  
	            //리스트에 추가
	        }  
	    }  
	  
	    if (!configCandidates.isEmpty()) {  
	    //후보가 있으면
	    
	        configCandidates.sort((bd1, bd2) -> {  
	            int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());  
	            int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());  
	            return Integer.compare(i1, i2);  
	        });  
	    //우선 순위대로 정렬
	
	        SingletonBeanRegistry singletonRegistry = null;  
	        if (registry instanceof SingletonBeanRegistry) {  
	            SingletonBeanRegistry sbr = (SingletonBeanRegistry)registry;  
	            singletonRegistry = sbr;  
	            if (!this.localBeanNameGeneratorSet) {  
	                BeanNameGenerator generator = (BeanNameGenerator)sbr.getSingleton("org.springframework.context.annotation.internalConfigurationBeanNameGenerator");  
	                if (generator != null) {  
	                    this.componentScanBeanNameGenerator = generator;  
	                    this.importBeanNameGenerator = generator;  
	                }  
	            }  
	        }  
	        //BeanGenerator 준비
	  
	        if (this.environment == null) {  
	            this.environment = new StandardEnvironment();  
	        }  
	        //Environment 준비
	  
	        ConfigurationClassParser parser = new ConfigurationClassParser(this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry);  
			//ConfigurationClassParser 생성

	        Set<BeanDefinitionHolder> candidates = new LinkedHashSet(configCandidates);  
	        Set<ConfigurationClass> alreadyParsed = new HashSet(configCandidates.size());  
	  
	        do {  
	            StartupStep processConfig = this.applicationStartup.start("spring.context.config-classes.parse");  
	            parser.parse(candidates);  
	            parser.validate();  
				//파싱 및 검증

	            Set<ConfigurationClass> configClasses = new LinkedHashSet(parser.getConfigurationClasses());      
	            configClasses.removeAll(alreadyParsed);  
	            //파싱 결과 configCLasses로 추출
	            
	            if (this.reader == null) {  
	                this.reader = new ConfigurationClassBeanDefinitionReader(registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry());  
	            }  
	            //@Bean 등 모든 메타데이터를 BeanDefinition으로 변환, 등록
	  
	            this.reader.loadBeanDefinitions(configClasses);  
	            //@Bean 등 모든 메타 데이터 -> BeanDefinition으로 변환/ 등록
	        
	            alreadyParsed.addAll(configClasses); 
				
				 
	            processConfig.tag("classCount", () -> String.valueOf(configClasses.size())).end();  
	            candidates.clear();  
	            if (registry.getBeanDefinitionCount() > candidateNames.length) {  
	                String[] newCandidateNames = registry.getBeanDefinitionNames();  
	                Set<String> oldCandidateNames = Set.of(candidateNames);  
	                Set<String> alreadyParsedClasses = new HashSet();  
	  
	                for(ConfigurationClass configurationClass : alreadyParsed) {  
	                    alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());  
	                }  
	  
	                for(String candidateName : newCandidateNames) {  
	                    if (!oldCandidateNames.contains(candidateName)) {  
	                        BeanDefinition bd = registry.getBeanDefinition(candidateName);  
	                        if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) && !alreadyParsedClasses.contains(bd.getBeanClassName())) {  
	                            candidates.add(new BeanDefinitionHolder(bd, candidateName));  
	                        }  
	                    }  
	                }  
	  
	                candidateNames = newCandidateNames;  
	            }  
	        } while(!candidates.isEmpty());  
	  //파싱 후 추가된 경우가 있으면 반복
	
	        if (singletonRegistry != null && !singletonRegistry.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {  
	            singletonRegistry.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());  
	        }  
	  
	        this.propertySourceDescriptors = parser.getPropertySourceDescriptors();  
	        MetadataReaderFactory var26 = this.metadataReaderFactory;  
	        if (var26 instanceof CachingMetadataReaderFactory) {  
	            CachingMetadataReaderFactory cachingMetadataReaderFactory = (CachingMetadataReaderFactory)var26;  
	            cachingMetadataReaderFactory.clearCache();  
	        }  
//ImportRegistry, PropertySource 등 여타 정보 컨테이너 등록
	    }  
	}

}
```
