## 1. 아키텍처 계층 구조
```
Application Layer
    ↓
Retry Abstraction Layer (@Retryable, @Recover)
    ↓
Retry Operations Interface (RetryOperations)
    ↓
Retry Template (구현체)
    ↓
Retry Context (상태 관리)
    ↓
Retry Policy + BackOff Policy (전략 패턴)
```

- **관심사의 분리**: 비즈니스 로직과 재시도 로직의 완전한 분리
- **전략 패턴**: RetryPolicy, BackOffPolicy를 교체 가능한 전략으로 추상화
- **상태 관리**: RetryContext를 통한 재시도 상태의 캡슐화

## 2. AOP 프록시 메커니즘
```
@EnableRetry 
    ↓
RetryConfiguration import
    ↓
@EnableAspectJAutoProxy(proxyTargetClass = true)
    ↓
AnnotationAwareRetryOperationsInterceptor Bean 등록
    ↓
BeanPostProcessor가 @Retryable 메소드 탐지
    ↓
CGLIB으로 Proxy 서브클래스 생성
    ↓
Proxy 객체가 원본 빈 대체
```

#### CGLIB vs JDK Dynamic Proxy

- **CGLIB**:
    - 클래스 상속 기반 (final 클래스/메소드 불가)
    - 바이트코드 조작으로 서브클래스 생성
    - 인터페이스 없이도 프록시 생성 가능
- **Spring Retry는 CGLIB 강제**:
    - `@Retryable`은 concrete class에 붙기 때문
    - 메소드 시그니처 매칭 필요

#### RetryTemplate 내부 동작
```java
RetryTemplate.execute(RetryCallback<T> callback):
     RetryContext context = open(policy)  // 상태 초기화
     while (canRetry(context, lastException)) { 
        try {
            return callback.doWithRetry(context)  // 실제 메소드 실행
        } catch (Throwable e) {
            registerThrowable(context, e)  // 예외 기록
            if (!canRetry(context, e)) {
                throw e or recover()  // 재시도 불가
            }
            backOffPolicy.backOff(backOffContext)  // 대기
        }
    }
```

#### RetryContext의 역할

- **상태 패턴**: 재시도 세션의 상태를 객체로 관리
- **ThreadLocal 기반**: 스레드별 독립적인 재시도 컨텍스트 유지
- **속성 저장**:
    - `retryCount`: 현재 재시도 횟수
    - `lastException`: 마지막 발생 예외
    - `attributes`: 커스텀 메타데이터

#### RetryPolicy 인터페이스
```java
interface RetryPolicy {
	public Boolean canRetry(context: RetryContext) // 재시도 가능 여부
	public RetryContext open(parent: RetryContext?) // 컨텍스트 초기화
	public void close(context: RetryContext) // 컨텍스트 정리
	public void registerThrowable(context: RetryContext, throwable: Throwable) // 예외 등록
}
```


#### Stateless Retry (기본)
- RetryContext가 메소드 호출마다 새로 생성
- 스택에 상태 유지 (동기적)
- 간단하지만 긴 대기 시 스레드 블로킹

```java
@Retryable(stateful = true, include = [MessagingException::class])
public void processMessage(message: Message) { }
```

- RetryContext를 외부 저장소에 보관
- 메소드 재진입 시 이전 상태 복원
- 비동기/분산 환경에서 유용

#### @Recover 메소드
- 예외 타입 정확히 일치하는 메소드 탐색
- 없으면 예외의 부모 타입 메소드 탐색 (상속 계층 역순)
- 파라미터 개수/타입 일치 검증 
- 반환 타입 호환성 검증 
- 여러 개 발견 시 가장 구체적인 예외 타입 선택

```java
@Recover 
public String recover(e: IOException, id: String) // 파라미터 매칭 필요 

@Retryable
public String process(id: String) // id 파라미터와 일치해야 함
```

#### @Transactional과 상호작용
```
Client 
	↓ 
RetryProxy (바깥쪽)
	↓ 
TransactionProxy (안쪽)
	↓
Target Object 
```

- 실제 동작 추이
```
1차 시도 → 예외 → 롤백
		↓
재시도 2차 시도 → 예외 → 롤백
		↓
재시도 3차 시도 → 성공 → 커밋

```

### 3. State
|항목 |Stateless| Stateful|
|:---:|:---:|:---:|
|**상태 저장**|JVM 메모리 스택|Redis/DB|
|**상태 수명**|메소드 호출 동안만|재시도 완료까지|
|**메소드 종료 시**|상태 소멸|상태 유지|
|**스레드 대기**|sleep으로 블로킹|즉시 반환|
|**재호출 시**|처음부터 다시|이전 상태 복원|
|**분산 환경**|각 서버 독립적|여러 서버가 상태 공유|
- **Stateless**: 상태를 메모리에 보관, 한 번의 메소드 호출 내에서 모든 재시도 완료
- **Stateful**: 상태를 외부에 보관, 여러 번의 메소드 호출에 걸쳐 재시도 진행

---
### ⚠️ stateful에 대해서 
[retry template docs ](https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/retry.html#statefulRetry)에서 아래 내용 일부 발췌

> #### Stateless Retry
>
>In the simplest case, <u>a retry is just a while loop</u>. The `RetryTemplate` can just keep trying until it either succeeds or fails. The `RetryContext` contains some state to determine whether to retry or abort, but <u>this state is on the stack and there is no need to store it anywhere globally</u>, so we call this stateless retry. The distinction between stateless and stateful retry is contained in the implementation of the `RetryPolicy` (the `RetryTemplate` can handle both). In a stateless retry, the retry callback is always executed in the same thread it was on when it failed.
>
> #### [](https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/retry.html#statefulRetry)Stateful Retry
>
>Where the failure has caused a transactional resource to become invalid, there are some special considerations. This does not apply to a simple remote call because there is no transactional resource (usually), but it does sometimes apply to a database update, especially when using Hibernate. In this case it only makes sense to re-throw the exception that called the failure immediately, so that the transaction can roll back and we can start a new, valid transaction.
>
 <u>In cases involving transactions, a stateless retry is not good enough,</u> because the re-throw and roll back necessarily involve leaving the `RetryOperations.execute()` method and potentially losing the context that was on the stack. <u>To avoid losing it we have to introduce a storage strategy to lift it off the stack and put it (at a minimum) in heap storage.</u> For this purpose, Spring Batch provides a storage strategy called `RetryContextCache`, which can be injected into the `RetryTemplate`. The default implementation of the `RetryContextCache` is in memory, using a simple `Map`. A<u>dvanced usage with multiple processes in a clustered environment might also consider implementing the `RetryContextCache` with a cluster cache of some sort</u> (however, even in a clustered environment, this might be overkill).
>
 Part of the responsibility of the `RetryOperations` is to recognize the failed operations when they come back in a new execution (and usually wrapped in a new transaction). To facilitate this, Spring Batch provides the `RetryState` abstraction. This works in conjunction with a special `execute` methods in the `RetryOperations` interface.
>
 The way the failed operations are recognized is by identifying the state across multiple invocations of the retry. To identify the state, the user can provide a `RetryState` object that is responsible for returning a unique key identifying the item. The identifier is used as a key in the `RetryContextCache` interface.
>
> 	⚠️  Be very careful with the implementation of `Object.equals()` and `Object.hashCode()` in the key returned by `RetryState`. The best advice is to use a business key to identify the items. In the case of a JMS message, the message ID can be used.
>
 <u>When the retry is exhausted, there is also the option to handle the failed item in a different way, instead of calling the`RetryCallback`</u> (which is now presumed to be likely to fail). Just like in the stateless case, this option is provided by the `RecoveryCallback`, which can be provided by passing it in to the `execute` method of `RetryOperations`.
>
 The decision to retry or not is actually delegated to a regular `RetryPolicy`, so the usual concerns about limits and timeouts can be injected there (described later in this chapter).


- stateful로 설정하면 retry하는 로직 자체를 개발자가 컨트롤 해야 하는 것으로 보인다.
- spring은 상태만 유지하고 기록하는 것으로 보인다.
- 따라서 단순 stateful이 상태를 유지하고 retry를 하는 것이라기 보다는 retry를 위한 상태를 저장하는 것으로 보면 될 것 같다.