# Outbox Pattern과 Saga Pattern

## 왜 필요한가?

마이크로서비스 환경에서는 각 서비스가 독립된 데이터베이스를 가진다. 

모놀리식이라면:
```
주문 생성 → 재고 차감 → 결제 처리 (하나의 트랜잭션으로 처리)
```

마이크로서비스라면:
```
OrderService (OrderDB) → InventoryService (InventoryDB) → PaymentService (PaymentDB)
```

각 서비스가 별도 DB를 쓰기 때문에, 전통적인 ACID 트랜잭션으로 묶을 수 없다.

---

## Outbox Pattern

### 문제: Dual Write Problem

데이터를 저장하면서 동시에 이벤트를 발행해야 하는 상황:

```kotlin
@Transactional
fun createOrder(request: OrderRequest): Order {
    val order = orderRepository.save(order)  // DB 저장
    kafkaTemplate.send("order-created", event)  // 메시지 발행
    return order
}
```

여기서 발생할 수 있는 문제들:

**시나리오 1: DB 성공, 메시지 실패**
- 주문은 저장됨
- 하지만 다른 서비스들은 모름
- 결제도, 배송도 진행 안 됨

**시나리오 2: 메시지 성공, DB 실패**
- 이벤트는 발행됨
- 하지만 주문은 롤백됨
- 다른 서비스가 존재하지 않는 주문을 처리

**시나리오 3: 중복 발행**
- 네트워크 타임아웃으로 재시도
- 같은 이벤트가 두 번 발행됨

핵심 문제: **DB 트랜잭션과 메시지 발행은 서로 다른 시스템**이다. 하나의 원자적 작업으로 묶을 수 없다.

### 해결: Outbox 테이블

메시지를 DB 테이블에 먼저 저장한다. 그러면 비즈니스 데이터와 메시지가 같은 트랜잭션 안에 들어간다.

```sql
CREATE TABLE outbox_events (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    aggregate_type VARCHAR(100),  -- 'Order', 'Payment'
    aggregate_id VARCHAR(100),     -- 엔티티 ID
    event_type VARCHAR(100),       -- 'OrderCreated'
    payload JSON,                  -- 이벤트 데이터
    status VARCHAR(20),            -- 'PENDING', 'PUBLISHED'
    created_at TIMESTAMP
);
```

저장 로직:
```kotlin
@Transactional
fun createOrder(request: OrderRequest): Order {
    // 1. 비즈니스 데이터 저장
    val order = orderRepository.save(order)
    
    // 2. 이벤트를 outbox 테이블에 저장
    outboxRepository.save(OutboxEvent(
        aggregateType = "Order",
        aggregateId = order.id,
        eventType = "OrderCreated",
        payload = objectMapper.writeValueAsString(event)
    ))
    
    return order  // 두 INSERT가 하나의 트랜잭션
}
```

이제 두 작업이 하나의 DB 트랜잭션 안에 있다. 둘 다 성공하거나, 둘 다 실패한다.

### 발행 전략

Outbox에 저장된 이벤트를 실제로 Kafka로 보내는 방법:

#### 1. Polling (스케줄러)
```kotlin
@Scheduled(fixedDelay = 1000)  // 1초마다
fun relayMessages() {
    val events = outboxRepository.findPending(limit = 100)
    
    events.forEach { event ->
        kafkaTemplate.send(topic, event.payload)
        event.status = "PUBLISHED"
    }
}
```

- 장점: 구현 간단, 추가 인프라 불필요
- 단점: 폴링 주기만큼 지연, DB 부하

#### 2. CDC (Debezium)

MySQL binlog를 실시간으로 읽어서 Kafka에 발행:
- outbox 테이블에 INSERT 발생 → binlog 감지 → 즉시 Kafka 발행
- 장점: 실시간, 애플리케이션 부하 없음
- 단점: 인프라 복잡도 증가

#### 3. Transaction Log Tailing

binlog를 직접 파싱. CDC 도구 없이 커스텀 구현할 때 사용.

### Outbox의 보장과 한계

**보장하는 것:**
- At-least-once delivery (최소 한 번은 전달)
- 비즈니스 데이터와 이벤트의 원자성

**보장하지 않는 것:**
- Exactly-once (중복 가능)
- 즉시 일관성 (Eventual Consistency)

따라서 컨슈머는 멱등성을 보장해야 한다:
```kotlin
@KafkaListener(topics = ["order"])
fun handle(event: OrderCreatedEvent) {
    // 중복 체크
    if (paymentRepository.existsByOrderId(event.orderId)) {
        return  // 이미 처리됨
    }
    
    processPayment(event)
}
```

---

## Saga Pattern

### 문제: 분산 트랜잭션

주문 처리 시나리오:
```
1. OrderService: 주문 생성
2. PaymentService: 결제
3. InventoryService: 재고 차감
4. DeliveryService: 배송 요청
```

3단계에서 재고 부족 발생 → 1, 2단계를 어떻게 롤백?

모놀리식이었다면 `@Transactional`로 전체 롤백이 가능하다. 하지만 MSA에서는 각 서비스가 별도 DB를 쓰기 때문에 불가능하다.

전통적 해결책: **2PC (Two-Phase Commit)**
- 모든 서비스가 "준비됨" 응답 → Coordinator가 "커밋" 명령
- 문제점: Blocking, SPOF, 느림

### Saga의 접근

**로컬 트랜잭션 + 보상 트랜잭션**으로 해결:

```
성공 케이스:
T1(주문생성) → T2(결제) → T3(재고차감) → T4(배송)

실패 케이스 (T3에서 실패):
T1 → T2 → T3(실패) → C2(환불) → C1(주문취소)
```

각 단계는 독립적으로 실행되고, 실패 시 역순으로 보상한다.

### 구현 방식 1: Choreography (이벤트 기반)

각 서비스가 이벤트를 발행하고 구독한다. 중앙 제어자 없음.

```kotlin
// OrderService
@Transactional
fun createOrder(request: OrderRequest) {
    val order = orderRepository.save(order)
    eventPublisher.publish(OrderCreatedEvent(order.id))
}

@EventListener
fun onPaymentCompleted(event: PaymentCompletedEvent) {
    order.status = PAYMENT_COMPLETED
    eventPublisher.publish(OrderPaidEvent(order.id))
}

@EventListener
fun onPaymentFailed(event: PaymentFailedEvent) {
    order.status = CANCELLED  // 보상
}

// PaymentService
@EventListener
fun onOrderCreated(event: OrderCreatedEvent) {
    try {
        val payment = processPayment(event)
        eventPublisher.publish(PaymentCompletedEvent())
    } catch (e: Exception) {
        eventPublisher.publish(PaymentFailedEvent())
    }
}
```

**장점:**
- 서비스 간 결합도 낮음
- 새 서비스 추가 쉬움

**단점:**
- 전체 플로우 파악 어려움
- 순환 의존 위험
- 디버깅 복잡

**언제 사용:** 서비스 3~5개, 플로우 단순, 팀 자율성 중요

### 구현 방식 2: Orchestration (중앙 제어)

Orchestrator가 전체 흐름을 관리한다.

```kotlin
@Service
class OrderSagaOrchestrator {
    
    fun executeOrderSaga(request: OrderRequest) {
        val sagaId = UUID.randomUUID()
        
        try {
            // Step 1
            val order = orderService.createOrder(request)
            
            // Step 2
            val payment = paymentService.processPayment(order)
            
            // Step 3
            val inventory = inventoryService.reserve(order)
            
            // 성공
            sagaRepository.markCompleted(sagaId)
            
        } catch (e: Exception) {
            // 실패 시 보상
            compensate(sagaId)
        }
    }
    
    fun compensate(sagaId: String) {
        val steps = sagaRepository.findCompletedSteps(sagaId)
        
        steps.reversed().forEach { step ->
            when (step.name) {
                "ReserveInventory" -> inventoryService.release(step.resourceId)
                "ProcessPayment" -> paymentService.refund(step.resourceId)
                "CreateOrder" -> orderService.cancel(step.resourceId)
            }
        }
    }
}
```

Saga 상태 관리:
```sql
CREATE TABLE saga_instances (
    saga_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20),  -- STARTED, COMPLETED, COMPENSATING
    current_step VARCHAR(100)
);

CREATE TABLE saga_steps (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    saga_id VARCHAR(36),
    step_name VARCHAR(100),
    status VARCHAR(20),  -- COMPLETED, COMPENSATED
    resource_id VARCHAR(100)  -- 생성된 리소스 ID (보상 시 필요)
);
```

**장점:**
- 전체 플로우 명확
- 중앙 모니터링 쉬움
- 복잡한 로직 처리 용이

**단점:**
- Orchestrator가 SPOF
- 서비스 결합도 증가

**언제 사용:** 서비스 5개 이상, 복잡한 로직, 가시성 중요

### 보상 트랜잭션 설계

#### Semantic Lock (의미적 잠금)

즉시 실행하지 말고 "예약" 상태로 관리:

```kotlin
// ❌ 나쁜 예: 즉시 차감
fun reserve(productId: String, quantity: Int) {
    product.stock -= quantity  // 바로 차감
}

// ✅ 좋은 예: 예약 상태로 관리
fun reserve(orderId: String, productId: String, quantity: Int) {
    // 예약 레코드만 생성
    reservationRepository.save(Reservation(
        orderId = orderId,
        productId = productId,
        quantity = quantity,
        status = RESERVED  // 실제 재고는 아직 안 건드림
    ))
}

fun confirm(reservationId: String) {
    val reservation = findReservation(reservationId)
    product.stock -= reservation.quantity  // 확정 시 실제 차감
    reservation.status = CONFIRMED
}

fun cancel(reservationId: String) {
    reservation.status = CANCELLED  // 예약만 취소, 재고는 원래대로
}
```

이점:
- 취소가 간단 (예약 상태만 변경)
- 동시성 제어 명확
- 만료 시간 설정 가능

#### Pivot Transaction (보상 불가 지점)

모든 작업이 보상 가능한 것은 아니다:

```
T1: CreateOrder (보상 가능)
T2: AuthorizePayment (보상 가능)
T3: CapturePayment ← Pivot (실제 결제, 보상 어려움)
T4: ShipOrder (보상 가능하지만 비용 발생)
```

Pivot 이후 실패 → 전체 롤백 불가 → 수동 처리 필요

전략:
- Pivot 전에 모든 검증 완료
- Pivot 후 실패는 별도 프로세스 (CS 처리, 환불 정책)

#### Idempotency (멱등성)

같은 작업을 여러 번 실행해도 결과가 동일해야 함:

```kotlin
// ❌ 나쁜 예
fun refund(paymentId: String) {
    account.balance += amount  // 중복 호출 시 잔액 계속 증가
}

// ✅ 좋은 예
fun refund(paymentId: String) {
    // 이미 환불되었는지 체크
    if (payment.status == REFUNDED) {
        return  // 멱등성
    }
    
    account.balance += amount
    payment.status = REFUNDED
}
```

---

## Outbox + Saga 조합

실무에서는 두 패턴을 함께 사용:

```kotlin
// 1. OrderService: Outbox로 이벤트 저장
@Transactional
fun createOrder(request: OrderRequest) {
    val order = orderRepository.save(order)
    
    outboxRepository.save(OutboxEvent(
        eventType = "OrderCreated",
        payload = event
    ))
}

// 2. Message Relay: Outbox → Kafka
@Scheduled(fixedDelay = 1000)
fun relay() {
    val events = outboxRepository.findPending()
    events.forEach { event ->
        kafkaTemplate.send(topic, event.payload)
        event.status = "PUBLISHED"
    }
}

// 3. Saga Orchestrator: 이벤트 수신 → Saga 실행
@KafkaListener(topics = ["order-events"])
fun onOrderCreated(event: OrderCreatedEvent) {
    orderSagaOrchestrator.execute(event)
}

// 4. 각 단계마다 Outbox 사용
@Transactional
fun processPayment(orderId: String) {
    val payment = paymentRepository.save(payment)
    
    outboxRepository.save(OutboxEvent(
        eventType = if (payment.success) "PaymentCompleted" else "PaymentFailed",
        payload = payment
    ))
}
```

---

## 실무 고려사항

### 1. 타임아웃 처리

각 단계에 타임아웃 설정:
```kotlin
withTimeout(30.seconds) {
    paymentService.processPayment(order)
}
```

타임아웃 시 자동 보상 트리거

### 2. Dead Letter Queue

보상 실패 시 수동 처리 큐로:
```kotlin
try {
    paymentService.refund(paymentId)
} catch (e: Exception) {
    kafkaTemplate.send("saga-dlq", ManualCompensationRequest(
        sagaId = sagaId,
        step = "RefundPayment",
        error = e.message
    ))
    
    alertService.notify("Saga 보상 실패")
}
```

### 3. 분산 트레이싱

Correlation ID로 전체 플로우 추적:
```kotlin
data class OrderCreatedEvent(
    val orderId: String,
    val correlationId: String = UUID.randomUUID().toString()
)

// 모든 서비스에서 MDC 사용
MDC.put("correlationId", event.correlationId)
logger.info("Processing order")  // 로그에 correlationId 자동 포함
```

### 4. Outbox 정리

오래된 PUBLISHED 이벤트 삭제:
```kotlin
@Scheduled(cron = "0 0 2 * * *")  // 매일 새벽 2시
fun cleanup() {
    val threshold = Instant.now().minus(7, ChronoUnit.DAYS)
    outboxRepository.deleteByStatusAndPublishedAtBefore("PUBLISHED", threshold)
}
```

### 5. 멱등성 키

클라이언트 요청에 멱등성 키 포함:
```kotlin
@PostMapping("/orders")
fun createOrder(
    @RequestBody request: OrderRequest,
    @RequestHeader("Idempotency-Key") key: String
) {
    val existing = orderRepository.findByIdempotencyKey(key)
    if (existing != null) {
        return existing  // 중복 요청
    }
    
    val order = orderService.createOrder(request.copy(idempotencyKey = key))
    return order
}
```

---

## 정리

**Outbox Pattern:**
- 문제: DB 저장과 메시지 발행을 원자적으로 묶을 수 없다
- 해결: 메시지를 DB 테이블에 먼저 저장
- 보장: At-least-once, 트랜잭션 일관성
- 한계: Eventual Consistency, 중복 가능

**Saga Pattern:**
- 문제: 분산 환경에서 여러 서비스의 트랜잭션을 묶을 수 없다
- 해결: 로컬 트랜잭션 + 보상 트랜잭션
- 방식: Choreography (이벤트) vs Orchestration (중앙 제어)
- 핵심: Semantic Lock, Pivot, Idempotency

실무에서는 두 패턴을 조합해서 사용한다. Outbox로 이벤트 발행을 보장하고, Saga로 분산 트랜잭션을 관리한다.해서 사용한다. Outbox로 이벤트 발행을 보장하고, Saga로 분산 트랜잭션을 관리한다.

---

## 심화 패턴들

### 11. Saga Log Pattern

Saga의 모든 상태 변화를 로그로 기록해서 복구 가능하게 만든다:

```sql
CREATE TABLE saga_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    saga_id VARCHAR(36),
    sequence INT,
    event_type VARCHAR(100),  -- 'STEP_STARTED', 'STEP_COMPLETED', 'COMPENSATING'
    step_name VARCHAR(100),
    payload JSON,
    created_at TIMESTAMP
);
```

```kotlin
class SagaLogger {
    
    fun logStepStarted(sagaId: String, stepName: String, data: Any) {
        sagaLogRepository.save(SagaLogEntry(
            sagaId = sagaId,
            sequence = getNextSequence(sagaId),
            eventType = "STEP_STARTED",
            stepName = stepName,
            payload = objectMapper.writeValueAsString(data)
        ))
    }
    
    fun logStepCompleted(sagaId: String, stepName: String, result: Any) {
        sagaLogRepository.save(SagaLogEntry(
            sagaId = sagaId,
            sequence = getNextSequence(sagaId),
            eventType = "STEP_COMPLETED",
            stepName = stepName,
            payload = objectMapper.writeValueAsString(result)
        ))
    }
    
    fun recover(sagaId: String) {
        val logs = sagaLogRepository.findBySagaIdOrderBySequence(sagaId)
        
        // 마지막 완료된 단계 찾기
        val lastCompleted = logs.lastOrNull { it.eventType == "STEP_COMPLETED" }
        
        // 그 다음 단계부터 재시작
        if (lastCompleted != null) {
            resumeFromStep(sagaId, lastCompleted.stepName)
        }
    }
}
```

이점:
- Saga 실행 중 서버가 죽어도 복구 가능
- 전체 실행 히스토리 추적
- 감사(Audit) 로그

### 12. Saga Timeout과 만료 정책

장기 실행 Saga는 타임아웃과 만료 정책이 필요하다:

```kotlin
@Entity
data class SagaInstance(
    @Id
    val id: String,
    val status: SagaStatus,
    val expiresAt: Instant,  // Saga 만료 시간
    val createdAt: Instant
)

@Scheduled(fixedDelay = 60000)  // 1분마다
fun cleanupExpiredSagas() {
    val expiredSagas = sagaRepository.findByStatusAndExpiresAtBefore(
        status = SagaStatus.STARTED,
        expiresAt = Instant.now()
    )
    
    expiredSagas.forEach { saga ->
        logger.warn("Saga ${saga.id} expired, starting compensation")
        
        // 만료된 Saga는 자동 보상
        compensate(saga)
        
        saga.status = SagaStatus.EXPIRED
        sagaRepository.save(saga)
    }
}
```

만료 시간 설정:
```kotlin
fun executeOrderSaga(request: OrderRequest) {
    val saga = SagaInstance(
        id = UUID.randomUUID().toString(),
        status = SagaStatus.STARTED,
        expiresAt = Instant.now().plus(1, ChronoUnit.HOURS),  // 1시간 후 만료
        createdAt = Instant.now()
    )
    // ...
}
```

### 13. Anti-Corruption Layer (ACL)

외부 서비스와 통신할 때 ACL로 도메인 모델을 보호:

```kotlin
// 외부 결제 게이트웨이 응답
data class ExternalPaymentResponse(
    val transaction_id: String,
    val payment_status: String,  // "SUCCESS", "FAILURE", "PENDING"
    val error_code: String?
)

// 내부 도메인 모델
sealed class PaymentResult {
    data class Success(val transactionId: String) : PaymentResult()
    data class Failure(val reason: String) : PaymentResult()
    data class Pending(val transactionId: String) : PaymentResult()
}

// ACL: 외부 모델을 도메인 모델로 변환
class PaymentGatewayAdapter(
    private val externalGateway: ExternalPaymentGateway
) {
    
    fun processPayment(amount: BigDecimal): PaymentResult {
        val response = externalGateway.charge(amount)
        
        // 외부 모델 → 도메인 모델 변환
        return when (response.payment_status) {
            "SUCCESS" -> PaymentResult.Success(response.transaction_id)
            "FAILURE" -> PaymentResult.Failure(
                response.error_code ?: "Unknown error"
            )
            "PENDING" -> PaymentResult.Pending(response.transaction_id)
            else -> throw IllegalStateException("Unknown status")
        }
    }
}
```

이점:
- 외부 시스템 변경으로부터 도메인 격리
- 도메인 모델이 외부 의존성 없이 독립적
- 테스트 용이 (ACL만 모킹)

### 14. Circuit Breaker와 Saga

Saga 단계에서 외부 서비스 호출 시 Circuit Breaker 적용:

```kotlin
@Service
class PaymentService(
    private val paymentGateway: PaymentGateway,
    private val circuitBreakerRegistry: CircuitBreakerRegistry
) {
    
    fun processPayment(orderId: String, amount: BigDecimal): Payment {
        val circuitBreaker = circuitBreakerRegistry.circuitBreaker("payment-gateway")
        
        return Try.ofSupplier(
            CircuitBreaker.decorateSupplier(circuitBreaker) {
                paymentGateway.charge(orderId, amount)
            }
        ).recover { throwable ->
            when (throwable) {
                is CallNotPermittedException -> {
                    // Circuit Open: 즉시 실패
                    throw PaymentServiceUnavailableException()
                }
                else -> {
                    // 다른 오류
                    throw throwable
                }
            }
        }.get()
    }
}
```

Circuit Breaker 설정:
```yaml
resilience4j:
  circuitbreaker:
    instances:
      payment-gateway:
        failureRateThreshold: 50
        waitDurationInOpenState: 60s
        slidingWindowSize: 10
```

Circuit Open 시 Saga 동작:
- 즉시 보상 트랜잭션 실행
- 또는 재시도 큐에 추가 (나중에 처리)

### 15. Saga Versioning

Saga 로직이 변경될 때 버전 관리:

```kotlin
interface SagaExecutor {
    val version: String
    fun execute(request: OrderRequest)
}

@Service
class OrderSagaExecutorV1 : SagaExecutor {
    override val version = "v1"
    
    override fun execute(request: OrderRequest) {
        // 기존 로직: 결제 → 재고 → 배송
        processPayment(request)
        reserveInventory(request)
        createDelivery(request)
    }
}

@Service
class OrderSagaExecutorV2 : SagaExecutor {
    override val version = "v2"
    
    override fun execute(request: OrderRequest) {
        // 새 로직: 재고 먼저 확인 → 결제 → 배송
        reserveInventory(request)  // 순서 변경
        processPayment(request)
        createDelivery(request)
    }
}

@Service
class SagaVersionManager(
    private val executors: List<SagaExecutor>
) {
    
    fun execute(request: OrderRequest) {
        val version = request.sagaVersion ?: "v2"  // 기본값 최신 버전
        
        val executor = executors.find { it.version == version }
            ?: throw IllegalArgumentException("Unknown saga version: $version")
        
        executor.execute(request)
    }
}
```

실행 중인 Saga는 시작할 때 버전을 기록:
```kotlin
@Entity
data class SagaInstance(
    @Id
    val id: String,
    val version: String,  // "v1", "v2"
    val status: SagaStatus
)
```

이점:
- 새 버전 배포 후에도 기존 Saga 계속 실행 가능
- 점진적 마이그레이션
- 롤백 시 안전

### 16. Saga와 Long-Running Transaction

일부 Saga는 며칠씩 실행될 수 있다 (예: 배송 완료 대기):

```kotlin
@Service
class LongRunningSagaManager {
    
    fun createOrderSaga(request: OrderRequest) {
        val saga = SagaInstance(
            id = UUID.randomUUID().toString(),
            type = "OrderSaga",
            status = SagaStatus.STARTED
        )
        
        // Step 1-3: 즉시 실행
        val order = orderService.createOrder(request)
        val payment = paymentService.processPayment(order)
        val delivery = deliveryService.createDelivery(order)
        
        // Step 4: 배송 완료 대기 (며칠 소요)
        saga.currentStep = "WAITING_FOR_DELIVERY"
        saga.waitingUntil = delivery.estimatedArrival
        sagaRepository.save(saga)
        
        // 즉시 종료 (배송 완료 이벤트를 기다림)
    }
    
    @EventListener
    fun onDeliveryCompleted(event: DeliveryCompletedEvent) {
        val saga = sagaRepository.findByDeliveryId(event.deliveryId)
        
        if (saga.currentStep == "WAITING_FOR_DELIVERY") {
            // Step 5: Saga 재개
            confirmInventory(saga)
            
            saga.status = SagaStatus.COMPLETED
            sagaRepository.save(saga)
        }
    }
}
```

주의사항:
- Saga 인스턴스를 DB에 저장 (메모리 X)
- 만료 정책 필수
- 모니터링 강화 (대기 중인 Saga 추적)

### 17. Parallel Saga Steps

일부 단계는 병렬로 실행 가능:

```kotlin
suspend fun executeOrderSaga(request: OrderRequest) {
    val sagaId = UUID.randomUUID().toString()
    
    try {
        // Step 1: 주문 생성
        val order = orderService.createOrder(request)
        
        // Step 2-3: 병렬 실행
        val (payment, inventory) = coroutineScope {
            val paymentDeferred = async {
                executeStep(sagaId, "ProcessPayment") {
                    paymentService.processPayment(order)
                }
            }
            
            val inventoryDeferred = async {
                executeStep(sagaId, "ReserveInventory") {
                    inventoryService.reserve(order)
                }
            }
            
            paymentDeferred.await() to inventoryDeferred.await()
        }
        
        // Step 4: 배송 (병렬 완료 후)
        val delivery = deliveryService.createDelivery(order)
        
    } catch (e: Exception) {
        compensate(sagaId)
    }
}
```

병렬 실행 시 주의:
- 한 단계 실패 시 모든 병렬 단계 취소
- 보상도 병렬로 실행 가능
- 동시성 제어 (공유 리소스 접근)

### 18. Saga와 Event Notification

Saga 진행 상황을 사용자에게 알림:

```kotlin
@Service
class SagaNotificationService(
    private val notificationService: NotificationService
) {
    
    @EventListener
    fun onStepCompleted(event: SagaStepCompletedEvent) {
        when (event.stepName) {
            "ProcessPayment" -> {
                notificationService.send(
                    userId = event.userId,
                    message = "결제가 완료되었습니다."
                )
            }
            "CreateDelivery" -> {
                notificationService.send(
                    userId = event.userId,
                    message = "상품이 발송되었습니다. 송장번호: ${event.trackingNumber}"
                )
            }
        }
    }
    
    @EventListener
    fun onSagaFailed(event: SagaFailedEvent) {
        notificationService.send(
            userId = event.userId,
            message = "주문 처리 중 오류가 발생했습니다. 고객센터로 문의해주세요.",
            priority = NotificationPriority.HIGH
        )
    }
}
```

### 19. Saga Metrics와 성능 모니터링

Saga 성능 지표 수집:

```kotlin
@Aspect
@Component
class SagaMetricsAspect(
    private val meterRegistry: MeterRegistry
) {
    
    @Around("@annotation(SagaStep)")
    fun measureStepDuration(joinPoint: ProceedingJoinPoint): Any? {
        val stepName = joinPoint.signature.name
        val timer = Timer.start(meterRegistry)
        
        return try {
            val result = joinPoint.proceed()
            
            timer.stop(Timer.builder("saga.step.duration")
                .tag("step", stepName)
                .tag("status", "success")
                .register(meterRegistry))
            
            meterRegistry.counter("saga.step.count",
                "step", stepName,
                "status", "success"
            ).increment()
            
            result
            
        } catch (e: Exception) {
            timer.stop(Timer.builder("saga.step.duration")
                .tag("step", stepName)
                .tag("status", "failure")
                .register(meterRegistry))
            
            meterRegistry.counter("saga.step.count",
                "step", stepName,
                "status", "failure"
            ).increment()
            
            throw e
        }
    }
}
```

수집 지표:
- Saga 실행 시간
- 단계별 성공/실패율
- 보상 실행 빈도
- 대기 중인 Saga 개수

### 20. Saga Testing 전략

Saga는 테스트하기 어렵다. 여러 전략을 조합:

#### 단위 테스트: 각 단계 독립 테스트
```kotlin
@Test
fun `결제 처리 성공`() {
    val payment = paymentService.processPayment(orderId, amount)
    
    assertThat(payment.status).isEqualTo(PaymentStatus.COMPLETED)
    verify(paymentGateway).charge(orderId, amount)
}

@Test
fun `결제 실패 시 예외 발생`() {
    whenever(paymentGateway.charge(any(), any()))
        .thenThrow(PaymentException("Insufficient funds"))
    
    assertThrows<PaymentException> {
        paymentService.processPayment(orderId, amount)
    }
}
```

#### 통합 테스트: Saga 전체 플로우
```kotlin
@SpringBootTest
@AutoConfigureTestDatabase
class OrderSagaIntegrationTest {
    
    @Test
    fun `주문 Saga 성공 플로우`() {
        val request = OrderRequest(customerId = "user1", items = listOf(...))
        
        val result = orderSagaOrchestrator.execute(request)
        
        assertThat(result).isInstanceOf(SagaResult.Success::class.java)
        
        // 각 단계 검증
        val order = orderRepository.findById(result.orderId)
        assertThat(order.status).isEqualTo(OrderStatus.COMPLETED)
        
        val payment = paymentRepository.findByOrderId(result.orderId)
        assertThat(payment.status).isEqualTo(PaymentStatus.COMPLETED)
    }
    
    @Test
    fun `재고 부족 시 보상 트랜잭션 실행`() {
        // 재고 부족 상황 설정
        inventoryService.setStock(productId, 0)
        
        val request = OrderRequest(...)
        
        val result = orderSagaOrchestrator.execute(request)
        
        assertThat(result).isInstanceOf(SagaResult.Failure::class.java)
        
        // 보상 확인
        val order = orderRepository.findById(result.orderId)
        assertThat(order.status).isEqualTo(OrderStatus.CANCELLED)
        
        val payment = paymentRepository.findByOrderId(result.orderId)
        assertThat(payment.status).isEqualTo(PaymentStatus.REFUNDED)
    }
}
```

#### Contract Testing: 서비스 간 계약 검증
```kotlin
@AutoConfigureStubRunner(
    ids = ["com.example:payment-service:+:stubs:8081"],
    stubsMode = StubRunnerProperties.StubsMode.LOCAL
)
class PaymentServiceContractTest {
    
    @Test
    fun `결제 API 계약 검증`() {
        val response = restTemplate.postForEntity(
            "http://localhost:8081/payments",
            PaymentRequest(orderId = "order1", amount = 10000),
            PaymentResponse::class.java
        )
        
        assertThat(response.statusCode).isEqualTo(HttpStatus.OK)
        assertThat(response.body?.status).isEqualTo("COMPLETED")
    }
}
```

#### Chaos Engineering: 장애 주입 테스트
```kotlin
@Test
fun `결제 서비스 타임아웃 시 Saga 보상`() {
    // Chaos Monkey: 결제 서비스 응답 지연
    chaosMonkey.enableLatency(
        service = "payment-service",
        latency = Duration.ofSeconds(35)  // Saga timeout은 30초
    )
    
    val result = orderSagaOrchestrator.execute(request)
    
    assertThat(result).isInstanceOf(SagaResult.Failure::class.java)
    assertThat(result.reason).contains("timeout")
    
    // 보상 실행 확인
    verify(orderService).cancel(any())
}
```

### 21. Saga와 Blue-Green Deployment

새 버전 배포 시 Saga 처리:

```kotlin
@Service
class SagaDeploymentManager {
    
    fun drainSagas() {
        // 1. 새 Saga 생성 중단
        sagaFactory.stopAcceptingNew()
        
        // 2. 실행 중인 Saga 대기
        while (sagaRepository.countByStatus(SagaStatus.STARTED) > 0) {
            logger.info("Waiting for ${sagaRepository.countByStatus(SagaStatus.STARTED)} sagas to complete")
            Thread.sleep(5000)
        }
        
        // 3. 배포 가능 신호
        logger.info("All sagas completed, ready for deployment")
    }
    
    fun resumeSagas() {
        // 새 버전 시작 후 Saga 재개
        sagaFactory.startAcceptingNew()
        
        // 배포 중 대기한 요청 처리
        processPendingRequests()
    }
}
```

### 22. Saga Replay (재실행)

실패한 Saga를 재실행:

```kotlin
@Service
class SagaReplayService {
    
    fun replay(sagaId: String) {
        val saga = sagaRepository.findById(sagaId)
        
        require(saga.status == SagaStatus.FAILED) {
            "Can only replay failed sagas"
        }
        
        // 새 Saga ID 생성
        val newSagaId = UUID.randomUUID().toString()
        
        // 원본 요청 데이터로 재실행
        val originalRequest = objectMapper.readValue<OrderRequest>(saga.payload)
        
        logger.info("Replaying saga $sagaId as $newSagaId")
        
        orderSagaOrchestrator.execute(originalRequest.copy(
            sagaId = newSagaId,
            isReplay = true,
            originalSagaId = sagaId
        ))
    }
}
```

---



---

## 정리

**Outbox Pattern:**
- 문제: DB 저장과 메시지 발행을 원자적으로 묶을 수 없다
- 해결: 메시지를 DB 테이블에 먼저 저장
- 보장: At-least-once, 트랜잭션 일관성
- 한계: Eventual Consistency, 중복 가능
- 보완: Inbox Pattern으로 Exactly-once 달성

**Saga Pattern:**
- 문제: 분산 환경에서 여러 서비스의 트랜잭션을 묶을 수 없다
- 해결: 로컬 트랜잭션 + 보상 트랜잭션
- 방식: Choreography (이벤트) vs Orchestration (중앙 제어)
- 핵심: Semantic Lock, Pivot, Idempotency
- 확장: State Machine, Process Manager, Event Sourcing

**고급 패턴:**
- Inbox Pattern: 중복 메시지 방지
- Saga Log: 복구 가능성
- ACL: 외부 시스템으로부터 도메인 보호
- Circuit Breaker: 장애 전파 차단
- Versioning: 점진적 마이그레이션
- Parallel Steps: 성능 최적화
- Metrics: 성능 모니터링
- Replay: 실패 복구

실무에서는 이 패턴들을 조합해서 사용한다. Outbox로 이벤트 발행을 보장하고, Saga로 분산 트랜잭션을 관리하며, 추가 패턴들로 안정성과 관찰 가능성을 높인다.