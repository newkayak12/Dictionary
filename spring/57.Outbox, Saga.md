# Outbox Pattern과 Saga Pattern

## 왜 필요한가?

마이크로서비스 환경에서는 각 서비스가 독립된 데이터베이스를 가진다. 

모놀리식이라면:
```
주문 생성 → 재고 차감 → 결제 처리 (하나의 트랜잭션으로 처리)
```

마이크로서비스라면:
```
OrderService (OrderDB) → InventoryService (InventoryDB) → PaymentService (PaymentDB)
```

각 서비스가 별도 DB를 쓰기 때문에, 전통적인 ACID 트랜잭션으로 묶을 수 없다.

---

## Outbox Pattern

### 문제: Dual Write Problem

데이터를 저장하면서 동시에 이벤트를 발행해야 하는 상황:

```kotlin
@Transactional
fun createOrder(request: OrderRequest): Order {
    val order = orderRepository.save(order)  // DB 저장
    kafkaTemplate.send("order-created", event)  // 메시지 발행
    return order
}
```

여기서 발생할 수 있는 문제들:

**시나리오 1: DB 성공, 메시지 실패**
- 주문은 저장됨
- 하지만 다른 서비스들은 모름
- 결제도, 배송도 진행 안 됨

**시나리오 2: 메시지 성공, DB 실패**
- 이벤트는 발행됨
- 하지만 주문은 롤백됨
- 다른 서비스가 존재하지 않는 주문을 처리

**시나리오 3: 중복 발행**
- 네트워크 타임아웃으로 재시도
- 같은 이벤트가 두 번 발행됨

핵심 문제: **DB 트랜잭션과 메시지 발행은 서로 다른 시스템**이다. 하나의 원자적 작업으로 묶을 수 없다.

### 해결: Outbox 테이블

메시지를 DB 테이블에 먼저 저장한다. 그러면 비즈니스 데이터와 메시지가 같은 트랜잭션 안에 들어간다.

```sql
CREATE TABLE outbox_events (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    aggregate_type VARCHAR(100),  -- 'Order', 'Payment'
    aggregate_id VARCHAR(100),     -- 엔티티 ID
    event_type VARCHAR(100),       -- 'OrderCreated'
    payload JSON,                  -- 이벤트 데이터
    status VARCHAR(20),            -- 'PENDING', 'PUBLISHED'
    created_at TIMESTAMP
);
```

저장 로직:
```kotlin
@Transactional
fun createOrder(request: OrderRequest): Order {
    // 1. 비즈니스 데이터 저장
    val order = orderRepository.save(order)
    
    // 2. 이벤트를 outbox 테이블에 저장
    outboxRepository.save(OutboxEvent(
        aggregateType = "Order",
        aggregateId = order.id,
        eventType = "OrderCreated",
        payload = objectMapper.writeValueAsString(event)
    ))
    
    return order  // 두 INSERT가 하나의 트랜잭션
}
```

이제 두 작업이 하나의 DB 트랜잭션 안에 있다. 둘 다 성공하거나, 둘 다 실패한다.

### 발행 전략

Outbox에 저장된 이벤트를 실제로 Kafka로 보내는 방법:

#### 1. Polling (스케줄러)
```kotlin
@Scheduled(fixedDelay = 1000)  // 1초마다
fun relayMessages() {
    val events = outboxRepository.findPending(limit = 100)
    
    events.forEach { event ->
        kafkaTemplate.send(topic, event.payload)
        event.status = "PUBLISHED"
    }
}
```

- 장점: 구현 간단, 추가 인프라 불필요
- 단점: 폴링 주기만큼 지연, DB 부하

#### 2. CDC (Debezium)

MySQL binlog를 실시간으로 읽어서 Kafka에 발행:
- outbox 테이블에 INSERT 발생 → binlog 감지 → 즉시 Kafka 발행
- 장점: 실시간, 애플리케이션 부하 없음
- 단점: 인프라 복잡도 증가

#### 3. Transaction Log Tailing

binlog를 직접 파싱. CDC 도구 없이 커스텀 구현할 때 사용.

### Outbox의 보장과 한계

**보장하는 것:**
- At-least-once delivery (최소 한 번은 전달)
- 비즈니스 데이터와 이벤트의 원자성

**보장하지 않는 것:**
- Exactly-once (중복 가능)
- 즉시 일관성 (Eventual Consistency)

따라서 컨슈머는 멱등성을 보장해야 한다:
```kotlin
@KafkaListener(topics = ["order"])
fun handle(event: OrderCreatedEvent) {
    // 중복 체크
    if (paymentRepository.existsByOrderId(event.orderId)) {
        return  // 이미 처리됨
    }
    
    processPayment(event)
}
```

---

## Saga Pattern

### 문제: 분산 트랜잭션

주문 처리 시나리오:
```
1. OrderService: 주문 생성
2. PaymentService: 결제
3. InventoryService: 재고 차감
4. DeliveryService: 배송 요청
```

3단계에서 재고 부족 발생 → 1, 2단계를 어떻게 롤백?

모놀리식이었다면 `@Transactional`로 전체 롤백이 가능하다. 하지만 MSA에서는 각 서비스가 별도 DB를 쓰기 때문에 불가능하다.

전통적 해결책: **2PC (Two-Phase Commit)**
- 모든 서비스가 "준비됨" 응답 → Coordinator가 "커밋" 명령
- 문제점: Blocking, SPOF, 느림

### Saga의 접근

**로컬 트랜잭션 + 보상 트랜잭션**으로 해결:

```
성공 케이스:
T1(주문생성) → T2(결제) → T3(재고차감) → T4(배송)

실패 케이스 (T3에서 실패):
T1 → T2 → T3(실패) → C2(환불) → C1(주문취소)
```

각 단계는 독립적으로 실행되고, 실패 시 역순으로 보상한다.

### 구현 방식 1: Choreography (이벤트 기반)

각 서비스가 이벤트를 발행하고 구독한다. 중앙 제어자 없음.

```kotlin
// OrderService
@Transactional
fun createOrder(request: OrderRequest) {
    val order = orderRepository.save(order)
    eventPublisher.publish(OrderCreatedEvent(order.id))
}

@EventListener
fun onPaymentCompleted(event: PaymentCompletedEvent) {
    order.status = PAYMENT_COMPLETED
    eventPublisher.publish(OrderPaidEvent(order.id))
}

@EventListener
fun onPaymentFailed(event: PaymentFailedEvent) {
    order.status = CANCELLED  // 보상
}

// PaymentService
@EventListener
fun onOrderCreated(event: OrderCreatedEvent) {
    try {
        val payment = processPayment(event)
        eventPublisher.publish(PaymentCompletedEvent())
    } catch (e: Exception) {
        eventPublisher.publish(PaymentFailedEvent())
    }
}
```

**장점:**
- 서비스 간 결합도 낮음
- 새 서비스 추가 쉬움

**단점:**
- 전체 플로우 파악 어려움
- 순환 의존 위험
- 디버깅 복잡

**언제 사용:** 서비스 3~5개, 플로우 단순, 팀 자율성 중요

### 구현 방식 2: Orchestration (중앙 제어)

Orchestrator가 전체 흐름을 관리한다.

```kotlin
@Service
class OrderSagaOrchestrator {
    
    fun executeOrderSaga(request: OrderRequest) {
        val sagaId = UUID.randomUUID()
        
        try {
            // Step 1
            val order = orderService.createOrder(request)
            
            // Step 2
            val payment = paymentService.processPayment(order)
            
            // Step 3
            val inventory = inventoryService.reserve(order)
            
            // 성공
            sagaRepository.markCompleted(sagaId)
            
        } catch (e: Exception) {
            // 실패 시 보상
            compensate(sagaId)
        }
    }
    
    fun compensate(sagaId: String) {
        val steps = sagaRepository.findCompletedSteps(sagaId)
        
        steps.reversed().forEach { step ->
            when (step.name) {
                "ReserveInventory" -> inventoryService.release(step.resourceId)
                "ProcessPayment" -> paymentService.refund(step.resourceId)
                "CreateOrder" -> orderService.cancel(step.resourceId)
            }
        }
    }
}
```

Saga 상태 관리:
```sql
CREATE TABLE saga_instances (
    saga_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20),  -- STARTED, COMPLETED, COMPENSATING
    current_step VARCHAR(100)
);

CREATE TABLE saga_steps (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    saga_id VARCHAR(36),
    step_name VARCHAR(100),
    status VARCHAR(20),  -- COMPLETED, COMPENSATED
    resource_id VARCHAR(100)  -- 생성된 리소스 ID (보상 시 필요)
);
```

**장점:**
- 전체 플로우 명확
- 중앙 모니터링 쉬움
- 복잡한 로직 처리 용이

**단점:**
- Orchestrator가 SPOF
- 서비스 결합도 증가

**언제 사용:** 서비스 5개 이상, 복잡한 로직, 가시성 중요

### 보상 트랜잭션 설계

#### Semantic Lock (의미적 잠금)

즉시 실행하지 말고 "예약" 상태로 관리:

```kotlin
// ❌ 나쁜 예: 즉시 차감
fun reserve(productId: String, quantity: Int) {
    product.stock -= quantity  // 바로 차감
}

// ✅ 좋은 예: 예약 상태로 관리
fun reserve(orderId: String, productId: String, quantity: Int) {
    // 예약 레코드만 생성
    reservationRepository.save(Reservation(
        orderId = orderId,
        productId = productId,
        quantity = quantity,
        status = RESERVED  // 실제 재고는 아직 안 건드림
    ))
}

fun confirm(reservationId: String) {
    val reservation = findReservation(reservationId)
    product.stock -= reservation.quantity  // 확정 시 실제 차감
    reservation.status = CONFIRMED
}

fun cancel(reservationId: String) {
    reservation.status = CANCELLED  // 예약만 취소, 재고는 원래대로
}
```

이점:
- 취소가 간단 (예약 상태만 변경)
- 동시성 제어 명확
- 만료 시간 설정 가능

#### Pivot Transaction (보상 불가 지점)

모든 작업이 보상 가능한 것은 아니다:

```
T1: CreateOrder (보상 가능)
T2: AuthorizePayment (보상 가능)
T3: CapturePayment ← Pivot (실제 결제, 보상 어려움)
T4: ShipOrder (보상 가능하지만 비용 발생)
```

Pivot 이후 실패 → 전체 롤백 불가 → 수동 처리 필요

전략:
- Pivot 전에 모든 검증 완료
- Pivot 후 실패는 별도 프로세스 (CS 처리, 환불 정책)

#### Idempotency (멱등성)

같은 작업을 여러 번 실행해도 결과가 동일해야 함:

```kotlin
// ❌ 나쁜 예
fun refund(paymentId: String) {
    account.balance += amount  // 중복 호출 시 잔액 계속 증가
}

// ✅ 좋은 예
fun refund(paymentId: String) {
    // 이미 환불되었는지 체크
    if (payment.status == REFUNDED) {
        return  // 멱등성
    }
    
    account.balance += amount
    payment.status = REFUNDED
}
```

---

## Outbox + Saga 조합

실무에서는 두 패턴을 함께 사용:

```kotlin
// 1. OrderService: Outbox로 이벤트 저장
@Transactional
fun createOrder(request: OrderRequest) {
    val order = orderRepository.save(order)
    
    outboxRepository.save(OutboxEvent(
        eventType = "OrderCreated",
        payload = event
    ))
}

// 2. Message Relay: Outbox → Kafka
@Scheduled(fixedDelay = 1000)
fun relay() {
    val events = outboxRepository.findPending()
    events.forEach { event ->
        kafkaTemplate.send(topic, event.payload)
        event.status = "PUBLISHED"
    }
}

// 3. Saga Orchestrator: 이벤트 수신 → Saga 실행
@KafkaListener(topics = ["order-events"])
fun onOrderCreated(event: OrderCreatedEvent) {
    orderSagaOrchestrator.execute(event)
}

// 4. 각 단계마다 Outbox 사용
@Transactional
fun processPayment(orderId: String) {
    val payment = paymentRepository.save(payment)
    
    outboxRepository.save(OutboxEvent(
        eventType = if (payment.success) "PaymentCompleted" else "PaymentFailed",
        payload = payment
    ))
}
```

---

## 실무 고려사항

### 1. 타임아웃 처리

각 단계에 타임아웃 설정:
```kotlin
withTimeout(30.seconds) {
    paymentService.processPayment(order)
}
```

타임아웃 시 자동 보상 트리거

### 2. Dead Letter Queue

보상 실패 시 수동 처리 큐로:
```kotlin
try {
    paymentService.refund(paymentId)
} catch (e: Exception) {
    kafkaTemplate.send("saga-dlq", ManualCompensationRequest(
        sagaId = sagaId,
        step = "RefundPayment",
        error = e.message
    ))
    
    alertService.notify("Saga 보상 실패")
}
```

### 3. 분산 트레이싱

Correlation ID로 전체 플로우 추적:
```kotlin
data class OrderCreatedEvent(
    val orderId: String,
    val correlationId: String = UUID.randomUUID().toString()
)

// 모든 서비스에서 MDC 사용
MDC.put("correlationId", event.correlationId)
logger.info("Processing order")  // 로그에 correlationId 자동 포함
```

### 4. Outbox 정리

오래된 PUBLISHED 이벤트 삭제:
```kotlin
@Scheduled(cron = "0 0 2 * * *")  // 매일 새벽 2시
fun cleanup() {
    val threshold = Instant.now().minus(7, ChronoUnit.DAYS)
    outboxRepository.deleteByStatusAndPublishedAtBefore("PUBLISHED", threshold)
}
```

### 5. 멱등성 키

클라이언트 요청에 멱등성 키 포함:
```kotlin
@PostMapping("/orders")
fun createOrder(
    @RequestBody request: OrderRequest,
    @RequestHeader("Idempotency-Key") key: String
) {
    val existing = orderRepository.findByIdempotencyKey(key)
    if (existing != null) {
        return existing  // 중복 요청
    }
    
    val order = orderService.createOrder(request.copy(idempotencyKey = key))
    return order
}
```

---

## 정리

**Outbox Pattern:**
- 문제: DB 저장과 메시지 발행을 원자적으로 묶을 수 없다
- 해결: 메시지를 DB 테이블에 먼저 저장
- 보장: At-least-once, 트랜잭션 일관성
- 한계: Eventual Consistency, 중복 가능

**Saga Pattern:**
- 문제: 분산 환경에서 여러 서비스의 트랜잭션을 묶을 수 없다
- 해결: 로컬 트랜잭션 + 보상 트랜잭션
- 방식: Choreography (이벤트) vs Orchestration (중앙 제어)
- 핵심: Semantic Lock, Pivot, Idempotency

실무에서는 두 패턴을 조합해서 사용한다. Outbox로 이벤트 발행을 보장하고, Saga로 분산 트랜잭션을 관리한다.