# 설계 원칙

- SOLID는 함수와 데이터 구조를 클래스로 배치하는 방법
- 이 클래스 간의 상호 작용을 하는 방법을 설명한다.
- SOLID를 준수하면 아래와 같은 장점이 있다.
> 1. 변경에 유연하다.
> 2. 이해하기 쉽다.
> 3. 컴포넌트의 기반이 된다.
- 즉 모듈과 컴포넌트 내부에서 사용되는 SW 구조를 정의하는데 도움을 준다.

> 1. SRP: 단일 책임 원칙 -> SW 모듈은은 변경 이유가 하나여야 한다.
> 2. OCP: 개방 폐쇄 원칙 -> 새로운 코드를 추가하는 방식으로 시스템 행위를 변경할 수 있어야 한다.
> 3. LSP: 리스코프치환 원칙 -> 상호 대체 가능한 구성요소를 이용해 SW를 만들 수 있으려면, 이들 구성 요소는 서로 치환이 가능해야 한다는 계약
> 4. ISP: 인터페이스 분리 원칙 -> 설계자는 사용하지 않는 것에 의존하지 않아야 한다.
> 5. DIP: 의존성 역전 원칙 -> 세부 사항이 정책에 의존해야 한다.


## SRP
- 하나의 모듈이 하나의 일만 하는 것이 아니다.
- 단일 모듈의 변경의 이유가 하나, 오직 하나뿐이어야 한다는 것이다.
- 즉, 하나의 모듈은 하나의 actor에 대해서만 책임져야 한다.
- 이는 변경되는 상황에서의 전파도를 낮출 수 있어야 한다는 것, 변경될 것과 아닌 것을 분리해야 한다는 의미로까지 해석할 수 있다.
- 이 원칙을 위반하는 징후들은 아래와 같다.

### 1. 유사해 보이는 케이스 뒤섞기
- 분리할지 말지를 고민하는 경우가 생기게 된다. 단순하게 한두 개쯤 차이점이 있는 경우 말이다.
- 결과적으로 이 차이점을 무시하고 찰흙처럼 뭉쳐두면  서로 다른 lifeCycle, 목적으로 사용되면서 서로 다른 이유로 수정을 해야할 필요가 생긴다.
- 서로 다른 액터가 의존해야 할 대상을 하나로 뭉쳐두면 이 덩어리는 괴물이 되어버린다.

### 2. 잦은 병합
- 협업을 하면서 왠지 모르게 병합이 잦아진다면 고민해볼 필요가 있다. 
- 충돌을 해결하는 것도 일이지만 서로 다른 목적을 가진 기능을 한 곳에 밀어 넣고 있을지도 모른다.

### 결론
- SRP는 메소드, 클래스 수준의 원칙이다.
- 위와 같은 이상 징후를 보인다면 같은 것과 다른 것을 분리하는 방법을 고려해봄직 하다.
- 추가로 SRP는 컴포넌트 레벨, 아키텍쳐 레벨에서도 적용할 수 있다. 
- 컴포넌트 레벨은 Common Closure Principle(공통 폐쇄 원칙)이 된다. 
- 아키텍쳐 레벨은 Architecture Boundary 생성을 책임지는 Axis of Change(변경의 축)이 된다.

## OCP
- 개채의 행위는 확장할 수 있어야 하지만, 이 때 개체를 변경하면 안 된다는 원칙이다.
- 작은 수정에 기존이 흔들이면 연쇄적으로 이에 의존하고 있는 부분도 흔들리게 될 것이다.
- 이를 위해서는 책임에 대한 분리, 의존성 역전 등을 해둬야 한다.
- 이는 아키텍쳐를 떠받치는 원동력으로 작용하며, 시스템을 확장하기 쉬운 동시에 변경에 대한 파급력이 적을 수 있는 방향으로 유도해준다.


## LSP
- 'S 타입의 객체와 T 타입에 대응하는 객체가 있을 때 S 타입에 대응하는 객체 O1이 T 타입의 객체 O2 대신 놓였을 때도 행위가 변하지 않는다면 S는 T의 하위 타입이다.'는 의미다.
- 자주 나오는 주제로 상속, 구현이 있다. 결론부터 말하면 서브 타이핑이 필요하며, 서브 클래싱을 위한 상속은 큰 의미가 없다는 것이다.
- 처음에는 LSP는 상속을 사용하도록 유도하는 장치 정도로 간주됐었다.
- LSP는 시간이 지남에 따라서 인터페이스와 구현체에도 적용되는 설계원칙으로 변모됐다.
- LSP를 준수하도록 만들어져 있다면 서브타이핑 하나로 새로운 기능을 추가할 수 있지만 아니라면 새롭게 코드를 작성해야 하는 안타까운 경우가 발생할 수도 있다.
- LSP는 아키텍쳐 레벨까지 확장해야만 한다. 그게 아니라면 아키텍쳐가 오염되어 위의 언급과 같이 별도 메커니즘을 추가해야 할 수 있기 때문이다.

## ISP
- 정적 타입 언어는 `import` 등의 타입 선언문을 강제한다.
- 소스코드에 선언된 선언문으로 소스 코드 의존성이 발생하고, 이로 인해 재컴파일, 재배포가 강제되는 상황이 무조건 초래된다.
- ISP를 사용하는 근본적인 동기는 필요 이상으로 많은 것을 포함하는 모듈에 의존하는 것에 대한 인지로부터 시작된다.
- 불필요한 재컴파일, 재배포를 강제하기 때문이다.

## DIP
- '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
- 의존에서 피하고자 하는 것은 변동성이 큰 구체적 요소다. 이는 인터페이스보다 변동성이 높다.
- 인터페이스를 변경하지 않고 구현체를 수정할 수 있으며, 외부에서는 인터페이스에 의존하면 안정된 아키텍쳐를 얻을 수 있다.
