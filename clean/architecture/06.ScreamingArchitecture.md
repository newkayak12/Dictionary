# 소리치는 아키텍쳐

- 소리치는 아키텍쳐, 상위 수준의 디렉토리 구조, 최상위 패키지에 담긴 소스파일 이름 등을 보고 목적을 유추할 수 있는가를 의미한다.
- 좋은 아키텍쳐는 UseCase를 중심에 둔다. 더 나아가 외부의 '어떤 것'에도 흔들리지 않고 UseCase를 지원하는 구조를 기술할 수 있어야 한다.
- 아키텍처의 외부를 신경쓰는 것은 UseCase를 다 채운 이후에나 관심을 가져야 한다.
- 절대로 세부 사항이 시스템 구조를 뒤흔들어서는 안된다.
- 더 나아가 프레임워크는 도구일 뿐이다. 절대로 프레임워크에 좌우되면 안된다. 따라서 "어떻게 하면 아키텍쳐를 UseCase에 중점을 둔 채 그대로 보존할 수 있을지를 고민해보라."
- UseCase를 최우선으로 하면, 프레임워크랑 거리를 적당히 둔다면 UseCase 전부, 단위테스트를 할 수 있어야 한다.

## 아키텍쳐
- 소리치는 아키텍쳐를 위한 어느 정도의 공식은 있다.
> 1. Hexagonal
> 2. Data, Context and Interaction(DCI) : 읽기 쉽고, 사람의 사고 방식에 가까운 코드 구조를 만들기 위한 시도 
>    - Data: 
>      - OOP의 엔티티, 도메인 모델에 해당한다.
>      - 주로 상태를 보관하고 로직은 거의 없다.
>      - '자료'에 가깝다.
>    - Context:
>      - UseCase가 실행되는 환경을 정의
>      - 어떤 객체가 어떤 역할로 어떻게 상호작용할지 지정 
>    - Interaction:
>      - Role에 따른 Behavior를 정의
>      - "이 컨텍스트 내에서 이 역할을 맡은 객체는 이런 행동을 해야 한다"는 식이다.
>    - 사람의 사고 흐름과 코드를 일치시키려는 시도다.
>    - 시스템이 무엇을 하는지가 코드에서 묻어난다.
> 3. Boundary-Control-Entity(BCE) : 관심사 분리를 돕기 위한 아키텍쳐 패턴, 각 구성 요소는 시스템의 서로 다른 책임을 나누어 가지고 있어서 유지보수, 확장성을 높임
>    - Boundary: 
>      - 시스템과 외부의 인터페이스를 담당
>      - UI, API, 입력 처리 등의 역할
>      - 외부 요청을 받아서 Control에 전달
>    - Control:
>      - 애플리케이션 로직, 흐름 제어를 담당
>      - Boundary로부터 받은 요청을 받아 적절한 엔티티와 상호작용하고, 결과를 다시 Boundary로 전달
>      - UseCase를 수행하는 중심부
>    - Entity:
>      - 도메인 객체, 핵심 비즈니스 로직과 상태를 가진 객체
>      - 시스템의 장기적인 정보를 담고, 재사용 가능한 비즈니스 규칙을 구현
>    - DDD에 주로 응용된다.

- 모두 관심사의 분리가 중심에 있다. 
- 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

## 의존성 규칙
- 외부 layer는 내부 layer를 알지만 내부에서는 외부를 알지 못한다.

### 엔티티
- 전체적인 핵심 업무 규칙을 캡슐화한다.
- 엔티티는 가장 일반적이며 고수준인 규칙을 캡슐화한다.
- 외부와 격리되어 있으며 pure하다. 엔티티가 변경될 가능성은 지극히 낮다.

### UseCase
- 애플리케이션에 특화된 업무 규칙을 포함한다.
- UseCase 계층 SW는 시스템의 모든 UseCase를 캡슐화하고 구현한다. 
- 엔티티가 자신의 핵심 업무 규칙을 사용해서 UseCase의 목적을 달성하도록 이끈다.

### adapter
- 데이터를 UseCase, Entity에서 DB, Web으로 보내야할 형식으로 바꾼다.
- 역시나 안에 속한 어떤 사항도 알면 안된다.

### 경계 횡단
- 제어 흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용해서 해결한다.
- 동적 다형성으로 소스 코드 의존성을 제어 흐름과 반대로 만들 수 있다.
- 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.