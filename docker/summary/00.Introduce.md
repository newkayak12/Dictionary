# 도커

매 번 같은 환경을 구축하는 것은 꽤나 번거롭다. 그렇다고 VM을 복사해서 늘리는 방식은 비효율적이다. VM자체가 무겁기 때문이다. VM의 가장 큰 
문제는 쓸데 없이 GuestOS까지 올려야 했기 때문이다. 도커는 이런 부분에 대한 필요성으로 나왔다. 도커는 VM보다 오버헤드가 적다.

도커는 chroot, cgroup, namespace으로 이를 가능케 한다.


## Linux의 chroot
리눅스 파일트리는 Root에서 비롯된다. root 아래 `chroot`로 특정 디렉토리를 root로 설정하면 chroot jail이 생성된다. 이는 jail 바깥과
단절시키는 역할을 한다. 보통 계정별 root를 설정해서 접근 관리를 하는데 사용됐다. 그러나 완전히 외부와 봉쇄되기 때문에 실행 파일, 라이브러리를
손수 준비해야 했다.

## LXC
리눅스 커널 레벨에서 격리된 공간이다. 각 공간마다. 애플리케이션을 실행하기 위한 모든 것을 포함하는 완전한 파일시스템과 실행 환경을 제공한다.
cgroup + namespace를 결합한 결과다.

### namespace
리눅스에서 프로세스를 격리시킬 수 있는 가상화 기술이다. namespace는 자원의 종류를 제한한다.  그런고로 프로세스 실행 시 시스템의 리소스를 분리해서 실행 가능하게 해준다. 


#### 종류

|종류 |설명 |
|:---:|:---:|
|PID|Process ID를 격리하여, 네임스페이스 외 다른 프로세스에 접근이 불가능하게 합니다.|
|NetWork|	IP, 포트, 라우팅 테이블 등 네트워크 리소스를 격리합니다.|
|User	|프로세스별 UID, GID 정보를 격리합니다.|
|Mount	|프로세스별 마운트되는 파일시스템을 격리합니다. 지정된 파일시스템을 루트처럼 생각하여 동작하게됩니다.|
|IPC	|IPC(프로세스간 통신)를 격리하여, 다른 프로세스의 접근이나 제어를 방지합니다.|
|UTS	|호스트명이나 도메인 명을 격리합니다.|
|Time	|시간을 격리시킬 수 있습니다.|
|cgroup	|프로세스는 /proc/self/cgroup에 가상화된 새로운 cgroup 마운트를 가지게됩니다.|

`ls -alh /proc/{PID}/ns` 이렇게 조회할 수 있다.

#### 생성
`unshare`로 생성한다. 다양한 옵션이 있다.

>
> 옵션
> 
> - -i, --ipc: IPC 네임스페이스의 공유를 해제합니다. 파일이 지정된 경우 영구 네임스페이스는 바인드 마운트에 의해 생성됩니다.
> - -m, --mount : 마운트 네임스페이스를 공유 해제합니다
> - -p, --pid : PID 네임스페이스의 공유를 해제합니다.
> - -u, --uts : UTS 네임스페이스 공유를 해제합니다.
> - -U, --user : 사용자 네임스페이스 공유를 해제합니다.
> - -C, --cgroup : cgroup 네임스페이스 공유를 해제합니다.
> - -T, --time : 시간 네임스페이스 공유를 해제합니다.
> - -f, --fork : 지정된 프로그램을 실행하지 않고 공유 해제의 하위 프로세스로 포크합니다. 새로운 PID 네임스페이스를 생성할 때 유용합니다.
> - --keep-caps --user : 옵션이 주어지면 사용자에게 권한이 부여되었는지 확인합니다.
> - --kill-child : 공유하제가 종료되면 포크된 자식 프로세스로 신호 이름을 보내도록 합니다.
> - --mount-proc : 프로그램을 실행하기 직전 proc 파일 시스템을 mountpoint에 마운트 합니다 (기본값 /proc)
> - --mpa-user=uid : uid가 매핑된 후에만 프로그램을 실행합니다.
> - --map-group=gid : gid가 매핑된 후에만 프로그램을 실행합니다.

#### 통신
격리된 NameSpace 간의 통신은 VETH(Virtual Ethernet)를 통해서 한다. 

### cgroup
리눅스 커널의 기능이다. 프로세스에 대한 그룹화와 시스템 리소스(CPU, 메모리, 디스크, 네트워크 자원들과 같은 컴퓨팅 리소스)를 
제어(수집, 제한, 격리) 가능하게 해주는 기능이다.

1. 리소스 제한 : cgroup으로 할당된 CPU 시간, 메모리 사용량, I/O 대역폭 등을 제한할 수 있다. 이를 통해서 시스템의 안정성을 높이고 리소스 사용을 효율적으로 관리할 수 있다.
2. 우선순위 할당 : 다른 프로세스 그룹에 서로 다른 CPU 스케쥴링 우선순위 또는 I/O 대역폭 우선순위를 할당할 수 있다.
3. 계정 및 보고 : cgroup을 사용하면 시스템 리소스 사용에 대한 상세한 보고와 분석이 가능하다. 
4. 프로세스 관리 : 프로세스를 그룹으로 관리할 수 있게 해준다.

 














---------------------
[참고](https://medium.com/@devjohnpark/docker%EC%9D%98-%EB%B3%80%EC%B2%9C%EC%82%AC-9dfa764b217e)
[참고](https://www.44bits.io/ko/keyword/linux-namespace)
[참고](https://velog.io/@_gyullbb/1-1.-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B2%A9%EB%A6%AC)
[참고](https://jaykos96.tistory.com/31)



## LXC에서 libcontainer으로 변경

도커는 기존 LXC에서 libcontainer로 변경하였다. 이는
LXC 위에 libContainer란 별도의 실행 드라이버를 올려서 실행하는 식이다. 그래서 GO lang으로 컨테이너를 구동시킬 수 있게 됐다.
이는 리눅스에 대한 의존도를 줄이려는 시도 중 하나다.

1. LXC는 하나의 컨테이너에 여러 프로그램을 띄울 수 있지만 도커는 이를 권장하지 않는다.
> 1컨테이너 1프로그램에 대한 장점
> 1. 다른 프로젝트에서 재사용 가능
> 2. 보안 및 격리에서 얻는 이점이 있음
> 3. 결합도가 낮아서 업데이트 시 간섭이 없음
> 4. MSA 구성에 효율적

2. LXC는 캡쳐가 없지만 Docker에는 캡쳐가 존재 (스냅샷)
3. 도커는 레이어 기반으로 재사용하는 구조로 이뤄져 있음
