# 쿠버네티스

컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼이다. 쿠버네티스틑 선언적 구성과 자동화를 모두 용이하게 해준다.


## 장점
1. 서버 자원 클러스터링, 마이크로서비스 구조의 컨테이너 배포, 서비스 장애 복구 등 컨테이너 기반의 서비스 운영에 필요한 대부분의 오케스트레이션 기능을 지원
2. 영속성 볼륨(Persistent Volume) : 스케쥴링, 장애복구, 오토스케일링, 서비스 디스커버리 및 인그레스 등 컨테이너 기반의 클라우드를 운영할 때 필요한 대부분의 기능과
컴포넌트를 사용자가 직접 커스터마이징할 수 있다.

![k8 _ https://www.redhat.com/ko/topics/containers/what-is-kubernetes](./img/k8.png)


## 모든 리소스는 오브젝트 형식으로 관리된다.
모든 리소스는 오브젝트 형태로 관리된다. 예를들어 컨테이너 집합과 이를 관리하는 컨트롤러, 사용자, 노드까지도 오브젝트로 관리할 수 있다.


### 구조
![master-node](./img/masternode.png)

> 전체 클러스터를 관리하는 마스터, 컨테이너가 배포되는 노드로 구성되어 있다.
> 모든 명령은 Master API 서버를 호출하고 노드는 마스터와 통신하면서 필요한 작업을 수행한다.
> 특정 노드의 컨테이너에 명령하거나 로그를 조회할 때도 노드에 직접 명령하는게 아니라 마스터를 통해서 진행한다.

1. Namespace
> - 물리 클러스터 내의 복수의 가상 클러스터
 
2. Master
> - 마스터 서버는 다양한 모듈이 확장성을 고려하여 기능별로 쪼개져 있는 것이 특징이다.
> - 관리자만 접속할 수 있도록 보안 설정이 필요하고 마스터는 보통 홀수 개로 클러스터링한다.

3. Node
> - kubelet, kube-proxy, 동작 중인 pod를 유지시키고 런타임 환경을 제공한다.
> - 노드 서버는 마스터 서버와 통신하면서 필요한 Pod를 생성하고 네트워크와 볼륨을 설정한다.
> - 실제 컨테이너가 생성되는 곳이다.
> - 각각 서버에 라벨을 붙여서 사용 목적을 정의할 수도 있다.

4. Kubectl
> - json, protobuf를 이용한 http 통신을 지원한다.
> - kubectl이라는 명령행 도구를 사용한다.


## Controlplane( MasterNode )
![ControlPlane](./img/master.png)

클러스터에 관한 전반적인 결정(scheduling)을 수행하고 클러스터 이벤트를 감지하고 반응한다.
보통 MasterNode는 단독으로 사용자 컨테이너와 분리하여 구성한다.

### kube-apiserver
- 컨트롤 플레인 컴포넌트
- API 서버는 쿠버네티스 컨트롤 플레인의 프론트엔드이다.
- 쿠버네티스 클러스터의 중심 역할을 하는 통로다.

### etcd
- 모든 클러스터 데이터를 담는 쿠버ㅔ티스 뒷단의 저장소로 사용되는 일관성, 고가용성 k-v 저장소다.
- etcd를 복제해두면 장애가 나더라도 시스템의 가용성을 확보할 수 있다.

### kube-scheduler
- 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해서 pod를 어떤 워커 노드로 뿌릴지 결정 및 할당한다.
- cpu, gpu, memory 등 상태 관리

### kube-controller-manager
- 컨트롤러 프로세스를 실행하는 컨트롤 플레인 컴포넌트
- 쿠버네티스에 있는 거의 모든 오브젝트의 상태를 관리한다.
- Deployment는 ReplicaSet을 생성하고 ReplicaSet은 Pod를 생성하고 Pod는 스케쥴러가 관리하는 식이다.

### cloud-controller-manager
- 클라우드 특화 모듈


## Node 컴포넌트( Worker Node )

![worker](./img/node.png)

노드 컴포넌트는 동작 중인 pod을 유지하고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작

### kublet agent
- pod의 구성 내용을 받아서 컨테이너 런타임으로 전달
- 포드 안의 컨테이너들이 정상적으로 작동하는지 모니터링
- kublet은 다양한 메커니즘을 통해 제공된 podSpec을 받아서 컨테이너가 해당 podSpec 따라 동작하는 것을 확정함
- pod 상태를 확인하고 마스터로 전달


### kube-proxy
- pod로 연결되는 네트워크를 관리한다.
- kube-proxy를 통해서 포드가 통신할 수 있는 네트워크를 설정한다.

### 컨테이너 런타임
- 컨테이너 런타임은 컨테이너 실행을 담당하는 소프트웨어


## YAML
YAML로 컨테이너 리소스를 명시적으로 생성하거나 삭제할 수 있다. YAML로는 컨테이너, 모든 리소스 오브젝트들에 사용될 수 있다.
설정값(ConfigMap), 비밀 값(Secrets) 등도 YAML로 정의해서 사용한다.

### 쿠버네티스 기본 세팅

1. apiVersion : 오브젝트 API 버전 ( Pod | ReplicaSet | Deployment | Service )
2. kind : YAML 파일에서 생성하려는 Object 여기서는 Pod
3. metadata : 라벨, 주석, 이름 등과 같은 리소스의 부가 정보
4. spec : 리소스를 생성하기 위한 자세한 정보



## 컴포넌트
쿠버넨티스 노드의 역할은 master-worker로 나뉘어 있다. 마스터는 클러스터를 관리하는 역할을 담당하고, 워커 노드는 애플리케이션 컨테이너가 생성된다.

## Pod : 컨테이너를 다루는 기본 단위
컨테이너 애플리케이션을 구동하기 위해서 반드시 알아야 할 몇 가지 오브젝트가 있다.

### 1. Pod
- 컨테이너 애플리케이션의 기본 단위 ( 1포드 - 1개 이상의 컨테이너가 존재할 수도 있다.)
- 도커 컨테이너와의 차이점 : 여러 리눅스 네임스페이스를 공유하는 여러 컨테이너들을 추상화된 집합으로 사용하기 위해서 
- 완전한 애플리케이션으로서의 포드 : 1개 이상의 컨테이너가 들어설 수는 있지만 보통 1포드 - 1컨테이너로 사용하는 경우가 많다.
- 기능 확장을 위한 추가 컨테이너 : 사이드카 패턴을 통해서 기존 컨테이너를 수정하지 않고 원하는 추가 기능(Logging 등)을 붙이는 식으로 사용할 수 있다.

 ```yaml
spec:
  containers:
    - name: <name>
      images: <imageName>
      ports:
        - containerPort: 
          protocol: TCP
 ```

### 2. ReplicaSet
- 포드의 항상성을 유지해주는 컨트롤러 : 포드가 컨테이너를 추상화해서 하나의 애플리케이션으로 동작하게 만드는 컨테이너 묶음이라면 레플리카셋은 포드의 개수를 일정하게 유지해주는 컨트롤러다.
- 포드에 대한 생성/관리를 쿠버네티스에게 맡기는 시작 포인트 : 직접 생성하면 쿠버네티스가 관리하는 것이 아니라 장애 발생 등에 대응하기 힘들다. 
- 항상성 : 정해진 수의 동일한 포드가 실행되도록 관리해준다. 만일 노드 장애 등이 발생하면 다른 노드에서 포드를 다시 생성한다. (노드 구분 없이 전체 개수를 일정하게 유지할 수 있게 관리해주는 컨트롤러다.)

```yaml
spec:
  replicas: <count> #유지시킬 개수다.
  selector:
    matchLabels:
      app: <appName>
  template:  ## 이 아래로는 포드 생성 시 사용할 템플릿을 정의한다. 포드 스펙, 포드 템플릿이라고 한다.
    metadata:
      name: <replicaSetName>
      labels:
        app: <name>
```

- 느슨한 연결 : 레플리카셋과 포드가 결합되어 있지 않다. 라벨 셀렉터를 통해서 느슨한 연결을 유지하고 있다.
> 라벨은 서로 다른 오브젝트가 서로를 찾아야 할 때 사용되기도 한다. `spec.selector.matchLabel`에 정의된 라벨을 통해서 생성되야할 포드를 찾는다. 

### 3. Deployment

- 레플리카셋의 상위 오브젝트
- 업데이트와 배포를 용이하게 : 디플로이먼트는 컨테이너 애플리케이션을 배포하고 관리하는 역할을 한다.
- 리비전 : 업데이트 시 옵션에 따라서 이전 버전으로 롤백이 용이하도록  리비전을 남겨둔다.(--record)
- 리비전 발생 레플리카 통쨰로 DESRIED, CURRENT로 나눠서 관리한다. 이렇게 디플로이먼트는 여러 개의 레플리카셋을 관리한다.
- 포드의 롤링 업데이트 정책을 사용할 수도 있다.

### 4. Service
- 포드를 연결하고 외부에 노출
- 포드 IP는 고정이 아니라 유동이다. 그래서 하나의 애플리케이션으로 엮으려면 서로 port를 알수 있게 해야한다.
- 포드는 기본적으로 외부 미노출이 원칙이다.
- 다른 디플로이먼트의 포드들이 외부적으로 접근하려면 서비스를 통해야 한다.
- 여러 개의 포드에 쉽게 접근할 수 있도록 고유한 도메인 이름을 부여한다.
- 요청을 분산하는 로드밸런서 기능을 수행한다.
- 클라우드 플랫폼의 로드 밸런서, 클러스터 노드의 포트 등을 통해서 포드를 외부로 노출한다.
- 어떻게 접근할 것이냐에 따라 여러 개로 세분화할 수 있다.

> 1. ClusterIP : 쿠버네티스 내부에서만 포드들에 접근할 때 사용
>    - 따로 무언가를 하지 않아도 서비스와 연결된 여러 개의 포드에 자동으로 요청이 분산된다.
>    - 또한 서비스에는 IP 뿐만 아니라 서비스 이름 그 자체로도 접근할 수 있다.
>    - 쿠버네티스는 애플리케이션이 서비스나 포드를 쉽게 찾을 수 있도록 내부 DNS를 구동하고 있으며, 포드들은 자동으로 이 DNS를 사용하도록 설정되기 때문이다.
>    - 보통 클러스터 내부에서 서로를 찾아서 연결해야할 경우 서비스 이름만 알면 되니, 포드의 IP를 알 필요가 없으며, 서비스 이름으로 간단히 접근할 수 있다.   
> 
> ```yaml
> spec:
>   ports:
>     - name: web-port
>       port: 8080 # 쿠버네티스 내부에서만 사용할 수 있는 고유한 IP를 할당 받는다. 서비스의 IP에 접근할 때 사용할 포트를 설정한다. 
>       targetPort: 80 # 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하고 있는 포트를 입력한다.
>   selector:
>     app: webServer # 어떤 라벨을 가지는 포드에 접근할 수 있게 만들 것인지 결정한다.
>   type: ClusterIP # Cluster | NodePort | LoadBalancer 등 설정할 수 있다.
> ```
>
>  2. NodePort : 포드에 접근할 수 있는 포트를 클러스터의 모든 노드에 동일하게 개방
>     - 클러스터 외부에서도 접근할 수 있다. 동일한 서비스 리소스이기 때문에 라벨 셀렉터, 포트 설정 등과 같은 기본 항목의 사용 방법은 모두 같다.
>     - 생성하면 내,외부 모두 접근할 수 있는 포트가 열리고 해당 포트로 접근하면 동일한 서비스에 연결할 수 있다.
>     - 추가적으로 `NodePort`는 `ClusterIP`를 포함하고 있다. 즉, ClusterIP 기능이 외부로 포트가 열린다는 추가적인 부분이 있다는 것 빼고는 크게 다른점이 없다.
>     - 솔직히 NodePort로 두고 쓸 일이 별로 없다. 대신 `Ingress`라는 쿠버네티스 오브젝트를 두고 쓰는 경우가 많다.
>
> ```yaml
> spec:
>   ports:
>     - name: web-port
>       port: 8080 # 쿠버네티스 내부에서만 사용할 수 있는 고유한 IP를 할당 받는다. 서비스의 IP에 접근할 때 사용할 포트를 설정한다.
>       targetPort: 80 # 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하고 있는 포트를 입력한다.
>       nodePort: 31000
>   selector:
>     app: webServer # 어떤 라벨을 가지는 포드에 접근할 수 있게 만들 것인지 결정한다.
>   type: NodePort # Cluster | NodePort | LoadBalancer 등 설정할 수 있다.
>
> ```
> 3. LoadBalancer : 클라우드 플랫폼에서 제공하는 로드밸런서를 동적으로 프로비저닝해 포드에 연결
>    - 서비스 생성과 동시에 로드 밸런서를 새롭게 생성해서 포드와 연결한다. 클라우드 플랫폼으로부터 도메인 이름, IP를 할당받기 때문에 NodePort보다 더 쉽게 접근할 수 있다.
>    - 로드밸런서를 동적으로 생성하는 기능을 제공하는 환경에서만 사용할 수 있다.
>    - 생성 후 외부 IP는 해당 클라우드의 외부 접근 도메인, 아이피가 할당된다.
>    - 생성과 동시에 모든 워커 노드는 포드에 접근할 수 있는 랜덤 포트를 개방하고 로드밸런서에 알린다.
>    - 로드 밸런서는 요청을 워커 노드로 밸런싱하여 요청을 전달한다.
>    - NodePort의 기능을 간접, 자동으로 사용할 수 있다.
>    - anntation으로 로드밸런서 타입을 명시할 수도 있다.(AWS)
>    
> ```yaml
> apiVersion: v1
> kind: Service
> metadata: 
>   name: hostname-svc-nlb
>   annotations:
>       service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
> spec:
>   ports:
>     - name: web-port
>       port: 80 # 쿠버네티스 내부에서만 사용할 수 있는 고유한 IP를 할당 받는다. 서비스의 IP에 접근할 때 사용할 포트를 설정한다.
>       targetPort: 80 # 항목에서 정의한 라벨에 의해 접근 대상이 된 포드들이 내부적으로 사용하고 있는 포트를 입력한다.
>   selector:
>     app: webServer # 어떤 라벨을 가지는 포드에 접근할 수 있게 만들 것인지 결정한다.
>   type: LoadBalancer # Cluster | NodePort | LoadBalancer 등 설정할 수 있다.
>
> ```   
>

- 트래픽 분배를 결정하는 서비스 속성: externalTrafficPolicy
  - `externalTrafficPolicy: Cluster`는 NodePort, LoadBalancer의 기본 동작이다.
  - `externalTrafficPolicy: Local`은 포드가 생성된 노드에서만 포드로 접근할 수 있다. 로컬 노드한 포드 중 하나로 요청이 전달된다.
  - 이 설정은 불필요한 네트워크 홉을 줄일 수 있다는 장점이 있다. 또한 요청 리다이렉트로 NAT이 발생하여 클라이언트 IP 보존할 수 없는 문제도 해결될 수 있다.
  - 이 설정은 요청이 고르게 분산되는 것을 막는다.
- 요청을 외부로 리다이렉트하는 서비스: ExternalName
  - 서비스가 외부 도메인을 가리키도로 설정할 수 있다. 해당 서비스에 접근하면 쿠버네티스 DNS는 특정 CNAME을 뱉게 된다.

```yaml
apiVersion: v1
kind: Service
metadata: 
  name: external-svc
spec:
  type: ExternalName
  externalName: record.host.com
```   


## Resource : 리소스 관리와 설정

### 1. Namespace

### 2. ConfigMap

### 3. Secret