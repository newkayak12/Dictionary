

### 다중키 인덱스
필드 값이 배열이고, 이를 인덱스로 잡는 경우를 다중 키 인덱스(multiKey Index)라고 한다. 이렇게 구성하면 인덱스 내의 여러 개의 엔트리가
동일한 도큐먼트를 지시하게 된다. 예를 들어보자.

```mongodb-json
{
    name: "Apple",
    tags: ["iPhone", "iPad", "appleWatch", "visionPro", "macbookPro", "macbookAir"]

}
```

tags에 다중키 인덱스를 잡았다면 여러 개의 인덱스 엔트리가 같은 도큐먼트를 지시하고 있다. 이와 같이 배열 내 요소는 각자 자신만의 엔트리를 가지고 있다.
이렇게 인덱스를 사용할 수 있지만 역시나 비용은 만만치 않다. 


### 해시 인덱스
해시 함수를 통해서 인덱스를 구성하는 경우를 해시 인덱스라고 한다. 

`db.table.createIndex({element:'hashed'})`

와 같이 구성할 수 있다. 해시 인덱스는 원본을 해싱하므로 몇 가지 제약 사항이 있다.

1. $eq 쿼리는 동일하게 동작하지만 범위 쿼리는 지원하지 않는다.(해싱되었으므로 원본 값을 가지고 범위 쿼리는 불가능하다.)
2. 다중 키 해시 인덱스는 허용되지 않는다.
3. 부동소수점은 해시되기 전에 정수로 변환된다.

해시 인덱스는 인덱스의 엔트리가 균등하게 분배된다는 장점이 있다. 


## 관리

### 생성, 삭제
 
- `createIndex()` 로 생성한다. (`db.target.createIndex({indexName:1})`)
- `db.system.indexes.find().pretty()`로 인덱스를 검증할 수 있다.
- deleteIndexes로 삭제할 수 있다. (`db.runCommand({deleteIndexes: "user", index: "zip"})`)
- `dropIndex()`로 삭제할 수 있다. (`db.target.dropIndex("indexName")`)


### 선언
인덱스 만들기가 굉장히 쉽다. 그래서 러닝 중이던 준비 중이던 인덱스를 잡아야 할 떄가 생길 수 있다. 그러나, 러닝 중이라면 더 고민해보자.
인덱스 구축은 오랜시간이 걸린다. 일종의 마이그레이션으로 봐도 크게 다르지 않을 수 있다.


### 과정 (인덱스 구축)
1. 인덱스할 값을 정렬한다.
2. B-Tree에 추가된다.
3. 정렬된 값들이 인덱스로 삽입된다.

이 과정이 데이터 수가 많다면 오래 걸릴 수가 있다.

### 백그라운드 인덱싱
그래서 인덱스 구축을 백그라운드에서 할 수도 있다. 물론 쓰기 잠금은 걸리지만 중간중간 읽기, 쓰기를 허용하기 위해서 잠시간 멈추면서 진행된다.

`db.target.createIndex({key: 1}, {background: true})`로 백그라운드에서 인덱스를 생성할 수 있다.


### 리인덱싱

기존 데이터의 업데이트, 삭제가 대량으로 발생하면 아무리 인덱스가 재구성한다고 하더라도 단편화는 피할 수 없다. 이런 경우 인덱스를 재구축할 필요가 생긴다.

`db.target.reIndex()`
